commit 2a6f7324a5957e8cc16977bc2bc775818e0e28a6
Merge: 085fc12 34eb188
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Sun Nov 24 21:31:21 2013 -0500

    Merge branch 'master' of
    https://github.com/danielle-mustillo/ECSE-211-Team-5.git
    
    Conflicts:
    	src/utilities/Settings.java

commit 085fc12b3b7292d0cea071c7a87380b0a7091a84
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Sun Nov 24 21:29:17 2013 -0500

    The code almost works now. The robot sometimes misses a block but that
    seems to be more of a hardware calibration and testing thing. The
    DropOff function still throws exceptions which must be handled. However,
    the Recognize function does not properly drive forward to get to the
    block and grab it. All functionality is there except for the drive
    forward to get the blue block between the sponges.

diff --git a/src/controllers/Collect.java b/src/controllers/Collect.java
index 4c0af54..44c9e36 100644
--- a/src/controllers/Collect.java
+++ b/src/controllers/Collect.java
@@ -30,30 +30,33 @@ private static boolean setup = false;
 		/*
 		 * Setup will stop the robot, add a new destination closer to the object to pick it up
 		 */
-		if (!setup) {
-			setup = true;
-
-			// stop navigation for the moment.
-			oldRoute = manager.sm.nav.getRoute();
-			manager.sm.nav.setRoute(new Stack<Point>());
-			manager.hm.drive.stop();
-
-			// setup claw and navigate towards the block
-			Sound.twoBeeps();
-			Forklift.setHeight(ForkliftState.GROUND);
-			sleep(Claw.releaseObject());
-			Position currentPos = manager.sm.odo.getPosition();
-			
-			//navigate towards block
-			final int clawOffset = Settings.clawToUSDistance;
-//			int distance = manager.hm.ultrasonicPoller.getUSReading(1) - clawOffset < 0 ? 0 : manager.hm.ultrasonicPoller.getUSReading(1) - clawOffset;
-//			manager.sm.nav.addToRoute(currentPos.addDistanceToPosition(15));
-		}
+//		if (!setup) {
+//			setup = true;
+//
+//			// stop navigation for the moment.
+//			oldRoute = manager.sm.nav.getRoute();
+//			manager.sm.nav.setRoute(new Stack<Point>());
+//			manager.hm.drive.stop();
+//
+//			// setup claw and navigate towards the block
+//			Sound.twoBeeps();
+//			Forklift.setHeight(ForkliftState.GROUND);
+//			
+//			
+//			
+//			//navigate towards block
+////			int distance = manager.hm.ultrasonicPoller.getUSReading(1) - clawOffset < 0 ? 0 : manager.hm.ultrasonicPoller.getUSReading(1) - clawOffset;
+//			
+//		}
 		/*
 		 * Once the robot is in position to pickup the object, it will then grab the object and lift it. 
 		 * It will then pass on control to DropOff.java or Search.java depending on if the block "hopper" is full. 
 		 */
-		if (manager.sm.nav.getRoute().empty()) {
+//		RConsole.println(""+manager.sm.nav.getRoute().empty());
+//		if(!manager.sm.nav.getRoute().empty()) {
+//			RConsole.println(""+manager.sm.nav.getRoute().peek());
+//		}
+//		if (manager.sm.nav.getRoute().empty()) {
 			// grab and lift
 			sleep(Claw.grabObject());
 			sleep(Forklift.setHeight(ForkliftState.LIFT_HEIGHT));
@@ -70,7 +73,7 @@ private static boolean setup = false;
 			
 			//clean up method.
 			setup = false;
-		}
+//		}
 	}
 	
 	public static void sleep(int num) {
diff --git a/src/controllers/Recognize.java b/src/controllers/Recognize.java
index ce8eaa0..407a306 100644
--- a/src/controllers/Recognize.java
+++ b/src/controllers/Recognize.java
@@ -5,6 +5,7 @@ import java.util.Stack;
 import services.Navigation;
 import utilities.Point;
 import utilities.Position;
+import utilities.Settings;
 import hardwareAbstraction.Claw;
 import hardwareAbstraction.ColorPoller.ObjectDetected;
 import hardwareAbstraction.Forklift;
@@ -23,7 +24,7 @@ private Manager manager;
 	}
 	
 	public void run() {
-		manager.cm.setState(State.COLLECT);
+//		manager.cm.setState(State.COLLECT);
 		
 		//do nothing else, don't call recognize again. 
 		manager.cm.setState(State.PAUSE);
@@ -69,13 +70,17 @@ private Manager manager;
 		ObjectDetected object = manager.hm.colorPoller.getObjectReading();
 		if (object == ObjectDetected.BLUE_BLOCK) {
 			manager.sm.nav.setRoute(oldRoute);
-			manager.cm.setState(State.COLLECT);
+			Position currentPos = manager.sm.odo.getPosition();
+//			manager.sm.nav.addToRoute(currentPos.addDistanceToPosition(10));
+			sleep(Claw.releaseObject());
+//			if(manager.sm.nav.getRoute().empty())
+				manager.cm.setState(State.COLLECT);
 		} else {
 			//reset old route
 			manager.sm.nav.setRoute(oldRoute);
 			manager.cm.setState(State.SEARCH); // TODO change to wall follower.
 		}
-
+		manager.hm.colorPoller.stop();
 	}
 	
 	public static void sleep(int num) {
diff --git a/src/hardwareAbstraction/Forklift.java b/src/hardwareAbstraction/Forklift.java
index 3c1114b..da67a76 100644
--- a/src/hardwareAbstraction/Forklift.java
+++ b/src/hardwareAbstraction/Forklift.java
@@ -9,7 +9,7 @@ public class Forklift {
 	static NXTRemoteMotor lift = Settings.liftMotor;
 	static int liftHeight = 15; // 15 cm upwards. Should be ok
 	static int scanHeight = 10; // 10 cm upwards. Needs to be tested. 
-	static int scanHeightLow = 7; // 7 cm upwards. Needs to be tested. 
+	static int scanHeightLow = 8; // 7 cm upwards. Needs to be tested. 
 	private static double radius = 1; //radius of "spool". Must be tested. 
 	public static ForkliftState state = ForkliftState.GROUND; //sensor starts on the ground.
 //	/**
diff --git a/src/launcher/Launcher.java b/src/launcher/Launcher.java
index e98b223..65ca31f 100644
--- a/src/launcher/Launcher.java
+++ b/src/launcher/Launcher.java
@@ -36,7 +36,7 @@ public class Launcher {
 	 * @param args
 	 */
 	public static void main(String[] args) {
-		RConsole.openUSB(20000);
+//		RConsole.openUSB(20000);
 		
 		Manager manager = new Manager();
 		Button.waitForPress();
@@ -46,13 +46,16 @@ public class Launcher {
 			e.printStackTrace();
 		}
 		
-		manager.cm.setState(State.SEARCH);
 		
-		/*manager.sm.localization.start();
 		
-		while(manager.cm.getState() == State.LOCALIZING) {
-			manager.um.nap(150);
-		}*/
+//		manager.sm.localization.start();
+//		
+//		while(manager.cm.getState() == State.LOCALIZING) {
+//			manager.um.nap(150);
+//		}
+		
+		
+		manager.cm.setState(State.SEARCH);
 		
 //		manager.sm.odo.adjustPosition(180, 0, Math.PI);
 //		manager.sm.odoCorrection.start();
diff --git a/src/services/Navigation.java b/src/services/Navigation.java
index ed528a2..5a6ab9d 100644
--- a/src/services/Navigation.java
+++ b/src/services/Navigation.java
@@ -59,101 +59,125 @@ public class Navigation implements TimerListener {
 		if (manager.cm.getState() == State.SEARCH
 				|| manager.cm.getState() == State.DROP_OFF
 				|| manager.cm.getState() == State.RECOGNIZE
-				|| manager.cm.getState() == State.TESTING) {
+				|| manager.cm.getState() == State.TESTING
+				|| manager.cm.getState() == State.COLLECT) {
 			
 			if (route.empty()) {
 				// nothing is done
 			} else {
-				nextDestination = route.peek();
-				// if navigation must be done
-
-				// update the new headings to travel to
-				setupDeltaPositonAndHeading();
-
-				// see if we need to make a big turn
-				if (Math.abs(dH) > 0.1) {
-					// if we need to turn more than 0.2 rads or 0.1 for
-					// completing a turn, call the turnTo method
-					// otherwise we can adjust small angle errors by slowing
-					// one wheel down slightly
-					turnTo(dH);
-				} else if (Math.abs(dX) > 1 || Math.abs(dY) > 1) {
-					// RConsole.println(""+Math.abs(dX)+" "+Math.abs(dY));
-					// scan ahead only once facing the correct orientation, then
-					// travelTo that destination.
-					// TODO comment back this code. Problematic code for the
-					// moment.
-					if (!scannedAhead) {
-						manager.cm.setState(State.PAUSE);
-						Sound.beep();
-						RConsole.println("Scanning Ahead");
-						scannedAhead = true;
-						
-						manager.hm.drive.stop();
-						UltrasonicMotor.setForwardPosition();
-						manager.hm.ultrasonicPoller.pingSequential();
-						manager.hm.ultrasonicPoller.resetUSP();
-						while(!manager.hm.ultrasonicPoller.isSetup()) {
-							
-							manager.um.nap(200);
-						}
-						
-						int lowest = manager.hm.ultrasonicPoller.getLowestReading();
-									
-						if (lowest < 20) {
-							//reassign the lowest to something useful now (aka not zeros).
-							lowest = manager.hm.ultrasonicPoller.getUSReading(1);
-							
-							RConsole.println("Read less than 20");
-							Sound.beepSequenceUp();
-							//TODO comment this back in when recognize works. 
-							manager.cm.setState(State.RECOGNIZE);
-							
-						}
-						else if (lowest < 50) {
-							
-							RConsole.println("Read less than 50");
-							RConsole.println("Pushing the following to the stack" + manager.sm.odo.getPosition().addDistanceToPosition(lowest - Settings.clawToUSDistance));
-							
-							route.push(manager.sm.odo.getPosition().addDistanceToPosition(lowest - Settings.clawToUSDistance));
-							
-							UltrasonicMotor.setDefaultPosition();
+				if(manager.cm.getState() == State.RECOGNIZE) {
+					if (Math.abs(dH) > 0.1) {
+						turnTo(dH);
+					} else if (Math.abs(dX) > 1 || Math.abs(dY) > 1) {
+						travelTo();
+					}
+					
+				}
+				else {
+					nextDestination = route.peek();
+					// if navigation must be done
+
+					// update the new headings to travel to
+					setupDeltaPositonAndHeading();
+
+					// see if we need to make a big turn
+					if (Math.abs(dH) > 0.1) {
+						// if we need to turn more than 0.2 rads or 0.1 for
+						// completing a turn, call the turnTo method
+						// otherwise we can adjust small angle errors by slowing
+						// one wheel down slightly
+						turnTo(dH);
+					} else if (Math.abs(dX) > 1 || Math.abs(dY) > 1) {
+						// RConsole.println(""+Math.abs(dX)+" "+Math.abs(dY));
+						// scan ahead only once facing the correct orientation,
+						// then
+						// travelTo that destination.
+						// TODO comment back this code. Problematic code for the
+						// moment.
+						if (!scannedAhead) {
+							manager.cm.setState(State.PAUSE);
+							Sound.beep();
+							RConsole.println("Scanning Ahead");
+							scannedAhead = true;
+
+							manager.hm.drive.stop();
+							UltrasonicMotor.setForwardPosition();
+							manager.hm.ultrasonicPoller.pingSequential();
 							manager.hm.ultrasonicPoller.resetUSP();
-						
-							while(!manager.hm.ultrasonicPoller.isSetup()) {
+							while (!manager.hm.ultrasonicPoller.isSetup()) {
+
 								manager.um.nap(200);
 							}
-							
-							manager.cm.setState(State.SEARCH);
-							Sound.beepSequence();
-						} else {
-							
-							UltrasonicMotor.setDefaultPosition();
-							manager.hm.ultrasonicPoller.pingAll();
-							manager.hm.ultrasonicPoller.resetUSP();
-							
-							while(!manager.hm.ultrasonicPoller.isSetup()) {
-								manager.um.nap(200);
+
+							int lowest = manager.hm.ultrasonicPoller
+									.getLowestReading();
+
+							if (lowest < Settings.tipOfClawToUSDistance + 7) {
+								// reassign the lowest to something useful now
+								// (aka not zeros).
+								lowest = manager.hm.ultrasonicPoller
+										.getUSReading(1);
+
+								RConsole.println("Read less than 20");
+								Sound.beepSequenceUp();
+								// TODO comment this back in when recognize
+								// works.
+								manager.cm.setState(State.RECOGNIZE);
+
+							} else if (lowest < 50) {
+
+								RConsole.println("Read less than 50");
+								RConsole.println("Pushing the following to the stack"
+										+ manager.sm.odo
+												.getPosition()
+												.addDistanceToPosition(
+														lowest
+																- Settings.tipOfClawToUSDistance));
+
+								route.push(manager.sm.odo
+										.getPosition()
+										.addDistanceToPosition(
+												lowest
+														- Settings.tipOfClawToUSDistance));
+
+								UltrasonicMotor.setDefaultPosition();
+								manager.hm.ultrasonicPoller.resetUSP();
+
+								while (!manager.hm.ultrasonicPoller.isSetup()) {
+									manager.um.nap(200);
+								}
+
+								manager.cm.setState(State.SEARCH);
+								Sound.beepSequence();
+							} else {
+
+								UltrasonicMotor.setDefaultPosition();
+								manager.hm.ultrasonicPoller.pingAll();
+								manager.hm.ultrasonicPoller.resetUSP();
+
+								while (!manager.hm.ultrasonicPoller.isSetup()) {
+									manager.um.nap(200);
+								}
+
+								manager.cm.setState(State.SEARCH);
+								Sound.beep();
+								// do no processing, just continue along doing
+								// nothing.
 							}
-							
-							manager.cm.setState(State.SEARCH);
-							Sound.beep();
-							// do no processing, just continue along doing nothing. 
+						} else {
+							travelTo();
+							RConsole.println("Not scanning ahead");
 						}
 					} else {
-						travelTo();
-						RConsole.println("Not scanning ahead");
+
+						// stop the motors, reset scanning state and get next
+						// destination.
+						manager.hm.drive.stop();
+						scannedAhead = false;
+						if (!route.empty())
+							route.pop();
 					}
-				} else {
-					
-					// stop the motors, reset scanning state and get next
-					// destination.
-					manager.hm.drive.stop();
-					scannedAhead = false;
-					if(!route.empty())
-						route.pop();
 				}
-
 			}
 		}
 	}
diff --git a/src/utilities/Settings.java b/src/utilities/Settings.java
index 96022f4..7098e3c 100644
--- a/src/utilities/Settings.java
+++ b/src/utilities/Settings.java
@@ -44,6 +44,7 @@ public class Settings {
 	public static final double TILE_SIZE = 30.48;
 	public static final int maxBlockCapacity = 1;
 	
-	public static final int clawToUSDistance = 10; //TODO measure this. 
+	public static final int tipOfClawToUSDistance = 18; //TODO measure this. 
+	public static final int centerOfClawToUSDistance = 7;
 	
 }

commit 34eb188e37cab85ac947c1ecf0280f31fedb6420
Author: RileyvanRyswyk <rileyvan@gmail.com>
Date:   Sun Nov 24 20:51:28 2013 -0500

    Utilities package comments

diff --git a/src/utilities/Angle.java b/src/utilities/Angle.java
index f0c03b4..501fb53 100644
--- a/src/utilities/Angle.java
+++ b/src/utilities/Angle.java
@@ -12,7 +12,7 @@ public class Angle {
 
 	/**
 	 * Ensures angle is always in [0, 2PI)
-	 * @param angle to convert
+	 * @param angle angle to convert
 	 * @return
 	 */
 	public static double principleAngle(double angle) {		
@@ -36,7 +36,11 @@ public class Angle {
 		else
 			return d - 2*Math.PI;
 	}
-	
+	/**
+	 * Converts radians to degrees
+	 * @param rad angle to convert
+	 * @return
+	 */
 	public static int radToDeg(double rad) {
 		return (int) (rad * 180 / Math.PI);
 	}
diff --git a/src/utilities/BluetoothTransmission.java b/src/utilities/BluetoothTransmission.java
index 4f89f56..f943685 100644
--- a/src/utilities/BluetoothTransmission.java
+++ b/src/utilities/BluetoothTransmission.java
@@ -13,13 +13,19 @@ import lejos.nxt.comm.NXTConnection;
 import lejos.nxt.comm.RConsole;
 
 /**
- * This class will open a new 
+ * This class will open a bluetooth connection to the PC server.  It will also read the match variables and set the appropriate variables in {@link Settings}.
  * @author Danielle
  *
  */
 public class BluetoothTransmission {
+	/**
+	 * Input Data Stream
+	 */
 	static DataInputStream stream; 
 	
+	/**
+	 * Calls {@link getConnection() } and then {@link getInformation() }.  It will then call {@link close}
+	 */
 	public static void getBluetoothData() {
 		Settings.greenZoneCoords = new Point[2];
 		Settings.redZoneCoords = new Point[2];
@@ -28,6 +34,10 @@ public class BluetoothTransmission {
 		close();
 	}
 	
+	/**
+	 * Waits for a bluetooth connection to the server, and when one becomes available it will connect.
+	 * @return
+	 */
 	private static DataInputStream getConnection() {
 		LCD.clear();
 		LCD.drawString("Starting BT connection", 0, 0);
@@ -36,13 +46,18 @@ public class BluetoothTransmission {
 		return conn.openDataInputStream();
 	}
 	
+	/**
+	 * Closes the connection to the server
+	 */
 	private static void close() {
 		try {
 			stream.close();
 		} catch (IOException e) {
 		}
 	}
-	
+	/**
+	 * Reads the input stream for information, it will then set {@link Settings.role}, {@link Settings.startingCorner}, {@link Settings.greenZoneCoords}, and {@link Settings.redZoneCoords}
+	 */
 	private static void getInformation() {
 		//TODO verify the input of the coordinates with the server. I am assuming the coordinates are sent as a series of 8 integers. The order is unknown. 
 		try {
diff --git a/src/utilities/Communicator.java b/src/utilities/Communicator.java
index 2d7d0e3..310bc00 100644
--- a/src/utilities/Communicator.java
+++ b/src/utilities/Communicator.java
@@ -19,12 +19,20 @@ import lejos.nxt.comm.NXTConnection;
  * 
  */
 public class Communicator {
-	
+	/**
+	 * Connection object for the connection between the two NXT bricks
+	 */
 	private NXTConnection con;
+	/**
+	 * RS485 Connector object
+	 */
 	private NXTCommConnector connector;
 	public DataInputStream dis;
 	public DataOutputStream dos;
-	
+	/**
+	 * Master communicator.  Establishes and stores the RS485 connection to the slave NXT.  It will also open the input & output data streams
+	 * @param extendedNXT
+	 */
 	public Communicator(String extendedNXT) {
 		
 	       connector = RS485.getConnector();
@@ -39,10 +47,10 @@ public class Communicator {
 	
 	
 	
-	/**
-	 * The Communicator object that will just connect to the slaveNXT. Uses exclusively RS485 for a reliable connection. It initializes the motors from the remote brick.
-	 * @param slaveNXT	A String with the name of the remoteNXT connected via RS485. 
-	 */
+//	/**
+//	 * The Communicator object that will just connect to the slaveNXT. Uses exclusively RS485 for a reliable connection. It initializes the motors from the remote brick.
+//	 * @param slaveNXT	A String with the name of the remoteNXT connected via RS485. 
+//	 */
 	/*public Communicator(String slaveNXT) {
 		RemoteNXT nxt = null;
 		try {
diff --git a/src/utilities/Map.java b/src/utilities/Map.java
index eae6572..9746f96 100644
--- a/src/utilities/Map.java
+++ b/src/utilities/Map.java
@@ -1,5 +1,9 @@
 package utilities;
-
+/**
+ * Not implemented!
+ * @author 
+ *
+ */
 public class Map {
 
 }
diff --git a/src/utilities/Point.java b/src/utilities/Point.java
index 1c2717d..0de513e 100644
--- a/src/utilities/Point.java
+++ b/src/utilities/Point.java
@@ -1,33 +1,56 @@
 package utilities;
-
+/**
+ * Helper class that uses a Point object to store a points x and y coordinates. As well it provides convenient helper methods  
+ * @author Riley
+ *
+ */
 public class Point  {
 	public double x;
 	public double y;
 	
+	/**
+	 * Initializes a point to the passed x and y
+	 * @param x
+	 * @param y
+	 */
 	public Point(double x, double y) {
 		this.x = x;
 		this.y = y;
 	}
-	
+	/**
+	 * Initializes a point with the same x and y as the point passed
+	 * @param point
+	 */
 	public Point(Point point) {
 		this.x = point.x;
 		this.y = point.y;
 	}
-	
+	/**
+	 * Initializes a point, with x and y == Double.NaN
+	 */
 	public Point() {
 		this.x = Double.NaN;
 		this.y = Double.NaN;
 	}
-	
+	/**
+	 * Outputs the x and y of the point to a string
+	 */
 	public String toString() {
 		return "{x:" + x + ", y:" + y + "}";
 	}
-	
+	/**
+	 * Returns the distance between this point and the point passed in
+	 * @param point
+	 * @return
+	 */
 	public double distanceToPoint(Point point) {
 		return Math.sqrt(Math.pow(x - point.x, 2) + Math.pow(y - point.y, 2));
 	}
 	
-	//return a point object identical to the current point. Not passed by reference. 
+	/**
+	 * Returns a new Point with the same x and y as the point. Not pass by reference
+	 * @return
+	 */
 	public Point getPoint() {
 		return new Point(this.x, this.y);
 	}
diff --git a/src/utilities/Position.java b/src/utilities/Position.java
index 9f5c422..6caee2d 100644
--- a/src/utilities/Position.java
+++ b/src/utilities/Position.java
@@ -1,21 +1,38 @@
 package utilities;
 
+/**
+ * Using the {@link Point} class as a base, Position adds an angle theta.  
+ * @author Riley
+ * @author Danielle
+ *
+ */
 public class Position extends Point {
 
 	public double theta;
 
+	/**
+	 * Initializes the Position as per the passed x, y, theta
+	 * @param x
+	 * @param y
+	 * @param theta
+	 */
 	public Position(double x, double y, double theta) {
 		this.x = x;
 		this.y = y;
 		this.theta = theta;
 	}
-
+	/**
+	 * Initializes an empty Position object
+	 */
 	public Position() {
 		this.x = Double.NaN;
 		this.y = Double.NaN;
 		this.theta = Double.NaN;
 	}
 
+	/**
+	 * Outputs the position variables to a String
+	 */
 	public String toString() {
 		return "{x:" + x + ", y:" + y + ", theta:" + theta + "}";
 	}
diff --git a/src/utilities/Settings.java b/src/utilities/Settings.java
index 6792ede..6383cd7 100644
--- a/src/utilities/Settings.java
+++ b/src/utilities/Settings.java
@@ -7,43 +7,109 @@ import lejos.nxt.Motor;
 import lejos.nxt.NXTRegulatedMotor;
 import lejos.nxt.SensorPort;
 import lejos.nxt.UltrasonicSensor;
-
+/**
+ * Contains most of the Motor/Sensor port settings, Physical Robot Parameters and match settings
+ * @author Riley
+ * @author Danielle
+ *
+ */
 public class Settings {
-	
+	/**
+	 * Colour sensor on the claw
+	 */
 	public static ColorSensor frontColorSensor = new ColorSensor(SensorPort.S1);
+	/**
+	 * left line sensor
+	 */
 	public static ColorSensor rearLeftColorSensor = new ColorSensor(SensorPort.S2);
+	/**
+	 * Right line sensor
+	 */
 	public static ColorSensor rearRightColorSensor = new ColorSensor(SensorPort.S3);
 	
 //	public static UltrasonicSensor leftUltrasonic;
 //	public static UltrasonicSensor centerUltrasonic;
 //	public static UltrasonicSensor rightUltrasonic;
 	
+	/**
+	 * Left Driving motor
+	 */
 	public static NXTRegulatedMotor leftDriveMotor = Motor.B;
+	/**
+	 * Right Driving Motor
+	 */
 	public static NXTRegulatedMotor rightDriveMotor = Motor.A;
 	
+	/**
+	 * The motor id that corresponds to the Claw motor. Used by {@link NXTRemoteControl}
+	 */
 	public static final int CLAW_MOTOR_ID = 1;
+	/**
+	 * The motor id that corresponds to the Ultrasonic motor. Used by {@link NXTRemoteControl}
+	 */
 	public static final int ULTRASONIC_MOTOR_ID = 2;
+	/**
+	 * The motor id that corresponds to the Lift motor. Used by {@link NXTRemoteControl}
+	 */
 	public static final int LIFT_MOTOR_ID = 3;
 	
 	public static NXTRemoteMotor clawMotor;
 	public static NXTRemoteMotor ultrasonicMotor;
 	public static NXTRemoteMotor liftMotor;
 	
+	/**
+	 * Name of the slave NXT brick
+	 */
 	public static final String NXTSlaveName = "NXT";
 	
+	/**
+	 * Robots Role id, set by {@link BluetoothTransmission}
+	 */
 	public static int role;
+	/**
+	 * Array of points corresponding to the red zone, set by {@link BluetoothTransmission}
+	 */
 	public static Point[] redZoneCoords;
+	/**
+	 * Array of points corresponding to the green zone, set by {@link BluetoothTransmission}
+	 */
 	public static Point[] greenZoneCoords = new Point[2]; //TODO remove once BT is working.
+	/**
+	 * Starting corner of the robot, set by {@link BluetoothTransmission}
+	 */
 	public static StartingCorner startingCorner = StartingCorner.BOTTOM_RIGHT;
+	/**
+	 * Playing field width (in X direction)
+	 */
 	public static final int FIELD_X = 8;
+	/**
+	 * Playing field length (in y direction)
+	 */
 	public static final int FIELD_Y = 8;
 	
+	/**
+	 * Line sensor distance from odometry centre
+	 */
 	public static final double LS_OFFSET = 15.0;
+	/**
+	 * distance between the line sensors
+	 */
 	public static final double LS_WIDTH = 11.5;
+	/**
+	 * Distance from the odometry centre to the line that passes through both line sensors
+	 */
 	public static final double LS_LENGTH = 13.5;
+	/**
+	 * Size of a tile
+	 */
 	public static final double TILE_SIZE = 30.48;
+	/**
+	 * Maximum carrying capacity of the robot
+	 */
 	public static final int maxBlockCapacity = 1;
-	
+	/**
+	 * the distance from the end of the claw to the front of the ultrasonic sensor
+	 */
 	public static final int clawToUSDistance = 7; //TODO measure this. 
 	
 }
diff --git a/src/utilities/StartingCorner.java b/src/utilities/StartingCorner.java
index a5834cd..eeb5f5b 100644
--- a/src/utilities/StartingCorner.java
+++ b/src/utilities/StartingCorner.java
@@ -1,5 +1,9 @@
 package utilities;
-
+/**
+ * Identifier for the four starting corners
+ * @author Riley
+ *
+ */
 public enum StartingCorner {
 	BOTTOM_RIGHT, BOTTOM_LEFT, TOP_RIGHT, TOP_LEFT;
 }
diff --git a/src/utilities/Tile.java b/src/utilities/Tile.java
index 3483341..697aec4 100644
--- a/src/utilities/Tile.java
+++ b/src/utilities/Tile.java
@@ -1,5 +1,9 @@
 package utilities;
-
+/**
+ * Currently not implemented
+ * @author
+ *
+ */
 public class Tile {
 
 }

commit 5c09f29cbfa99744fe36284dddca6a49a2649f69
Author: RileyvanRyswyk <rileyvan@gmail.com>
Date:   Sun Nov 24 20:01:03 2013 -0500

    More commenting.  Mostly Slave package

diff --git a/src/services/LCDInfo.java b/src/services/LCDInfo.java
index d045ad5..eb466c4 100644
--- a/src/services/LCDInfo.java
+++ b/src/services/LCDInfo.java
@@ -1,7 +1,5 @@
 package services;
 
-
-
 import utilities.Angle;
 import utilities.Point;
 import utilities.Position;
@@ -9,7 +7,13 @@ import lejos.nxt.LCD;
 import lejos.util.Timer;
 import lejos.util.TimerListener;
 import manager.Manager;
-
+/**
+ * Prints Information to the LCD display of the NXT. This includes {@link Odmeter} x, y, theta; a debug value, and the next point in the Route of {@link Navigation}.
+ * 
+ * It is a modified version of the code supplied in Lab 4
+ * @author Riley
+ *
+ */
 public class LCDInfo implements TimerListener{
 	public static final int LCD_REFRESH = 300;
 	private Manager manager;
@@ -28,7 +32,7 @@ public class LCDInfo implements TimerListener{
 	}
 	
 	/**
-	 * main update loop
+	 * main update loop.  x, y are in mm.  Theta is in degrees
 	 */
 	public void timedOut() { 
 		Position pos = manager.sm.odo.getPosition();
diff --git a/src/slave/NXTRemoteControl.java b/src/slave/NXTRemoteControl.java
index eba3136..5b337fb 100644
--- a/src/slave/NXTRemoteControl.java
+++ b/src/slave/NXTRemoteControl.java
@@ -17,23 +17,44 @@ import lejos.robotics.RegulatedMotor;
 import lejos.robotics.RegulatedMotorListener;
 
 /**
- * Enables remote control of a motor object using RS485. 
+ * Enables remote control of a motor object using RS485.
+ * 
+ * <p>
+ * Listens for commands sent on RS485 connection.  When a new command is received it will be interpreted, and carried out.
+ * If data is to be sent back, it will send data back through the RS485 connection.
+ *  <p>
+ *  It will wait and automatically connect to the master brick over RS485.
+ *  <p>
+ * A modified version from http://www.lejos.org/forum/viewtopic.php?f=7&t=2620
+ * 
+ *  @author Riley
+ *  @author Danielle
+ *  @author cs07cc4 (LeJOS forum username)
  **/
 public class NXTRemoteControl extends Thread implements RemoteCommands, RegulatedMotorListener {
 
-   private DataInputStream dis = null;
-   private DataOutputStream dos = null;
-   
-   //private DataInputStream lisdis = null;
-   //private DataOutputStream lisdos = null;
+	private DataInputStream dis = null;
+	private DataOutputStream dos = null;
    
+   /**
+    * Communication connector object
+    */
    private NXTCommConnector connector;
+   /**
+    * Connection between the NXTs
+    */
    private NXTConnection con;
    
    
-   //private NXTConnection listenersCon;
+  /**
+   * Id of the motor/poller to be acted on
+   */
    private int id;
+   /**
+    * The command to be carried out as according to {@link RemoteCommands} interface
+    */
    private int command;
+
    private int tachoCount;
    private boolean isMoving;
    private int speed;
@@ -41,20 +62,39 @@ public class NXTRemoteControl extends Thread implements RemoteCommands, Regulate
    private int acceleration;
    private int angle;
    private boolean immediateReturn, isStalled;
-   
-   //Ultrasonic Var
    private boolean isSetup = false;
 
+   /**
+    * Motor A
+    */
    private static NXTRegulatedMotor A = null;
+   /**
+    * Motor B
+    */
    private static NXTRegulatedMotor B = null;
+   /**
+    * Motor C
+    */
    private static NXTRegulatedMotor C = null;
+   /**
+    * Ultrasonic Poller
+    */
    private static RemoteUltrasonicPoller usp = null;
 
+   /**
+    * Constructor for only 1 motor. Not used
+    * @param portA
+    */
    public NXTRemoteControl(MotorPort portA) {
       
       A = new NXTRegulatedMotor(portA);
 
-}
+   }
+   /**
+    * Constructor for two motors. not used
+    * @param portA
+    * @param portB
+    */
    public NXTRemoteControl(MotorPort portA, MotorPort portB) {
       
          A = new NXTRegulatedMotor(portA);
@@ -62,6 +102,12 @@ public class NXTRemoteControl extends Thread implements RemoteCommands, Regulate
          
 
    }
+   /**
+    * Constructor for three motors. Not used.
+    * @param portA
+    * @param portB
+    * @param portC
+    */
    public NXTRemoteControl(MotorPort portA, MotorPort portB,
          MotorPort portC) {
       
@@ -70,7 +116,13 @@ public class NXTRemoteControl extends Thread implements RemoteCommands, Regulate
          C = new NXTRegulatedMotor(portC);
 
    }
-   
+   /**
+    * Constructor for three motors and the {@link RemoteUltrasonicPoller}
+    * @param portA
+    * @param portB
+    * @param portC
+    * @param usPoller
+    */
    public NXTRemoteControl(MotorPort portA, MotorPort portB, MotorPort portC, RemoteUltrasonicPoller usPoller) {
 	   A = new NXTRegulatedMotor(portA);
        B = new NXTRegulatedMotor(portB);
@@ -78,6 +130,12 @@ public class NXTRemoteControl extends Thread implements RemoteCommands, Regulate
        usp = usPoller;
    }
 
+   /**
+    * Executes motor commands.  It will read the {@link dis} for a param if necessary.  If a value is to be returned, it will return it via the {@link dos}
+    * @param id - id of the motor (1 -> MotorA, 2 -> MotorB, 3-> MotorC)
+    * @param command - command to be carried out as per {@link RemoteCommands} interface
+    * @throws IOException
+    */
    protected void executeMotorCommand(int id, int command) throws IOException {
 
 		NXTRegulatedMotor motor = getMotor(id);
@@ -240,6 +298,12 @@ public class NXTRemoteControl extends Thread implements RemoteCommands, Regulate
 
    }
    
+   /**
+    * Executes Ultrasonic Poller sensor commands. It will read a param for the {@link dis} if necessary. If a return value is required, it will be sent via the {@link dos}.
+    * @param id - will always be four, used to differentiate from motors
+    * @param command - command to execute as per {@link RemoteCommands} interface
+    * @throws IOException
+    */
    protected void executeSensorCommand(int id, int command) throws IOException {
 
 		switch (command) {
@@ -308,7 +372,11 @@ public class NXTRemoteControl extends Thread implements RemoteCommands, Regulate
 			
 		}
    }
-
+/**
+ * Returns the RemoteUltrasonicPoller if id == 4
+ * @param id
+ * @return
+ */
    protected RemoteUltrasonicPoller getSensor(int id) {
 
 	      switch (id) {
@@ -316,7 +384,12 @@ public class NXTRemoteControl extends Thread implements RemoteCommands, Regulate
 	         return usp;
 	      }
 	      return null;
-	   }   
+	   }  
+   /**
+    * Returns the Motor designation (A ||B || C) based on id (1 || 2 || 3)
+    * @param id
+    * @return
+    */
    protected NXTRegulatedMotor getMotor(int id) {
 
       switch (id) {
@@ -332,7 +405,11 @@ public class NXTRemoteControl extends Thread implements RemoteCommands, Regulate
 
       return null;
    }   
-   
+   /**
+    * Returns numerical motor id based on input motor
+    * @param motor
+    * @return
+    */
    protected int getMotor(RegulatedMotor motor) {
 
       if(motor.equals(Motor.A))
@@ -345,6 +422,9 @@ public class NXTRemoteControl extends Thread implements RemoteCommands, Regulate
       return -1;
    }
    
+   /**
+    * Connects to the other NXT brick.  It will then continually check the {@link dis} for any new commands, and call the necessary execute method
+    */
    public void run() {
 
       while (true) {
@@ -387,6 +467,9 @@ public class NXTRemoteControl extends Thread implements RemoteCommands, Regulate
       }
 }
    @Override
+   /**
+    * Not used
+    */
    public void rotationStarted(RegulatedMotor motor, int tachoCount, boolean stalled,
          long timeStamp) {
       
@@ -406,6 +489,9 @@ public class NXTRemoteControl extends Thread implements RemoteCommands, Regulate
       
    
    @Override
+   /**
+    * Not used
+    */
    public void rotationStopped(RegulatedMotor motor, int tachoCount, boolean stalled,
          long timeStamp) {
       
diff --git a/src/slave/RemoteUltrasonicPoller.java b/src/slave/RemoteUltrasonicPoller.java
index 789f5ed..8e461d1 100644
--- a/src/slave/RemoteUltrasonicPoller.java
+++ b/src/slave/RemoteUltrasonicPoller.java
@@ -23,31 +23,86 @@ import manager.Manager;
 public class RemoteUltrasonicPoller implements TimerListener {
 	private UltrasonicSensor[] us = new UltrasonicSensor[3];
 	
-	//properties of the USPoller
+	/**
+	 * Rate at which to poll the ultrasonic sensors
+	 */
 	private int pollRate;
+	/**
+	 * Timer for timer listener
+	 */
 	private Timer poller;
+	/**
+	 * Stores the past 5 readings of the 3 ultrasonic Sensors
+	 */
 	private int readings[][];
 	
-	//internal designation of the sensors
+	/**
+	 * Id of the left sensor
+	 */
 	private int left = 0;
+	/**
+	 * Id of the Center sensor
+	 */
 	private int center = 1;
+	/**
+	 * Id of the right sensor
+	 */
 	private int right = 2;
 	
-	// internal use of a counter for sequential pinging.
+	/**
+	 * Used to determine which sensor to ping in SEQUENTIAL mode
+	 */
 	private int counter;
 
-	// the threads which run the US.
+	/**
+	 * Thread for the left ultrasonic
+	 */
 	private Thread leftUS;
+	/**
+	 * Thread for the center ultrasonic
+	 */
 	private Thread centerUS;
+	/**
+	 * Thread for the right Ultrasonic
+	 */
 	private Thread rightUS;
 	
-	// the instruction to the USP.
+	/**
+	 * The mode to poll the ultrasonic sensors
+	 */
 	public USPState state;
 	
+	/**
+	 * The various modes of the ultrasonic poller
+	 * <p>
+	 * {@link PING_CENTER} - Pings only the center ultrasonic
+	 * * <p>
+	 * {@link PING_ALL} - Pings all the Ultrasonic sensors at the same time 
+	 * <p>
+	 * {@link PING_LEFT} - Pings only the left ultrasonic 
+	 * <p>
+	 * {@link PING_RIGHT} - Pings only the right ultrasonic
+	 * <p>
+	 * {@link PING_SEQUENTIAL} - Pings all the ultrasonic sensors, but only one at a time (each sensor is polled every 3 * {@link pollRate}
+	 * @author Danielle
+	 *
+	 */
 	public enum USPState {
 		PING_CENTER, PING_ALL, PING_LEFT, PING_RIGHT, PING_SEQUENTIAL;
 	}
-
+	
+	/**
+	 * Initializes the 3 ultrasonic sensors
+	 * <p>
+	 * Sets default pollRate to 20
+	 * <p>
+	 * Turns the ultrasonic Sensors off
+	 * <p>
+	 * Initializes the threads for the Ultrasonic sensors
+	 * <p>
+	 * Sets default state to {@link PING_CENTER}
+	 * @author Danielle
+	 */
 	public RemoteUltrasonicPoller() {
 		us[left] = new UltrasonicSensor(SensorPort.S3);
 		us[center] = new UltrasonicSensor(SensorPort.S1);
@@ -67,13 +122,17 @@ public class RemoteUltrasonicPoller implements TimerListener {
 		this.state = USPState.PING_CENTER;
 	}
 	
+	/**
+	 * Sets the mode of the ultrasonic poller to the corresponding state passed
+	 * @param state
+	 */
 	public void setUSPState(USPState state) {
 		this.state = state;
 		resetUSP();
 	}
 
 	/**
-	 * Pings all three ultrasonic sensors and gets their values. Puts them into
+	 * Pings the ultrasonic sensors based on which mode the poller is set to and stores their corresponding values. Puts them into
 	 * the readings array
 	 */
 	@Override
@@ -106,7 +165,10 @@ public class RemoteUltrasonicPoller implements TimerListener {
 		}
 	}
 
-	// For debugging purposes.
+	/**
+	 * For debugging purposes. 
+	 * @return
+	 */
 	private String toStringLastValues() {
 		String out = "";
 		out += " L: " + getUSReading(left);
@@ -143,7 +205,7 @@ public class RemoteUltrasonicPoller implements TimerListener {
 	}
 
 	/**
-	 * Checks if the ultrasonic sensor has collected atleast 5 values. It does
+	 * Checks if the ultrasonic sensor has collected at least 5 values. It does
 	 * this by checking for any negative numbers in the readings.
 	 */
 	public boolean isSetup() {
@@ -231,7 +293,7 @@ public class RemoteUltrasonicPoller implements TimerListener {
 	
 	/**
 	 * This method gets the number representation of the US with the lowest value out of all the ultrasonic sensor. 
-	 * So if the center has the lowest reading, 
+	 * So if the center has the lowest reading, the {@link USPosition.CENTER} will be returned 
 	 */
 	public USPosition getLowestSensor() {
 		boolean takingReadings = false;
@@ -286,7 +348,11 @@ public class RemoteUltrasonicPoller implements TimerListener {
 		addReading(sensor, distance);
 	}
 
-	// helper method.
+	/**
+	 * Helper method to add a new reading to the {@link readings} array.  The new reading will be store in the 0th index.
+	 * @param sensor
+	 * @param reading
+	 */
 	private void addReading(int sensor, int reading) {
 		readings[sensor][4] = readings[sensor][3];
 		readings[sensor][3] = readings[sensor][2];
@@ -306,7 +372,12 @@ public class RemoteUltrasonicPoller implements TimerListener {
 			sum += readings[sensor][i];
 		return (sum / readings[sensor].length);
 	}
-
+	
+	/**
+	 * Call pingsUS(left) in the {@link LeftUS} thread
+	 * @author Danielle
+	 *
+	 */
 	public class LeftUS implements Runnable {
 
 		@Override
@@ -314,7 +385,11 @@ public class RemoteUltrasonicPoller implements TimerListener {
 			pingUS(left);
 		}
 	}
-
+	/**
+	 * Call pingsUS(right) in the {@link RightUS} thread
+	 * @author Danielle
+	 *
+	 */
 	public class RightUS implements Runnable {
 
 		@Override
@@ -322,7 +397,11 @@ public class RemoteUltrasonicPoller implements TimerListener {
 			pingUS(right);
 		}
 	}
-
+	/**
+	 * Call pingsUS(center) in the {@link CenterUS} thread
+	 * @author Danielle
+	 *
+	 */
 	public class CenterUS implements Runnable {
 
 		@Override
@@ -330,7 +409,11 @@ public class RemoteUltrasonicPoller implements TimerListener {
 			pingUS(center);
 		}
 	}
-	
+	/**
+	 * Has values for the 3 (left, center, right) positions of the ultrasonic sensors
+	 * @author Danielle
+	 *
+	 */
 	public enum USPosition {
 		LEFT, CENTER, RIGHT
 	}
diff --git a/src/slave/Responder.java b/src/slave/Responder.java
index 2a6d6af..f015d5c 100644
--- a/src/slave/Responder.java
+++ b/src/slave/Responder.java
@@ -11,48 +11,49 @@ import lejos.nxt.comm.RS485;
 
 /**
  * The responder class responds to the LCP requests sent by the Communicator.java class. 
- * Uses by default Bluetooth.
+ * Uses RS-485.
+ * 
  * 
- * Slight modification for LeJOS samples
  * <p> 
- * @author Andy Shaw
+ * 
  * @author danielle
+ * @author Riley
  * 
  */
 public class Responder {
 	
-	/**
-	 * The subclass that handles the LCP connections. In particular, it is modified version of the LCPResponder to shutdown the connection once the program disconnects.
-	 * @author Andy Shaw
-	 * @author danielle
-	 *
-	 */
-	public static class ResponderTool extends LCPResponder {
-		ResponderTool(NXTCommConnector con) {
-            super(con);
-        }
+//	/**
+//	 * The subclass that handles the LCP connections. In particular, it is modified version of the LCPResponder to shutdown the connection once the program disconnects.
+//	 * @author Andy Shaw
+//	 * @author danielle
+//	 *
+//	 */
+//	public static class ResponderTool extends LCPResponder {
+//		ResponderTool(NXTCommConnector con) {
+//            super(con);
+//        }
 
-         protected void disconnect() {
-            super.disconnect();
-            super.shutdown();
-        }
-	}
+ //        protected void disconnect() {
+ //           super.disconnect();
+ //           super.shutdown();
+ //       }
+//	}
 	
 	/**
-	 * This program has a main as it is to be loaded on the slaveNXT brick. Has
-	 * almost no functionality otherwise.
+	 * This program has a main as it is to be loaded on the slaveNXT brick. 
 	 * <p>
+	 * It will start the {@link RemoteUltrasonicPoller} and the {@link NXTRemoteControl}
 	 * @param args
 	 *            This is the default constructor, not needed.
 	 */
 	
 	public static void main(String[] args) throws Exception {
 		
-		//RConsole.openUSB(20000);
+//		RConsole.openUSB(20000);
 		LCD.drawString("Connecting", 1, 1);
-		//ResponderTool resp = new ResponderTool(RS485.getConnector());
-		//resp.start();
-		//resp.join();
+//		ResponderTool resp = new ResponderTool(RS485.getConnector());
+//		resp.start();
+//		resp.join();
 		RemoteUltrasonicPoller remoteUSP = new RemoteUltrasonicPoller();
 		NXTRemoteControl motorControl = new NXTRemoteControl(MotorPort.A, MotorPort.B, MotorPort.C, remoteUSP);
 		

commit d6741594babfceea88620ea782d57fe019c23f89
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Sun Nov 24 19:10:34 2013 -0500

    Thsi code works if you hack it. But it grabs the block now and releases
    it if you shove a blue block infront of the color sensor. Throws an
    exception 16 at the end of lifting mechanism though.

diff --git a/src/controllers/Collect.java b/src/controllers/Collect.java
index e1032db..4c0af54 100644
--- a/src/controllers/Collect.java
+++ b/src/controllers/Collect.java
@@ -8,6 +8,7 @@ import utilities.Settings;
 import hardwareAbstraction.Claw;
 import hardwareAbstraction.Forklift;
 import hardwareAbstraction.Forklift.ForkliftState;
+import lejos.nxt.Sound;
 import lejos.nxt.comm.RConsole;
 import manager.Manager;
 
@@ -38,13 +39,15 @@ private static boolean setup = false;
 			manager.hm.drive.stop();
 
 			// setup claw and navigate towards the block
+			Sound.twoBeeps();
+			Forklift.setHeight(ForkliftState.GROUND);
 			sleep(Claw.releaseObject());
 			Position currentPos = manager.sm.odo.getPosition();
 			
 			//navigate towards block
 			final int clawOffset = Settings.clawToUSDistance;
-			int distance = manager.hm.ultrasonicPoller.getUSReading(1) - clawOffset < 0 ? 0 : manager.hm.ultrasonicPoller.getUSReading(1) - clawOffset;
-			manager.sm.nav.addToRoute(currentPos.addDistanceToPosition(distance));
+//			int distance = manager.hm.ultrasonicPoller.getUSReading(1) - clawOffset < 0 ? 0 : manager.hm.ultrasonicPoller.getUSReading(1) - clawOffset;
+//			manager.sm.nav.addToRoute(currentPos.addDistanceToPosition(15));
 		}
 		/*
 		 * Once the robot is in position to pickup the object, it will then grab the object and lift it. 
diff --git a/src/controllers/Recognize.java b/src/controllers/Recognize.java
index 0681916..ce8eaa0 100644
--- a/src/controllers/Recognize.java
+++ b/src/controllers/Recognize.java
@@ -23,6 +23,8 @@ private Manager manager;
 	}
 	
 	public void run() {
+		manager.cm.setState(State.COLLECT);
+		
 		//do nothing else, don't call recognize again. 
 		manager.cm.setState(State.PAUSE);
 		
diff --git a/src/controllers/Search.java b/src/controllers/Search.java
index b907de4..eb8083f 100644
--- a/src/controllers/Search.java
+++ b/src/controllers/Search.java
@@ -26,11 +26,11 @@ public class Search extends Controller  {
 			}
 		}
 */		
-		Point pointOfInterest = new Point();
+//		Point pointOfInterest = new Point();
 		
-		if(manager.sm.mapper.update(pointOfInterest)) {
-			manager.sm.nav.addToRoute(pointOfInterest);
-		}
+//		if(manager.sm.mapper.update(pointOfInterest)) {
+//			manager.sm.nav.addToRoute(pointOfInterest);
+//		}
 		
 	}
 	/**
@@ -39,14 +39,14 @@ public class Search extends Controller  {
 	private void defaultRouter() {
 		if(manager.sm.nav.getRoute().empty()) {
 			switch(this.defaultPath) {
-			case 0 : manager.sm.nav.addToRoute(new Point(75,15));
+			case 0 : manager.sm.nav.addToRoute(new Point(00,30));
 			break;
-			case 1 : manager.sm.nav.addToRoute(new Point(75,75));
+			case 1 : manager.sm.nav.addToRoute(new Point(30,30));
 			break;
-			case 2 : manager.sm.nav.addToRoute(new Point(165,75));
+			case 2 : manager.sm.nav.addToRoute(new Point(30,00));
 			break;
 			//wont run on the crack
-			case 3 : manager.sm.nav.addToRoute(new Point(165,135)); 
+			case 3 : manager.sm.nav.addToRoute(new Point(00,00)); 
 			break;
 			case 4 : manager.sm.nav.addToRoute(new Point(15,135));
 			break;
@@ -58,7 +58,7 @@ public class Search extends Controller  {
 			break;
 			}
 			this.defaultPath += 1;
-			this.defaultPath %= 8;
+			this.defaultPath %= 4;
 		}
 	}
 	
diff --git a/src/hardwareAbstraction/Forklift.java b/src/hardwareAbstraction/Forklift.java
index 9f9e634..3c1114b 100644
--- a/src/hardwareAbstraction/Forklift.java
+++ b/src/hardwareAbstraction/Forklift.java
@@ -11,7 +11,7 @@ public class Forklift {
 	static int scanHeight = 10; // 10 cm upwards. Needs to be tested. 
 	static int scanHeightLow = 7; // 7 cm upwards. Needs to be tested. 
 	private static double radius = 1; //radius of "spool". Must be tested. 
-	public static ForkliftState state = ForkliftState.SCAN_HEIGHT; //sensor starts on the ground.
+	public static ForkliftState state = ForkliftState.GROUND; //sensor starts on the ground.
 //	/**
 //	 * This method lifts an object. Returns nothing.
 //	 * @bug the execution of external motors causes exceptions. Try-catch block was put for now. Must be fixed. 
diff --git a/src/launcher/Launcher.java b/src/launcher/Launcher.java
index e8604ad..e98b223 100644
--- a/src/launcher/Launcher.java
+++ b/src/launcher/Launcher.java
@@ -40,23 +40,13 @@ public class Launcher {
 		
 		Manager manager = new Manager();
 		Button.waitForPress();
-		
-		manager.cm.setState(State.PAUSE);
-		
-		try {
-			Thread.sleep(Forklift.setHeight(Forklift.ForkliftState.LIFT_HEIGHT));
-		} catch (InterruptedException e) {
-		}
-		
 		try {
-			Thread.sleep(Forklift.setHeight(Forklift.ForkliftState.GROUND));
+			Thread.sleep(Forklift.setHeight(ForkliftState.SCAN_HEIGHT_LOW));
 		} catch (InterruptedException e) {
+			e.printStackTrace();
 		}
 		
-		try {
-			Thread.sleep(Forklift.setHeight(Forklift.ForkliftState.SCAN_HEIGHT_LOW));
-		} catch (InterruptedException e) {
-		}
+		manager.cm.setState(State.SEARCH);
 		
 		/*manager.sm.localization.start();
 		
diff --git a/src/services/Navigation.java b/src/services/Navigation.java
index b93632d..ed528a2 100644
--- a/src/services/Navigation.java
+++ b/src/services/Navigation.java
@@ -1,5 +1,8 @@
 package services;
 
+import hardwareAbstraction.Claw;
+import hardwareAbstraction.Forklift;
+import hardwareAbstraction.Forklift.ForkliftState;
 import hardwareAbstraction.UltrasonicMotor;
 
 import java.util.Stack;
@@ -98,23 +101,23 @@ public class Navigation implements TimerListener {
 						int lowest = manager.hm.ultrasonicPoller.getLowestReading();
 									
 						if (lowest < 20) {
+							//reassign the lowest to something useful now (aka not zeros).
+							lowest = manager.hm.ultrasonicPoller.getUSReading(1);
 							
 							RConsole.println("Read less than 20");
-//							Sound.beepSequenceUp();
+							Sound.beepSequenceUp();
 							//TODO comment this back in when recognize works. 
 							manager.cm.setState(State.RECOGNIZE);
-							Sound.twoBeeps();
 							
 						}
 						else if (lowest < 50) {
 							
-							RConsole.println("Read less than 30");
-							RConsole.println("Pushing the following to the stack" + manager.sm.odo.getPosition().addDistanceToPosition(lowest - 5));
-							//route.push(manager.sm.odo.getPosition().addDistanceToPosition(lowest - Settings.clawToUSDistance));
+							RConsole.println("Read less than 50");
+							RConsole.println("Pushing the following to the stack" + manager.sm.odo.getPosition().addDistanceToPosition(lowest - Settings.clawToUSDistance));
 							
-							UltrasonicMotor.setDefaultPosition();
+							route.push(manager.sm.odo.getPosition().addDistanceToPosition(lowest - Settings.clawToUSDistance));
 							
-							manager.hm.ultrasonicPoller.pingAll();
+							UltrasonicMotor.setDefaultPosition();
 							manager.hm.ultrasonicPoller.resetUSP();
 						
 							while(!manager.hm.ultrasonicPoller.isSetup()) {
diff --git a/src/utilities/Settings.java b/src/utilities/Settings.java
index 6792ede..96022f4 100644
--- a/src/utilities/Settings.java
+++ b/src/utilities/Settings.java
@@ -44,6 +44,6 @@ public class Settings {
 	public static final double TILE_SIZE = 30.48;
 	public static final int maxBlockCapacity = 1;
 	
-	public static final int clawToUSDistance = 7; //TODO measure this. 
+	public static final int clawToUSDistance = 10; //TODO measure this. 
 	
 }

commit 682382eb0083ae06ce7d28305309fa249ee8430b
Author: RileyvanRyswyk <rileyvan@gmail.com>
Date:   Sun Nov 24 18:17:07 2013 -0500

    Odometer and OdometryCorrection commented

diff --git a/src/services/Odometer.java b/src/services/Odometer.java
index 85ea9c6..69869f1 100644
--- a/src/services/Odometer.java
+++ b/src/services/Odometer.java
@@ -15,15 +15,37 @@ import hardwareAbstraction.Drive;
  */
 
 public class Odometer implements TimerListener {
+	/**
+	 * Timer for TimerListener
+	 */
 	private Timer timer;
+	/**
+	 * Class variable for easy access to drive motors
+	 */
 	private Drive drive;
-	
+	/**
+	 * Period to update odometer, in ms
+	 */
 	private final int UPDATE_PERIOD = 25;
 	
+	/**
+	 * For synchronization
+	 */
 	private Object lock;
+	/**
+	 * Odometer variables
+	 */
 	private double x, y, theta;
+	/**
+	 * Used to find dx, dy and dtheta
+	 */
 	private double [] oldDH, dDH;
 
+	/**
+	 * Initializes x, y, theta.
+	 * Initializes timer, and starts the timer
+	 * @param manager
+	 */
 	public Odometer(Manager manager) {		
 		x = 0.0;
 		y = 0.0;
@@ -37,7 +59,9 @@ public class Odometer implements TimerListener {
 	}
 	
 	/**
-	 * Updates the odometer every UPDATE_PERIOD
+	 * Updates the odometer every {@link UPDATE_PERIOD }, based on the change in displacement and heading from {@link Drive}
+	 * 
+	 * Ensures theta is normalized between [0, 2PI)
 	 */
 	public void timedOut() {
 		drive.getDisplacementAndHeading(dDH);
@@ -61,8 +85,8 @@ public class Odometer implements TimerListener {
 	}
 	
 	/**
-	 * returns current position of the robot
-	 * @param pos
+	 * Returns the current position of the robot, as according to the odometer
+	 * @return 
 	 */
 	public Position getPosition() {
 		Position pos = new Position();
@@ -76,7 +100,7 @@ public class Odometer implements TimerListener {
 	}
 	
 	/**
-	 * returns the current heading of the robot
+	 * Returns the current heading of the robot (theta)
 	 * @return
 	 */
 	public double getTheta() {
@@ -90,7 +114,7 @@ public class Odometer implements TimerListener {
 	}
 	
 	/**
-	 * returns current y coordinate of the robot
+	 * Returns current y coordinate of the robot
 	 * @return
 	 */
 	public double getY() {
@@ -104,7 +128,7 @@ public class Odometer implements TimerListener {
 	}
 	
 	/**
-	 * returns current x coordinate of the robot
+	 * Returns current x coordinate of the robot
 	 * @return
 	 */
 	public double getX() {
@@ -118,9 +142,8 @@ public class Odometer implements TimerListener {
 	}
 	
 	/**
-	 * set the current position
+	 * Sets the current position of the odometer
 	 * @param pos
-	 * @param update
 	 */
 	public void setPosition(Position pos) {
 		synchronized (lock) {
@@ -143,8 +166,4 @@ public class Odometer implements TimerListener {
 			theta = Angle.principleAngle(theta+dTheta);
 		}
 	}
-	
-	
-	
-	
 }
diff --git a/src/services/OdometryCorrection.java b/src/services/OdometryCorrection.java
index 98b8a4c..87462c2 100644
--- a/src/services/OdometryCorrection.java
+++ b/src/services/OdometryCorrection.java
@@ -8,25 +8,74 @@ import lejos.nxt.comm.RConsole;
 import lejos.util.Timer;
 import lejos.util.TimerListener;
 import manager.*;
-
+/**
+ * OdometryCorrection makes use of the {@link LinePoller},
+ * each time a new line is detected, it will record the position of the odometer and what sensor detected the line.
+ * Then it will check to see if the previous detected line was with the other sensor.  If that is the case then, provided
+ * the difference in x, y, theta of the two poistions is relatively small and the robot is roughly in the center of the tile, 
+ * it will update x or y and theta of the {@link odometer}.
+ * 
+ * Note: The current methods used required the robot to travel in the center of the tiles, frequently enough.
+ * @author Riley 
+ *
+ */
 public class OdometryCorrection implements TimerListener  {
-	
+	/**
+	 * Period to update, should be similar to update period of {@link LinePoller}
+	 */
 	public final int UPDATE_PERIOD = 15;
+	/**
+	 * Max distance to adjust x or y
+	 */
 	public final int MAX_CHANGE_DISTANCE = 8;
+	/**
+	 * Max angle to adjust theta;
+	 */
 	public final int MAX_CHANGE_ANGLE = 30;
+	/**
+	 * Max distance from the center of the tile to still correct
+	 */
+	public final int MAX_DISTANCE_FROM_TILE_CENTER = 3;
+	/**
+	 * Max distance between points to correct (i.e. max distance between left sensor detection position and right senosr detection position)
+	 */
+	public final int MAX_DISTANCE_BETWEEN_POINTS = 5;
 	
+	/**
+	 * Timer for timer listener
+	 */
 	public Timer timer;
+	/**
+	 * {@link Manager} for access to robots other functions 
+	 */
 	public Manager manager;
-	
+	/**
+	 * id of the left sensor
+	 */
 	private int left = 0;
+	/**
+	 * id of the right sensor
+	 */
 	private int right = 1;
 	
+	/**
+	 * The odometer position at the detection of the last line
+	 */
 	private Position lastPos;
+	/**
+	 * the id of the last sensor to detect a line
+	 */
 	private int lastSensor;
 	
-	//Sets (0,0) to center of the of the first grid intersection
+	/**
+	 * For offseting the grid lines (i.e. to move 0,0 away from the first grid intersection )
+	 */
 	private double xOffset = 0, yOffset = 0;
 	
+	/**
+	 * Initializes timer
+	 * @param manager
+	 */
 	public OdometryCorrection(Manager manager) {
 		this.timer = new Timer(UPDATE_PERIOD, this);
 		this.lastPos = null;
@@ -34,20 +83,26 @@ public class OdometryCorrection implements TimerListener  {
 		this.manager = manager;
 	}
 	
+	/**
+	 * Starts odometry Correction
+	 */
 	public void start() {
 		timer.start();
 	}
 	
+	/**
+	 * Stops odometry Correction
+	 */
 	public void stop() {
 		timer.stop();
 	}
 	
-	
 	/**
-	 * Based on the which sensor is entered a line and the state of the last detected one, 
-	 * the method will call the relevant lineDetected or setup lastPos
+	 * Based on which sensor has entered a line and the state of the last detected one, 
+	 * the method will call the relevant lineDetected and/or setup lastPos
 	 */
 	public void timedOut() {
+		//Line detected by left sensor
 		if(manager.hm.linePoller.enteringLine(left)) {
 			if(this.lastPos == null) {
 				this.lastPos = manager.sm.odo.getPosition();
@@ -61,7 +116,7 @@ public class OdometryCorrection implements TimerListener  {
 				lastSensor = left;
 			}
 		}
-		
+		//Line detected by right sensor
 		if(manager.hm.linePoller.enteringLine(right)) {
 			if(this.lastPos == null) {
 				this.lastPos = manager.sm.odo.getPosition();
@@ -80,7 +135,7 @@ public class OdometryCorrection implements TimerListener  {
 	}
 	
 	/**
-	 * When only one sensor detected a line
+	 * When only one sensor detected a line. Currently not implemented. 
 	 * @param pos
 	 * @param sensor
 	 */
@@ -90,7 +145,7 @@ public class OdometryCorrection implements TimerListener  {
 	
 	
 	/**
-	 * Two sensors detected a line
+	 * Both sensors detected a line, decides whether the points are consider value according to thresholds, and then how to correct the robots position
 	 * @param leftPos
 	 * @param rightPos
 	 */
@@ -99,12 +154,14 @@ public class OdometryCorrection implements TimerListener  {
 		/*
 		 * Ensures that the point are reasonably close to each other
 		 */
-		if(leftPos.distanceToPoint(rightPos) > 5 && Math.abs(leftPos.theta-rightPos.theta) > 0.1 ) {
+		if(leftPos.distanceToPoint(rightPos) > MAX_DISTANCE_BETWEEN_POINTS && Math.abs(leftPos.theta-rightPos.theta) > 0.1 ) {
 			return;
 		}
 		
+		//Average the x and y of the line detected, as the robot should detect both at the same time if it is going perpendicular to the grid line
 		double x = (leftPos.x + rightPos.x) / 2.0;
 		double y = (leftPos.y + rightPos.y) / 2.0;
+		//Average the heading 
 		double theta = (leftPos.theta + rightPos.theta) / 2.0;
 		
 		double dx = 0;
@@ -122,14 +179,14 @@ public class OdometryCorrection implements TimerListener  {
 			double line = getClosestX(x, theta);
 			
 			//make sure the sensor is not close to a line parallel to direction of travel
-			if(Math.abs(x-line) > Settings.LS_WIDTH / 2 + 3) {
+			if(Math.abs(x-line) > Settings.LS_WIDTH / 2 + MAX_DISTANCE_FROM_TILE_CENTER) {
 				
 				/*
 				 * getClosestY returns the closest line plus the offset for the light Sensor	
 				 */
 				line = getClosestY(y, theta);
 				
-				//if we are within 10cm of the line, update our position
+				//if we are within MAX_CHANGE_DISTANCE of the line, set dy
 				if(Math.abs(line - y) < MAX_CHANGE_DISTANCE) {
 					RConsole.println("dY: " + String.valueOf(line-y));
 					dy = line - y;
@@ -149,14 +206,14 @@ public class OdometryCorrection implements TimerListener  {
 			double line = getClosestY(y, theta);
 			
 			// make sure the sensor is not close to a line parallel with direction of travel
-			if(Math.abs(y-line) > Settings.LS_WIDTH / 2 + 3) {
+			if(Math.abs(y-line) > Settings.LS_WIDTH / 2 + MAX_DISTANCE_FROM_TILE_CENTER) {
 			
 				/*
 				 * We have already detected a x line, so get the closest line
 				 */
 				line = getClosestX(x, theta);
 				
-				//if we are within 10cm of the line, update our position
+				//if we are within MAX_CHANGE_DISTANCE of the line, update dx
 				if(Math.abs(line - x) < MAX_CHANGE_DISTANCE) {
 					RConsole.println("dX: " + String.valueOf(line-x));
 					dx = line - x;
@@ -170,8 +227,9 @@ public class OdometryCorrection implements TimerListener  {
 		/* 
 		 * Angle Correction
 		 */
-		
+		//correction angle is arctan (displacement/width)
 		double dTheta = Math.atan(leftPos.distanceToPoint(rightPos) / Settings.LS_WIDTH);
+		//adjust sign
 		if(firstSensor == left) {
 			dTheta *= -1;
 		}

commit 49c83e8593dce5df88735b0c09f6246f857603de
Author: RileyvanRyswyk <rileyvan@gmail.com>
Date:   Sun Nov 24 17:33:16 2013 -0500

    Localization Commented for javadoc

diff --git a/src/services/Localization.java b/src/services/Localization.java
index 6887243..4a2bebb 100644
--- a/src/services/Localization.java
+++ b/src/services/Localization.java
@@ -9,33 +9,73 @@ import lejos.nxt.comm.RConsole;
 import lejos.util.Timer;
 import lejos.util.TimerListener;
 import manager.*;
-
+/**
+ * Localization handles all initial localization needs, both Ultrasonic and Line localization.
+ * It will also account for the different starting corners set in {@link Settings}
+ * 
+ * @author Riley
+ * @author Sa
+ *
+ */
 public class Localization implements TimerListener {
 	
 	private Manager manager;
 	private Timer timer;
 	
 	
-	//Speed in deg/sec of which to rotate during localization
+	/**
+	 * Speed in deg/sec of which to rotate during localization
+	 */
 	private double ROTATION_SPEED = 30;
 	
-	//period to check ultrasonic sensor in ms
+	/**
+	 * Period to check ultrasonic sensor in ms
+	 */
 	private final int UPDATE_PERIOD = 20;
 	
-	//threshold distance in cm, to determine if we are at a critical angle
+	/**
+	 * threshold distance in cm, to determine if we are at a critical angle
+	 */
 	private final int THRESHOLD = 30;
 	
+	/**
+	 * The type of detection to use for {@link angleA}
+	 */
 	private boolean rising;
+	/**
+	 * The value of the first critical angle
+	 */
 	private double angleA;
+	/**
+	 * Value of the second critical angle
+	 */
 	private double angleB;
 	
+	/**
+	 * True if lineLocalization has been setup
+	 */
 	private boolean lineLocalization;
+	/**
+	 * Number of lines detected by the right sensor
+	 */
 	private int rightLineCount;
+	/**
+	 * number of lines detected by the left sensor.  Offset by 4
+	 */
 	private int leftLineCount;
+	/**
+	 * Array of odometer headings when the grid lines are detected.
+	 *  (0-3) -> right,
+	 *  (4-7) -> left
+	 */
 	private double[] lineDetectedHeadings = new double[8]; 
 	
-	public boolean corrected = false;
+	//public boolean corrected = false;
 	
+	/**
+	 * Localization constructor, initializes Timer for TimerListener
+	 * @param manager
+	 */
 	public Localization(Manager manager) {
 		this.manager = manager;
 		this.timer = new Timer(UPDATE_PERIOD, this);
@@ -43,6 +83,10 @@ public class Localization implements TimerListener {
 	
 	/**
 	 * Starts the localization process
+	 * 
+	 * It will take the current center ultrasonic reading to determine if the robot is facing a wall or the field.  
+	 * Based on this it will decide whether the robot is to do falling then rising localization or rising then rising localization
+	 * 
 	 */
 	public void start() {
 		
@@ -57,7 +101,7 @@ public class Localization implements TimerListener {
 			manager.um.nap(120);
 			start();
 		}
-		
+		// Facing a wall
 		else if(usReading < THRESHOLD) {
 			rising = true;
 			
@@ -90,22 +134,24 @@ public class Localization implements TimerListener {
 	}
 	
 	/**
-	 * Controls Localization
-	 * Calls relevant methods depending on stage of localization 
+	 * Controls Localization.
+	 * Calls relevant helper methods depending on stage of localization 
 	 */
 	public void timedOut() {
-		// ultrasonic localization complete. 
+		// ultrasonic localization not complete. 
 		if(Double.isNaN(angleB)) {
 			ultrasonicLocalization();
 		} 
 //		//not finished line localization
-		else if(leftLineCount < 4 || rightLineCount < 4) {
-			//move to correct orientation for line localization
+		else if(leftLineCount < 4 || rightLineCount < 8) {
+			//move to correct starting orientation for line localization
 			if(!lineLocalization) {
 				prepareLineLocalization();
-			}else{
+			}
+			// Carry out line localization
+			else{
 				lineLocalization();
-				}
+			}
 		} 
 		//localization complete, update position
 		else {
@@ -117,24 +163,31 @@ public class Localization implements TimerListener {
 	}
 	
 	/**
-	 * If the robot starts facing the fall the robot will do rising, rising edge detection (angleA, angleB)
-	 * if the robot starts facing the field the robot will do falling edge, rising edge (angleA, angleB) 
+	 * If the robot started facing the fall the robot will do rising, rising edge detection (angleA, angleB)
+	 * if the robot started facing the field the robot will do falling edge, rising edge (angleA, angleB) 
 	 */
-	public void ultrasonicLocalization() {
+	private void ultrasonicLocalization() {
+		//retrieve current reading
 		int distance = updateUltrasonic();
 		
+		// Angle A is not yet set
 		if(Double.isNaN(angleA)) {
+			//if doing rising edge detection for Angle A, rotate CCW
 			if(rising) {
 				manager.hm.drive.setSpeeds(0, -ROTATION_SPEED);
-				if(distance > THRESHOLD) {
-					
+				
+				//No longer seeing the wall -> found angle A
+				if(distance > THRESHOLD) {	
 					Sound.beep();
 					angleA = manager.sm.odo.getTheta();
 					RConsole.println(String.valueOf(angleA));
 					manager.hm.drive.setSpeeds(0, ROTATION_SPEED);
 				}
-			} else {
+			} 
+			//Doing falling edge detection for Angle A, rotate CW
+			else {
 				manager.hm.drive.setSpeeds(0, ROTATION_SPEED);
+				//no longer seeing the field -> found angle A
 				if(distance < THRESHOLD) {
 					Sound.beep();
 					manager.hm.drive.stop();
@@ -142,8 +195,12 @@ public class Localization implements TimerListener {
 					RConsole.println(String.valueOf(angleA));
 				}
 			}
-		} else {
+		} 
+		//Angle B is not yet set
+		else {
 			manager.hm.drive.setSpeeds(0, ROTATION_SPEED);
+			// if no longer seeing a wall -> found angle B
+			// update odometer theta and stop
 			if(distance > THRESHOLD && Math.abs(angleA-manager.sm.odo.getTheta()) > 1) {
 				Sound.beep();
 				angleB = manager.sm.odo.getTheta();
@@ -155,10 +212,12 @@ public class Localization implements TimerListener {
 	}
 	
 	/**
-	 * Updates theta based on the results of ultrasonic sensor localization
+	 * Updates Odometer theta based on the results of ultrasonic sensor localization
 	 */
-	public void updateTheta() {
+	private void updateTheta() {
 		double deltaTheta = -(angleA + angleB) / 2;
+		
+		// The exact values for rising edge have not been found!
 		if(rising) {
 			//Depending on what angle is bigger, offset deltaTheta to the correct amount
 			if(angleA > angleB) {
@@ -181,20 +240,23 @@ public class Localization implements TimerListener {
 	}
 	
 	/**
-	 * calls checkLineSensor for each lineSensor
+	 * Calls checkLineSensor for each lineSensor
 	 */
-	public void lineLocalization() {
+	private void lineLocalization() {
+		//right sensor
 		checkLineSensor(true);
+		//left sensor
 		checkLineSensor(false);
 	}
 	
 	/**
-	 * Updates the odometers position based on line localization results
+	 * Updates the odometer's position based on line localization results
+	 * Uses method similar to lab 5
 	 */
-	public void updatePosition() {
+	private void updatePosition() {
 		
 		double thetaXminus = (lineDetectedHeadings[0] + lineDetectedHeadings[4]) / 2.0
-							 + ( (lineDetectedHeadings[4] < Math.PI) ? Math.PI : 0 );  //Correction term
+							 + ( (lineDetectedHeadings[4] < Math.PI) ? Math.PI : 0 );  //Correction term, in case the branch cut has been passed
 		double thetaYminus = (lineDetectedHeadings[3] + lineDetectedHeadings[7]) / 2.0;
 		double thetaYplus = (lineDetectedHeadings[1] + lineDetectedHeadings[5]) / 2.0;
 		double thetaXplus = (lineDetectedHeadings[2] + lineDetectedHeadings[6]) / 2.0;
@@ -211,16 +273,23 @@ public class Localization implements TimerListener {
 		double dTheta = (dThetaX + dThetaY) / 2.0;
 		
 		manager.sm.odo.adjustPosition(x, y, dTheta);
-		
-		
 	}
 	
-	public void prepareLineLocalization() {
+	/**
+	 * Ensures that the robot is facing towards the center of the field before starting line localization
+	 * This way the light sensors will consistently cross the lines in the same order every time
+	 */
+	private void prepareLineLocalization() {
+		//Heading to big, rotate CW
 		if(manager.sm.odo.getTheta() > (Math.PI/4 + 0.2)) {
 			manager.hm.drive.setSpeeds(0, ROTATION_SPEED);
-		} else if(manager.sm.odo.getTheta() < (Math.PI/4  - 0.2)) {
+		} 
+		//Heading to small, rotate CCW
+		else if(manager.sm.odo.getTheta() < (Math.PI/4  - 0.2)) {
 			manager.hm.drive.setSpeeds(0, -ROTATION_SPEED);
-		} else {
+		} 
+		//Heading is in acceptable starting region, start localization
+		else {
 			Sound.buzz();
 			manager.hm.drive.setSpeeds(0, ROTATION_SPEED);
 			lineLocalization = true;
@@ -230,12 +299,10 @@ public class Localization implements TimerListener {
 	
 	}
 	
-	
-	
 	/**
 	 * Adjusts the localization position for the starting corner
 	 */
-	public void adjustForStartingCorner() {
+	private void adjustForStartingCorner() {
 		double x1 = manager.sm.odo.getX();
 		double y1 = manager.sm.odo.getY();
 		double deltaTheta = manager.sm.odo.getTheta();
@@ -267,22 +334,31 @@ public class Localization implements TimerListener {
 		
 	}
 
-	
-	public int updateUltrasonic() {
+	/**
+	 * Calls getUSReading from {@link UltrasonicPoller} for the center ultrasonic sensor
+	 * @return current center ultrasonic reading
+	 */
+	private int updateUltrasonic() {
 		return manager.hm.ultrasonicPoller.getUSReading(1);
 	}
 	
 	/**
-	 * Updates the lineDetectedHeadings[] based on whether a new line has been detected
+	 * Updates the lineDetectedHeadings[] based on whether a new line has been detected by {@link LinePoller}
 	 * @param rightSensor -> true if the right sensor is to be checked, false if the left sensor is to be checked
 	 */
-	public void checkLineSensor(boolean rightSensor) {
+	private void checkLineSensor(boolean rightSensor) {
+		//True if a new line has been detected
 		if(manager.hm.linePoller.enteringLine((rightSensor) ? 1 : 0)) {
+			//if it was the right sensor that detected the line
+			//add the current heading and increase rightLineCount
 			if(rightSensor && rightLineCount < 4) {
 				Sound.beep();
 				lineDetectedHeadings[rightLineCount] = manager.sm.odo.getTheta();
 				rightLineCount++;
-			} else if (leftLineCount < 8) {
+			} 
+			//Otherwise if it was the left sensor that detected the line
+			//add current heading and increase leftLineCount
+			else if (leftLineCount < 8) {
 				lineDetectedHeadings[leftLineCount] = manager.sm.odo.getTheta();
 				leftLineCount++;
 				Sound.beep();

commit 7dc4bc302b699362d789184398f326cf5ed7728f
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Sun Nov 24 16:42:55 2013 -0500

    Removed some unneeded code.

diff --git a/src/hardwareAbstraction/Claw.java b/src/hardwareAbstraction/Claw.java
index c642ac4..be4c1ed 100644
--- a/src/hardwareAbstraction/Claw.java
+++ b/src/hardwareAbstraction/Claw.java
@@ -14,13 +14,9 @@ public class Claw {
 	 */
 	public static int grabObject() {
 		RConsole.println("grabbing object");
-		try {
-			claw.setAcceleration(200);
-			claw.setSpeed(150);
-			claw.rotateTo(0, true);
-		} catch (ArrayIndexOutOfBoundsException e){
-			
-		}
+		claw.setAcceleration(200);
+		claw.setSpeed(150);
+		claw.rotateTo(0, true);
 		return 2000;
 	}
 	
@@ -30,13 +26,9 @@ public class Claw {
 	 */
 	public static int releaseObject() {
 		RConsole.println("releasing object");
-		try {
-			claw.setAcceleration(200);
-			claw.setSpeed(150);
-			claw.rotateTo(-value, true);
-		} catch (ArrayIndexOutOfBoundsException e){
-			
-		}
+		claw.setAcceleration(200);
+		claw.setSpeed(150);
+		claw.rotateTo(-value, true);
 		return 2000;
 	}
 }
diff --git a/src/hardwareAbstraction/Forklift.java b/src/hardwareAbstraction/Forklift.java
index 16a16f2..9f9e634 100644
--- a/src/hardwareAbstraction/Forklift.java
+++ b/src/hardwareAbstraction/Forklift.java
@@ -108,15 +108,9 @@ public class Forklift {
 	private static int changeHeight(int newHeight, int oldHeight) {
 		int rotation = convertDistanceToAngle(newHeight);
 		int naptime = Math.abs(newHeight - oldHeight) * 400;
-		
-		try {
-			lift.setAcceleration(1000);
-			lift.setSpeed(200);
-			lift.rotateTo(-rotation, true);
-		} catch (ArrayIndexOutOfBoundsException e){
-		
-		}
-		
+		lift.setAcceleration(1000);
+		lift.setSpeed(200);
+		lift.rotateTo(-rotation, true);
 		return naptime;
 	}
 
diff --git a/src/launcher/Launcher.java b/src/launcher/Launcher.java
index 2bc4520..e8604ad 100644
--- a/src/launcher/Launcher.java
+++ b/src/launcher/Launcher.java
@@ -36,22 +36,39 @@ public class Launcher {
 	 * @param args
 	 */
 	public static void main(String[] args) {
-		//RConsole.openBluetooth(20000);
+		RConsole.openUSB(20000);
 		
 		Manager manager = new Manager();
 		Button.waitForPress();
 		
+		manager.cm.setState(State.PAUSE);
+		
+		try {
+			Thread.sleep(Forklift.setHeight(Forklift.ForkliftState.LIFT_HEIGHT));
+		} catch (InterruptedException e) {
+		}
+		
+		try {
+			Thread.sleep(Forklift.setHeight(Forklift.ForkliftState.GROUND));
+		} catch (InterruptedException e) {
+		}
+		
+		try {
+			Thread.sleep(Forklift.setHeight(Forklift.ForkliftState.SCAN_HEIGHT_LOW));
+		} catch (InterruptedException e) {
+		}
+		
 		/*manager.sm.localization.start();
 		
 		while(manager.cm.getState() == State.LOCALIZING) {
 			manager.um.nap(150);
 		}*/
 		
-		manager.sm.odo.adjustPosition(180, 0, Math.PI);
-		manager.sm.odoCorrection.start();
-		manager.sm.nav.start();
-		
-		manager.cm.setState(State.SEARCH);
+//		manager.sm.odo.adjustPosition(180, 0, Math.PI);
+//		manager.sm.odoCorrection.start();
+//		manager.sm.nav.start();
+//		
+//		manager.cm.setState(State.SEARCH);
 		
 		//Communicator com = new Communicator("NXT");
 		

commit b40404ad6ba7f6ab801cbe49abca7fadc1085016
Author: RileyvanRyswyk <rileyvan@gmail.com>
Date:   Sun Nov 24 16:16:36 2013 -0500

    Localization fix for bottom right and top left

diff --git a/src/services/Localization.java b/src/services/Localization.java
index 08a4aec..6887243 100644
--- a/src/services/Localization.java
+++ b/src/services/Localization.java
@@ -244,7 +244,7 @@ public class Localization implements TimerListener {
 			deltaTheta += Math.PI/2;
 			double x2 = -y1;
 			y1 = x1;
-			x1 *= x2;
+			x1 = x2;
 			x1 += (Settings.FIELD_X - 2)*Settings.TILE_SIZE; 
 			//return 3.0 * Math.PI / 4.0;
 			
@@ -258,7 +258,7 @@ public class Localization implements TimerListener {
 		} else if (Settings.startingCorner == StartingCorner.TOP_LEFT) {
 			deltaTheta -= Math.PI/2;
 			double y2 = -x1;
-			x1 *= y1;
+			x1 = y1;
 			y1 += y2 + (Settings.FIELD_Y - 2)*Settings.TILE_SIZE; 
 			//return 7.0 * Math.PI / 4.0;
 		}

commit 19cd7348232572ac1f95c72dc994292ba29b2cca
Author: RileyvanRyswyk <rileyvan@gmail.com>
Date:   Sun Nov 24 15:01:42 2013 -0500

    Search and Mapper testing code and fixes

diff --git a/src/controllers/Search.java b/src/controllers/Search.java
index b8b457c..b907de4 100644
--- a/src/controllers/Search.java
+++ b/src/controllers/Search.java
@@ -39,16 +39,16 @@ public class Search extends Controller  {
 	private void defaultRouter() {
 		if(manager.sm.nav.getRoute().empty()) {
 			switch(this.defaultPath) {
-			case 0 : manager.sm.nav.addToRoute(new Point(15,15));
+			case 0 : manager.sm.nav.addToRoute(new Point(75,15));
 			break;
-			case 1 : manager.sm.nav.addToRoute(new Point(15,135));
+			case 1 : manager.sm.nav.addToRoute(new Point(75,75));
 			break;
-			case 2 : manager.sm.nav.addToRoute(new Point(165,45));
+			case 2 : manager.sm.nav.addToRoute(new Point(165,75));
 			break;
 			//wont run on the crack
-			case 3 : manager.sm.nav.addToRoute(new Point(00,120)); 
+			case 3 : manager.sm.nav.addToRoute(new Point(165,135)); 
 			break;
-			case 4 : manager.sm.nav.addToRoute(new Point(180,120));
+			case 4 : manager.sm.nav.addToRoute(new Point(15,135));
 			break;
 			case 5 : manager.sm.nav.addToRoute(new Point(180,180));
 			break;
diff --git a/src/launcher/Launcher.java b/src/launcher/Launcher.java
index 19335bd..2bc4520 100644
--- a/src/launcher/Launcher.java
+++ b/src/launcher/Launcher.java
@@ -41,6 +41,17 @@ public class Launcher {
 		Manager manager = new Manager();
 		Button.waitForPress();
 		
+		/*manager.sm.localization.start();
+		
+		while(manager.cm.getState() == State.LOCALIZING) {
+			manager.um.nap(150);
+		}*/
+		
+		manager.sm.odo.adjustPosition(180, 0, Math.PI);
+		manager.sm.odoCorrection.start();
+		manager.sm.nav.start();
+		
+		manager.cm.setState(State.SEARCH);
 		
 		//Communicator com = new Communicator("NXT");
 		
@@ -111,11 +122,7 @@ public class Launcher {
 //		}
 		
 		
-		manager.sm.localization.start();
 		
-		while(manager.cm.getState() == State.LOCALIZING) {
-			manager.um.nap(150);
-		}
 		
 		//sleep(Forklift.setHeight(ForkliftState.SCAN_HEIGHT_LOW));
 		
diff --git a/src/services/Mapper.java b/src/services/Mapper.java
index e41654f..2afed5f 100644
--- a/src/services/Mapper.java
+++ b/src/services/Mapper.java
@@ -38,7 +38,24 @@ public class Mapper {
 			currentValue[left] = manager.hm.ultrasonicPoller.getUSReading(left);
 			currentValue[right] = manager.hm.ultrasonicPoller.getUSReading(right);
 			
-			if(!start(left)) {
+			if(!startSet[left]) {
+				start(left);
+			} else if (end(left)) {
+				if(calculatePoint(left,returnPoint)) {
+					return true;
+				}
+			}
+			
+			if(!startSet[right]) {
+				start(right);
+			} else if (end(right)) {
+				if(calculatePoint(right,returnPoint)) {
+					return true;
+				}
+			}
+			
+			
+/*			if(!start(left)) {
 				if(end(left)) {
 					if(calculatePoint(left,returnPoint)) {
 						return true;
@@ -53,9 +70,11 @@ public class Mapper {
 					}
 				}
 			}
+*/
 		}
 		
 		return false;
+		
 	}
 	
 	

commit e517dcced18bbc5d7628febf39cda42fd192995e
Author: RileyvanRyswyk <rileyvan@gmail.com>
Date:   Sun Nov 24 14:25:54 2013 -0500

    Updated search and navigation scanning ahead

diff --git a/src/controllers/Search.java b/src/controllers/Search.java
index ff4c68a..b8b457c 100644
--- a/src/controllers/Search.java
+++ b/src/controllers/Search.java
@@ -17,11 +17,15 @@ public class Search extends Controller  {
 	
 	public void run() {
 		defaultRouter();
-		if(UltrasonicMotor.isForward) {
-			manager.um.nap(UltrasonicMotor.setDefaultPosition());
+/*		if(UltrasonicMotor.isForward) {
+			UltrasonicMotor.setDefaultPosition();
+			manager.hm.ultrasonicPoller.pingAll();
 			manager.hm.ultrasonicPoller.resetUSP();
+			while(!manager.hm.ultrasonicPoller.isSetup()) {
+				manager.um.nap(200);
+			}
 		}
-		
+*/		
 		Point pointOfInterest = new Point();
 		
 		if(manager.sm.mapper.update(pointOfInterest)) {
diff --git a/src/hardwareAbstraction/UltrasonicMotor.java b/src/hardwareAbstraction/UltrasonicMotor.java
index 916b630..05a11e2 100644
--- a/src/hardwareAbstraction/UltrasonicMotor.java
+++ b/src/hardwareAbstraction/UltrasonicMotor.java
@@ -10,7 +10,16 @@ public class UltrasonicMotor {
 	 * pointing away from the center of the robot. Therefore, it will be at an
 	 * angle when viewed from the front of the robot.
 	 */
-	public static synchronized int setDefaultPosition() {
+	public static synchronized void setDefaultPosition() {
+		isForward = false;
+		Settings.ultrasonicMotor.rotateTo(90);
+		while(Settings.ultrasonicMotor.isMoving()) {
+			sleep(100);
+		}
+	}
+	
+	
+	/*public static synchronized int setDefaultPosition() {
 		try {
 			Settings.ultrasonicMotor.setAcceleration(200);
 			Settings.ultrasonicMotor.setSpeed(200);
@@ -19,14 +28,22 @@ public class UltrasonicMotor {
 		} catch (ArrayIndexOutOfBoundsException e) {
 		} 
 		return 2000;
-	}
+	}*/
 	
 	/**
 	 * The forward position is set to be with the two side ultrasonic sensors
 	 * pointing directly ahead, in line with the centre ultrasonic sensor. Therefore, it will be at an
 	 * angle when viewed from the front of the robot.
 	 */
-	public static synchronized int setForwardPosition() {
+	public static synchronized void setForwardPosition() {
+		isForward = true;
+		Settings.ultrasonicMotor.rotateTo(0);
+		while(Settings.ultrasonicMotor.isMoving()) {
+			sleep(100);
+		}
+	}
+	
+	/*public static synchronized int setForwardPosition() {
 		
 		try {
 			Settings.ultrasonicMotor.setAcceleration(200);
@@ -36,6 +53,16 @@ public class UltrasonicMotor {
 		} catch (ArrayIndexOutOfBoundsException e) {
 		} 
 		return 2000;
+	}*/
+	
+	
+	private static void sleep(int time) {
+		try {
+			Thread.sleep(time);
+		} catch (InterruptedException e) {
+			// TODO Auto-generated catch block
+			e.printStackTrace();
+		}
 	}
 
 }
diff --git a/src/manager/UtilityManager.java b/src/manager/UtilityManager.java
index 53aaf0c..ddc6abd 100644
--- a/src/manager/UtilityManager.java
+++ b/src/manager/UtilityManager.java
@@ -21,8 +21,14 @@ public class UtilityManager {
 		this.command = new NXTRemoteCommand(comLink);
 		
 		Settings.clawMotor = new NXTRemoteMotor(command, Settings.CLAW_MOTOR_ID);
+		Settings.clawMotor.setAcceleration(200);
+		Settings.clawMotor.setSpeed(200);
 		Settings.liftMotor = new NXTRemoteMotor(command, Settings.LIFT_MOTOR_ID);
+		Settings.liftMotor.setAcceleration(200);
+		Settings.liftMotor.setSpeed(200);
 		Settings.ultrasonicMotor = new NXTRemoteMotor(command, Settings.ULTRASONIC_MOTOR_ID);
+		Settings.ultrasonicMotor.setAcceleration(200);
+		Settings.ultrasonicMotor.setSpeed(200);
 		
 		this.map = new Map();
 	}
diff --git a/src/services/Navigation.java b/src/services/Navigation.java
index 7b71896..b93632d 100644
--- a/src/services/Navigation.java
+++ b/src/services/Navigation.java
@@ -87,22 +87,18 @@ public class Navigation implements TimerListener {
 						scannedAhead = true;
 						
 						manager.hm.drive.stop();
-						sleep(UltrasonicMotor.setForwardPosition());
-						/*
-						 * TODO this must be calibrated to the delay experienced
-						 * on the ultrasonic sensor. I want to make sure that 5
-						 * readings have been picked up by the ultrasonic
-						 * sensor. Therefore 5 seconds should be long enough
-						 * (until we can test otherwise).
-						 */
+						UltrasonicMotor.setForwardPosition();
+						manager.hm.ultrasonicPoller.pingSequential();
 						manager.hm.ultrasonicPoller.resetUSP();
 						while(!manager.hm.ultrasonicPoller.isSetup()) {
+							
 							manager.um.nap(200);
 						}
+						
 						int lowest = manager.hm.ultrasonicPoller.getLowestReading();
-						manager.sm.lcdInfo.debugValue = lowest;
-												
+									
 						if (lowest < 20) {
+							
 							RConsole.println("Read less than 20");
 //							Sound.beepSequenceUp();
 							//TODO comment this back in when recognize works. 
@@ -111,18 +107,32 @@ public class Navigation implements TimerListener {
 							
 						}
 						else if (lowest < 50) {
+							
 							RConsole.println("Read less than 30");
 							RConsole.println("Pushing the following to the stack" + manager.sm.odo.getPosition().addDistanceToPosition(lowest - 5));
 							//route.push(manager.sm.odo.getPosition().addDistanceToPosition(lowest - Settings.clawToUSDistance));
-							sleep(UltrasonicMotor.setDefaultPosition());
+							
+							UltrasonicMotor.setDefaultPosition();
+							
+							manager.hm.ultrasonicPoller.pingAll();
+							manager.hm.ultrasonicPoller.resetUSP();
+						
+							while(!manager.hm.ultrasonicPoller.isSetup()) {
+								manager.um.nap(200);
+							}
+							
 							manager.cm.setState(State.SEARCH);
 							Sound.beepSequence();
 						} else {
-							sleep(UltrasonicMotor.setDefaultPosition());
+							
+							UltrasonicMotor.setDefaultPosition();
+							manager.hm.ultrasonicPoller.pingAll();
 							manager.hm.ultrasonicPoller.resetUSP();
+							
 							while(!manager.hm.ultrasonicPoller.isSetup()) {
 								manager.um.nap(200);
 							}
+							
 							manager.cm.setState(State.SEARCH);
 							Sound.beep();
 							// do no processing, just continue along doing nothing. 

commit 88fe1e9a80456fa9339c66176507791756f636f9
Author: RileyvanRyswyk <rileyvan@gmail.com>
Date:   Sun Nov 24 14:25:23 2013 -0500

    Added field size

diff --git a/src/utilities/Settings.java b/src/utilities/Settings.java
index 62ffc2a..6792ede 100644
--- a/src/utilities/Settings.java
+++ b/src/utilities/Settings.java
@@ -25,7 +25,6 @@ public class Settings {
 	public static final int ULTRASONIC_MOTOR_ID = 2;
 	public static final int LIFT_MOTOR_ID = 3;
 	
-	
 	public static NXTRemoteMotor clawMotor;
 	public static NXTRemoteMotor ultrasonicMotor;
 	public static NXTRemoteMotor liftMotor;
@@ -36,6 +35,8 @@ public class Settings {
 	public static Point[] redZoneCoords;
 	public static Point[] greenZoneCoords = new Point[2]; //TODO remove once BT is working.
 	public static StartingCorner startingCorner = StartingCorner.BOTTOM_RIGHT;
+	public static final int FIELD_X = 8;
+	public static final int FIELD_Y = 8;
 	
 	public static final double LS_OFFSET = 15.0;
 	public static final double LS_WIDTH = 11.5;

commit 5a7d5c9c307290a91c08af2a161ffece02c65f08
Author: RileyvanRyswyk <rileyvan@gmail.com>
Date:   Sun Nov 24 14:25:11 2013 -0500

    Updated localization in different corners
    
    now includes the x and y offset so it should be completely done now!

diff --git a/src/services/Localization.java b/src/services/Localization.java
index 6d01af3..08a4aec 100644
--- a/src/services/Localization.java
+++ b/src/services/Localization.java
@@ -233,7 +233,7 @@ public class Localization implements TimerListener {
 	
 	
 	/**
-	 * returns the desired starting angle for line localization
+	 * Adjusts the localization position for the starting corner
 	 */
 	public void adjustForStartingCorner() {
 		double x1 = manager.sm.odo.getX();
@@ -242,18 +242,29 @@ public class Localization implements TimerListener {
 		
 		if(Settings.startingCorner == StartingCorner.BOTTOM_RIGHT) {
 			deltaTheta += Math.PI/2;
-			manager.sm.odo.setPosition(new Position(-y1, x1, deltaTheta));
+			double x2 = -y1;
+			y1 = x1;
+			x1 *= x2;
+			x1 += (Settings.FIELD_X - 2)*Settings.TILE_SIZE; 
 			//return 3.0 * Math.PI / 4.0;
 			
 		} else if (Settings.startingCorner == StartingCorner.TOP_RIGHT) {
 			deltaTheta += Math.PI;
-			manager.sm.odo.setPosition(new Position(-x1, -y1, deltaTheta));
+			x1 *= -1;
+			y1 *= -1;
+			x1 += (Settings.FIELD_X - 2)*Settings.TILE_SIZE; 
+			y1 += (Settings.FIELD_Y - 2)*Settings.TILE_SIZE; 
 			//return 5.0 * Math.PI / 4.0;
 		} else if (Settings.startingCorner == StartingCorner.TOP_LEFT) {
 			deltaTheta -= Math.PI/2;
-			manager.sm.odo.setPosition(new Position(y1, -x1, deltaTheta));
+			double y2 = -x1;
+			x1 *= y1;
+			y1 += y2 + (Settings.FIELD_Y - 2)*Settings.TILE_SIZE; 
 			//return 7.0 * Math.PI / 4.0;
-		} 
+		}
+		
+		manager.sm.odo.setPosition(new Position(x1, y1, deltaTheta));
+		
 	}
 
 	

commit f52351e17c0c1dee7e8c9cbcc9e8ed195cb6832c
Author: RileyvanRyswyk <rileyvan@gmail.com>
Date:   Sun Nov 24 14:24:24 2013 -0500

    Fix getLowestReading of NXTRemoteUltrasonicPoller

diff --git a/src/hardwareAbstraction/NXTRemoteMotor.java b/src/hardwareAbstraction/NXTRemoteMotor.java
index d9005e6..4e3f6b5 100644
--- a/src/hardwareAbstraction/NXTRemoteMotor.java
+++ b/src/hardwareAbstraction/NXTRemoteMotor.java
@@ -201,7 +201,7 @@ public class NXTRemoteMotor implements RemoteCommands, RegulatedMotor {
 		motorCommand.send(id, IS_MOVING);
 		try {
 			isMoving = motorCommand.getBool();
-			RConsole.println("isMoving=" + isMoving);
+			RConsole.println("isMoving=" + String.valueOf(isMoving));
 		} catch (IOException e) {
 			// TODO Auto-generated catch block
 			e.printStackTrace();
diff --git a/src/hardwareAbstraction/NXTRemoteUltrasonicPoller.java b/src/hardwareAbstraction/NXTRemoteUltrasonicPoller.java
index 72eb869..51ded7e 100644
--- a/src/hardwareAbstraction/NXTRemoteUltrasonicPoller.java
+++ b/src/hardwareAbstraction/NXTRemoteUltrasonicPoller.java
@@ -36,11 +36,12 @@ public class NXTRemoteUltrasonicPoller implements RemoteCommands, UltrasonicPoll
 	@Override
 	public boolean isSetup() {
 		boolean setup = false;
-		RConsole.println("reset USP");
+		RConsole.println("is Setup");
 		sensorCommand.send(id, IS_SETUP);
 		try {
 			setup = sensorCommand.getBool();
 		} catch (IOException e) {
+			System.out.println("Recieve Error");
 			//no exception expected here. 
 		}
 		return setup;
@@ -63,7 +64,7 @@ public class NXTRemoteUltrasonicPoller implements RemoteCommands, UltrasonicPoll
 
 
 	@Override
-	public int getLowestReading() {
+/*	public int getLowestReading() {
 		int reading = -1;
 		RConsole.println("getLowestReading from USP");
 		sensorCommand.send(id, GET_LOWEST_READING);
@@ -74,7 +75,21 @@ public class NXTRemoteUltrasonicPoller implements RemoteCommands, UltrasonicPoll
 		}
 		return reading;	
 	}
-
+*/
+	public int getLowestReading() {
+		int left = getUSReading(0);
+		int center = getUSReading(1);
+		int right = getUSReading(2);
+		
+		if(left <= center && left <= right) {
+			return left;
+		} else if (center <= right) {
+			return center;
+		} else {
+			return right;
+		}
+		
+	}
 
 	@Override
 	public USPosition getLowestSensor() {

commit 51e311313650fa44ebc6e280cc41361f510afcbe
Author: RileyvanRyswyk <rileyvan@gmail.com>
Date:   Sat Nov 23 15:24:38 2013 -0500

    Removed LCD ultrasonic printout

diff --git a/src/hardwareAbstraction/NXTRemoteUltrasonicPoller.java b/src/hardwareAbstraction/NXTRemoteUltrasonicPoller.java
index 4829665..72eb869 100644
--- a/src/hardwareAbstraction/NXTRemoteUltrasonicPoller.java
+++ b/src/hardwareAbstraction/NXTRemoteUltrasonicPoller.java
@@ -49,14 +49,16 @@ public class NXTRemoteUltrasonicPoller implements RemoteCommands, UltrasonicPoll
 	@Override
 	public int getUSReading(int sensor) {
 		int reading = -1;
-		RConsole.println("getUSReading from USP");
+		
 		sensorCommand.send(id, GET_US_READING, sensor);
 		try {
 			reading = sensorCommand.getInt();
 		} catch (IOException e) {
 			//no exception expected here. 
 		}
+		RConsole.println("Reading" + String.valueOf(reading));
 		return reading;	
+		
 	}
 
 
diff --git a/src/launcher/Launcher.java b/src/launcher/Launcher.java
index cda735b..19335bd 100644
--- a/src/launcher/Launcher.java
+++ b/src/launcher/Launcher.java
@@ -36,7 +36,7 @@ public class Launcher {
 	 * @param args
 	 */
 	public static void main(String[] args) {
-		//RConsole.openUSB(20000);
+		//RConsole.openBluetooth(20000);
 		
 		Manager manager = new Manager();
 		Button.waitForPress();
@@ -121,8 +121,8 @@ public class Launcher {
 		
 //		manager.sm.odoCorrection.start();
 		//manager.hm.ultrasonicPoller.start();
-		manager.sm.nav.start();
-		manager.sm.nav.turnToComplete(0);
+		//manager.sm.nav.start();
+		//manager.sm.nav.turnToComplete(0);
 		
 		
 		//manager.cm.setState(State.SEARCH);
diff --git a/src/services/LCDInfo.java b/src/services/LCDInfo.java
index ff10d62..d045ad5 100644
--- a/src/services/LCDInfo.java
+++ b/src/services/LCDInfo.java
@@ -40,15 +40,15 @@ public class LCDInfo implements TimerListener{
 		LCD.drawInt((int)(pos.y * 10), 3, 1);
 		LCD.drawInt(Angle.radToDeg(pos.theta), 3, 2);
 		
-		LCD.drawString("L: ", 0, 4);
+		/*LCD.drawString("L: ", 0, 4);
 		LCD.drawString("C: ", 0, 5);
 		LCD.drawString("R: ", 0, 6);
 		LCD.drawInt(manager.hm.ultrasonicPoller.getUSReading(0), 3, 4);
 		LCD.drawInt(manager.hm.ultrasonicPoller.getUSReading(1), 3, 5);
 		LCD.drawInt(manager.hm.ultrasonicPoller.getUSReading(2), 3, 6);
-		
-//		LCD.drawString("D: ", 0, 7);
-//		LCD.drawString(String.valueOf(debugValue), 3, 7);
+		*/
+		LCD.drawString("D: ", 0, 7);
+		LCD.drawString(String.valueOf(debugValue), 3, 7);
 		
 		if(!manager.sm.nav.getRoute().empty()) {
 			Point next = manager.sm.nav.getRoute().peek();
diff --git a/src/services/Localization.java b/src/services/Localization.java
index 6ad2ab4..6d01af3 100644
--- a/src/services/Localization.java
+++ b/src/services/Localization.java
@@ -5,6 +5,7 @@ import controllers.State;
 import utilities.*;
 import lejos.nxt.LCD;
 import lejos.nxt.Sound;
+import lejos.nxt.comm.RConsole;
 import lejos.util.Timer;
 import lejos.util.TimerListener;
 import manager.*;
@@ -75,9 +76,6 @@ public class Localization implements TimerListener {
 			return;
 		}
 		
-		LCD.drawString("Initial: ", 0, 4);
-		LCD.drawInt(usReading, 10, 4);
-		
 		angleA = Double.NaN;
 		angleB = Double.NaN;
 		lineDetectedHeadings[3] = Double.NaN;
@@ -129,8 +127,10 @@ public class Localization implements TimerListener {
 			if(rising) {
 				manager.hm.drive.setSpeeds(0, -ROTATION_SPEED);
 				if(distance > THRESHOLD) {
+					
 					Sound.beep();
 					angleA = manager.sm.odo.getTheta();
+					RConsole.println(String.valueOf(angleA));
 					manager.hm.drive.setSpeeds(0, ROTATION_SPEED);
 				}
 			} else {
@@ -139,6 +139,7 @@ public class Localization implements TimerListener {
 					Sound.beep();
 					manager.hm.drive.stop();
 					angleA = manager.sm.odo.getTheta();
+					RConsole.println(String.valueOf(angleA));
 				}
 			}
 		} else {
@@ -146,6 +147,7 @@ public class Localization implements TimerListener {
 			if(distance > THRESHOLD && Math.abs(angleA-manager.sm.odo.getTheta()) > 1) {
 				Sound.beep();
 				angleB = manager.sm.odo.getTheta();
+				RConsole.println(String.valueOf(angleB));
 				updateTheta();
 				manager.hm.drive.setSpeeds(0, 0);
 			}

commit 59a216518b10d18384b92e061761317e687a0b03
Author: RileyvanRyswyk <rileyvan@gmail.com>
Date:   Sat Nov 23 14:44:45 2013 -0500

    For Testing

diff --git a/src/launcher/Launcher.java b/src/launcher/Launcher.java
index d7e7465..cda735b 100644
--- a/src/launcher/Launcher.java
+++ b/src/launcher/Launcher.java
@@ -36,9 +36,8 @@ public class Launcher {
 	 * @param args
 	 */
 	public static void main(String[] args) {
-		RConsole.openUSB(20000);
+		//RConsole.openUSB(20000);
 		
-		Button.waitForPress();
 		Manager manager = new Manager();
 		Button.waitForPress();
 		
@@ -112,18 +111,18 @@ public class Launcher {
 //		}
 		
 		
-		/*manager.sm.localization.start();
+		manager.sm.localization.start();
 		
 		while(manager.cm.getState() == State.LOCALIZING) {
 			manager.um.nap(150);
-		}*/
+		}
 		
 		//sleep(Forklift.setHeight(ForkliftState.SCAN_HEIGHT_LOW));
 		
 //		manager.sm.odoCorrection.start();
 		//manager.hm.ultrasonicPoller.start();
-		//manager.sm.nav.start();
-//		manager.sm.nav.turnToComplete(Math.PI);
+		manager.sm.nav.start();
+		manager.sm.nav.turnToComplete(0);
 		
 		
 		//manager.cm.setState(State.SEARCH);
diff --git a/src/manager/Manager.java b/src/manager/Manager.java
index 9cfeb8b..1d92dc5 100644
--- a/src/manager/Manager.java
+++ b/src/manager/Manager.java
@@ -22,6 +22,7 @@ public class Manager {
 		
 		//Start Services
 		this.sm.start();
+		this.hm.ultrasonicPoller.start();
 		
 	}
 }
diff --git a/src/services/LCDInfo.java b/src/services/LCDInfo.java
index 1404288..ff10d62 100644
--- a/src/services/LCDInfo.java
+++ b/src/services/LCDInfo.java
@@ -47,8 +47,8 @@ public class LCDInfo implements TimerListener{
 		LCD.drawInt(manager.hm.ultrasonicPoller.getUSReading(1), 3, 5);
 		LCD.drawInt(manager.hm.ultrasonicPoller.getUSReading(2), 3, 6);
 		
-		LCD.drawString("D: ", 0, 7);
-		LCD.drawString(String.valueOf(debugValue), 3, 7);
+//		LCD.drawString("D: ", 0, 7);
+//		LCD.drawString(String.valueOf(debugValue), 3, 7);
 		
 		if(!manager.sm.nav.getRoute().empty()) {
 			Point next = manager.sm.nav.getRoute().peek();
diff --git a/src/utilities/Settings.java b/src/utilities/Settings.java
index 78d4301..62ffc2a 100644
--- a/src/utilities/Settings.java
+++ b/src/utilities/Settings.java
@@ -35,7 +35,7 @@ public class Settings {
 	public static int role;
 	public static Point[] redZoneCoords;
 	public static Point[] greenZoneCoords = new Point[2]; //TODO remove once BT is working.
-	public static StartingCorner startingCorner = StartingCorner.BOTTOM_LEFT;
+	public static StartingCorner startingCorner = StartingCorner.BOTTOM_RIGHT;
 	
 	public static final double LS_OFFSET = 15.0;
 	public static final double LS_WIDTH = 11.5;

commit 8e00c3d7696e61060b165d0fc5baae1a43838463
Author: RileyvanRyswyk <rileyvan@gmail.com>
Date:   Sat Nov 23 14:34:55 2013 -0500

    Comment Fix

diff --git a/src/services/Localization.java b/src/services/Localization.java
index 90066ed..6ad2ab4 100644
--- a/src/services/Localization.java
+++ b/src/services/Localization.java
@@ -51,7 +51,7 @@ public class Localization implements TimerListener {
 		//Retrieves center Ultrasonic reading
 		int usReading = updateUltrasonic();
 		
-		//Currently facing a wall, use rising edge detection for both angles
+		//Ultrasonic poller no yet ready
 		if(usReading < 4) {
 			manager.um.nap(120);
 			start();

commit 54c45b9a390f8f99101ac93789b3836deab61996
Author: RileyvanRyswyk <rileyvan@gmail.com>
Date:   Sat Nov 23 14:34:42 2013 -0500

    Integrating the new communicator into Manager

diff --git a/src/launcher/Launcher.java b/src/launcher/Launcher.java
index fb1eef1..d7e7465 100644
--- a/src/launcher/Launcher.java
+++ b/src/launcher/Launcher.java
@@ -38,24 +38,57 @@ public class Launcher {
 	public static void main(String[] args) {
 		RConsole.openUSB(20000);
 		
-		
-		//Manager manager = new Manager();
+		Button.waitForPress();
+		Manager manager = new Manager();
 		Button.waitForPress();
 		
 		
-		Communicator com = new Communicator("NXT");
+		//Communicator com = new Communicator("NXT");
 		
-		NXTRemoteCommand command = new NXTRemoteCommand(com);
+		//NXTRemoteCommand command = new NXTRemoteCommand(com);
 		
 //		NXTRemoteMotor clawMotor = new NXTRemoteMotor(command, 1);
 //		NXTRemoteMotor ultrasonicMotor = new NXTRemoteMotor(command, 2);
 //		NXTRemoteMotor liftMotor = new NXTRemoteMotor(command, 3);
 		
-		NXTRemoteUltrasonicPoller usp = new NXTRemoteUltrasonicPoller(command, 4);
+		//NXTRemoteUltrasonicPoller usp = new NXTRemoteUltrasonicPoller(command, 4);
+		/*NXTRemoteUltrasonicPoller usp = manager.hm.ultrasonicPoller;
 		usp.start();
+		
+		int l;
+		int r;
+		int c;
+		
+		sleep(1000);
+		c = usp.getUSReading(1);
+		r = usp.getUSReading(2);
+		l = usp.getUSReading(0);
+		
+		RConsole.print("C:" + c);
+		RConsole.print("L:" + l);
+		RConsole.print("R:" + r);
+		
+		usp.pingSequential();
+		sleep(1000);
+		c = usp.getUSReading(1);
+		r = usp.getUSReading(2);
+		l = usp.getUSReading(0);
+		
+		RConsole.print("C:" + c);
+		RConsole.print("L:" + l);
+		RConsole.print("R:" + r);
+		
+		usp.pingAll();
 		sleep(1000);
-		RConsole.print("reading:" + usp.getUSReading(1));
-		//usp.stop();
+		c = usp.getUSReading(1);
+		r = usp.getUSReading(2);
+		l = usp.getUSReading(0);
+		
+		RConsole.print("C:" + c);
+		RConsole.print("L:" + l);
+		RConsole.print("R:" + r);
+		
+		usp.stop();*/
 		
 //		ultrasonicMotor.setAcceleration(100);
 //		ultrasonicMotor.setSpeed(100);
diff --git a/src/manager/HardwareManager.java b/src/manager/HardwareManager.java
index b394455..af866c7 100644
--- a/src/manager/HardwareManager.java
+++ b/src/manager/HardwareManager.java
@@ -1,5 +1,6 @@
 package manager;
 
+import lejos.nxt.comm.RConsole;
 import controllers.State;
 import hardwareAbstraction.*;
 
@@ -12,17 +13,25 @@ public class HardwareManager {
 	public UltrasonicMotor ultrasonicMotor;
 	public ColorPoller colorPoller;
 	public LinePoller linePoller;
-	public UltrasonicPoller ultrasonicPoller;	
+	public NXTRemoteUltrasonicPoller ultrasonicPoller;
 	
 	public HardwareManager(Manager manager) {
 		this.manager = manager;
+		
 		this.drive = new Drive();
+	
 		this.forklift = new Forklift();
+	
 		this.claw = new Claw();
+	
 		this.ultrasonicMotor = new UltrasonicMotor();
+
 		this.colorPoller = new ColorPoller();
+
 		this.linePoller = new LinePoller();
-		this.ultrasonicPoller = new UltrasonicPoller(manager);
+
+		this.ultrasonicPoller = new NXTRemoteUltrasonicPoller(manager.um.command, 4);
+
 	}
 	
 	public void reset() {
diff --git a/src/manager/UtilityManager.java b/src/manager/UtilityManager.java
index 59339bd..53aaf0c 100644
--- a/src/manager/UtilityManager.java
+++ b/src/manager/UtilityManager.java
@@ -1,5 +1,8 @@
 package manager;
 
+import lejos.nxt.comm.RConsole;
+import hardwareAbstraction.NXTRemoteCommand;
+import hardwareAbstraction.NXTRemoteMotor;
 import utilities.*;
 
 public class UtilityManager {
@@ -7,6 +10,7 @@ public class UtilityManager {
 	public Manager manager;
 	public Communicator comLink; 
 	public Map map;
+	public NXTRemoteCommand command;
 	
 	
 	public UtilityManager(Manager manager) {
@@ -14,6 +18,12 @@ public class UtilityManager {
 		
 		//BluetoothTransmission.getBluetoothData();
 		this.comLink = new Communicator(Settings.NXTSlaveName);
+		this.command = new NXTRemoteCommand(comLink);
+		
+		Settings.clawMotor = new NXTRemoteMotor(command, Settings.CLAW_MOTOR_ID);
+		Settings.liftMotor = new NXTRemoteMotor(command, Settings.LIFT_MOTOR_ID);
+		Settings.ultrasonicMotor = new NXTRemoteMotor(command, Settings.ULTRASONIC_MOTOR_ID);
+		
 		this.map = new Map();
 	}
 	
diff --git a/src/slave/NXTRemoteControl.java b/src/slave/NXTRemoteControl.java
index d2ca65d..eba3136 100644
--- a/src/slave/NXTRemoteControl.java
+++ b/src/slave/NXTRemoteControl.java
@@ -71,11 +71,11 @@ public class NXTRemoteControl extends Thread implements RemoteCommands, Regulate
 
    }
    
-   public NXTRemoteControl(MotorPort portA, MotorPort portB, MotorPort portC, RemoteUltrasonicPoller usp) {
+   public NXTRemoteControl(MotorPort portA, MotorPort portB, MotorPort portC, RemoteUltrasonicPoller usPoller) {
 	   A = new NXTRegulatedMotor(portA);
        B = new NXTRegulatedMotor(portB);
        C = new NXTRegulatedMotor(portC);
-       this.usp = usp;
+       usp = usPoller;
    }
 
    protected void executeMotorCommand(int id, int command) throws IOException {
@@ -300,6 +300,12 @@ public class NXTRemoteControl extends Thread implements RemoteCommands, Regulate
 				usp.setUSPState(USPState.PING_ALL);
 				break;
 			}
+			case PING_SEQUENTIAL: {
+				RConsole.println("PING_SEQUENTIAL");
+				usp.setUSPState(USPState.PING_SEQUENTIAL);
+				break;
+			}
+			
 		}
    }
 
diff --git a/src/slave/RemoteUltrasonicPoller.java b/src/slave/RemoteUltrasonicPoller.java
index 7d915ad..789f5ed 100644
--- a/src/slave/RemoteUltrasonicPoller.java
+++ b/src/slave/RemoteUltrasonicPoller.java
@@ -53,7 +53,7 @@ public class RemoteUltrasonicPoller implements TimerListener {
 		us[center] = new UltrasonicSensor(SensorPort.S1);
 		us[right] = new UltrasonicSensor(SensorPort.S2);
 
-		this.pollRate = 100;
+		this.pollRate = 20;
 		this.readings = new int[3][5];
 
 		us[left].off();
@@ -69,6 +69,7 @@ public class RemoteUltrasonicPoller implements TimerListener {
 	
 	public void setUSPState(USPState state) {
 		this.state = state;
+		resetUSP();
 	}
 
 	/**
@@ -90,11 +91,11 @@ public class RemoteUltrasonicPoller implements TimerListener {
 		} else if(state == USPState.PING_SEQUENTIAL) {
 			switch(counter) {
 			case 0 : leftUS.run();
-			break;
+					 break;
 			case 1 : centerUS.run();
-			break;
+					 break;
 			case 2 : rightUS.run();
-			break;
+					 break;
 			}
 			counter += 1;
 			counter = counter % 3;
diff --git a/src/slave/Responder.java b/src/slave/Responder.java
index 4fdaac8..2a6d6af 100644
--- a/src/slave/Responder.java
+++ b/src/slave/Responder.java
@@ -48,7 +48,7 @@ public class Responder {
 	
 	public static void main(String[] args) throws Exception {
 		
-		RConsole.openUSB(20000);
+		//RConsole.openUSB(20000);
 		LCD.drawString("Connecting", 1, 1);
 		//ResponderTool resp = new ResponderTool(RS485.getConnector());
 		//resp.start();
diff --git a/src/utilities/Settings.java b/src/utilities/Settings.java
index ecb6085..78d4301 100644
--- a/src/utilities/Settings.java
+++ b/src/utilities/Settings.java
@@ -9,10 +9,6 @@ import lejos.nxt.SensorPort;
 import lejos.nxt.UltrasonicSensor;
 
 public class Settings {
-
-	private static Communicator com = new Communicator("NXT");
-	
-	private static NXTRemoteCommand motorCommand = new NXTRemoteCommand(com);
 	
 	public static ColorSensor frontColorSensor = new ColorSensor(SensorPort.S1);
 	public static ColorSensor rearLeftColorSensor = new ColorSensor(SensorPort.S2);
@@ -25,9 +21,14 @@ public class Settings {
 	public static NXTRegulatedMotor leftDriveMotor = Motor.B;
 	public static NXTRegulatedMotor rightDriveMotor = Motor.A;
 	
-	public static NXTRemoteMotor clawMotor = new NXTRemoteMotor(motorCommand, 1);
-	public static NXTRemoteMotor ultrasonicMotor = new NXTRemoteMotor(motorCommand, 2);
-	public static NXTRemoteMotor liftMotor = new NXTRemoteMotor(motorCommand, 3);
+	public static final int CLAW_MOTOR_ID = 1;
+	public static final int ULTRASONIC_MOTOR_ID = 2;
+	public static final int LIFT_MOTOR_ID = 3;
+	
+	
+	public static NXTRemoteMotor clawMotor;
+	public static NXTRemoteMotor ultrasonicMotor;
+	public static NXTRemoteMotor liftMotor;
 	
 	public static final String NXTSlaveName = "NXT";
 	

commit 3e38b3d00f30acc8652d6d9a902309c6fd3aef5b
Author: RileyvanRyswyk <rileyvan@gmail.com>
Date:   Sat Nov 23 12:23:25 2013 -0500

    Ultrasonic Poller now seems to be working.  Will make sure everything we need works.

diff --git a/src/launcher/Launcher.java b/src/launcher/Launcher.java
index 56bbd30..fb1eef1 100644
--- a/src/launcher/Launcher.java
+++ b/src/launcher/Launcher.java
@@ -8,9 +8,9 @@ import hardwareAbstraction.Forklift;
 import hardwareAbstraction.Forklift.ForkliftState;
 import hardwareAbstraction.NXTRemoteCommand;
 import hardwareAbstraction.NXTRemoteMotor;
-import hardwareAbstraction.NXTRemoteUltrasonicPoller;
 import hardwareAbstraction.UltrasonicMotor;
 import hardwareAbstraction.UltrasonicPoller;
+import hardwareAbstraction.NXTRemoteUltrasonicPoller;
 import utilities.Communicator;
 import utilities.Point;
 import controllers.State;
@@ -53,14 +53,9 @@ public class Launcher {
 		
 		NXTRemoteUltrasonicPoller usp = new NXTRemoteUltrasonicPoller(command, 4);
 		usp.start();
-		try {
-			Thread.sleep(100);
-		} catch (InterruptedException e) {
-			// TODO Auto-generated catch block
-			e.printStackTrace();
-		}
+		sleep(1000);
 		RConsole.print("reading:" + usp.getUSReading(1));
-		usp.stop();
+		//usp.stop();
 		
 //		ultrasonicMotor.setAcceleration(100);
 //		ultrasonicMotor.setSpeed(100);
diff --git a/src/slave/NXTRemoteControl.java b/src/slave/NXTRemoteControl.java
index f843efd..d2ca65d 100644
--- a/src/slave/NXTRemoteControl.java
+++ b/src/slave/NXTRemoteControl.java
@@ -41,6 +41,9 @@ public class NXTRemoteControl extends Thread implements RemoteCommands, Regulate
    private int acceleration;
    private int angle;
    private boolean immediateReturn, isStalled;
+   
+   //Ultrasonic Var
+   private boolean isSetup = false;
 
    private static NXTRegulatedMotor A = null;
    private static NXTRegulatedMotor B = null;
@@ -72,62 +75,14 @@ public class NXTRemoteControl extends Thread implements RemoteCommands, Regulate
 	   A = new NXTRegulatedMotor(portA);
        B = new NXTRegulatedMotor(portB);
        C = new NXTRegulatedMotor(portC);
-       usp = new RemoteUltrasonicPoller();
+       this.usp = usp;
    }
 
-   protected void executeCommand(int id, int command) throws IOException {
+   protected void executeMotorCommand(int id, int command) throws IOException {
 
 		NXTRegulatedMotor motor = getMotor(id);
-		RemoteUltrasonicPoller usp = getSensor(id);
 		
-		if (usp != null) {
-			switch (command) {
-			case START_USP: {
-				RConsole.println("START_USP");
-				usp.start();
-			}
-			case STOP_USP: {
-				RConsole.println("STOP_USP");
-				usp.stop();
-			}
-			case RESET_USP: {
-				RConsole.println("RESET_USP");
-				usp.resetUSP();
-			}
-			case IS_SETUP: {
-				RConsole.println("IS_SETUP");
-				usp.isSetup();
-			}
-			case GET_US_READING: {
-				RConsole.println("GET_US_READING");
-				int sensor = dis.readInt();
-				RConsole.println("sensor= " + sensor);
-				usp.getUSReading(sensor);
-			}
-			case GET_LOWEST_READING: {
-				RConsole.println("GET_LOWEST_READING");
-				usp.getLowestReading();
-			}
-			case PING_CENTER: {
-				RConsole.println("PING_CENTER");
-				usp.setUSPState(USPState.PING_CENTER);
-			}
-			case PING_LEFT: {
-				RConsole.println("PING_LEFT");
-				usp.setUSPState(USPState.PING_LEFT);
-			}
-			case PING_RIGHT: {
-				RConsole.println("PING_RIGHT");
-				usp.setUSPState(USPState.PING_RIGHT);
-			}
-			case PING_ALL: {
-				RConsole.println("PING_ALL");
-				usp.setUSPState(USPState.PING_ALL);
-			}
-			}
-		}
-		else {
-			switch (command) {
+		switch (command) {
 
 			case FORWARD: {
 				RConsole.println("FORWARD");
@@ -281,10 +236,72 @@ public class NXTRemoteControl extends Thread implements RemoteCommands, Regulate
 				break;
 
 			}
-			}
 		}
 
    }
+   
+   protected void executeSensorCommand(int id, int command) throws IOException {
+
+		switch (command) {
+			case START_USP: {
+				RConsole.println("START_USP");
+				usp.start();
+				break;
+			}
+			case STOP_USP: {
+				RConsole.println("STOP_USP");
+				usp.stop();
+				break;
+			}
+			case RESET_USP: {
+				RConsole.println("RESET_USP");
+				usp.resetUSP();
+				break;
+			}
+			case IS_SETUP: {
+				RConsole.println("IS_SETUP");
+				isSetup = usp.isSetup();
+				dos.writeBoolean(isSetup);
+				dos.flush();
+				break;
+			}
+			case GET_US_READING: {
+				RConsole.println("GET_US_READING");
+				int sensor = dis.readInt();
+				RConsole.println("sensor= " + sensor);
+				int reading = usp.getUSReading(sensor);
+				RConsole.println("value= " + String.valueOf(reading));
+				dos.writeInt(reading);
+				dos.flush();
+				break;
+			}
+			case GET_LOWEST_READING: {
+				RConsole.println("GET_LOWEST_READING");
+				usp.getLowestReading();
+				break;
+			}
+			case PING_CENTER: {
+				RConsole.println("PING_CENTER");
+				usp.setUSPState(USPState.PING_CENTER);
+				break;
+			}
+			case PING_LEFT: {
+				RConsole.println("PING_LEFT");
+				usp.setUSPState(USPState.PING_LEFT);
+				break;
+			}
+			case PING_RIGHT: {
+				RConsole.println("PING_RIGHT");
+				usp.setUSPState(USPState.PING_RIGHT);
+				break;
+			}
+			case PING_ALL: {
+				RConsole.println("PING_ALL");
+				usp.setUSPState(USPState.PING_ALL);
+				break;
+			}
+		}
+   }
 
    protected RemoteUltrasonicPoller getSensor(int id) {
 
@@ -345,7 +362,11 @@ public class NXTRemoteControl extends Thread implements RemoteCommands, Regulate
             id = dis.readInt();
             command = dis.readInt();
             RConsole.println("id="+id +"command =" +command);
-            executeCommand(id, command);
+            if(id > 3) {
+            	executeSensorCommand(id, command);
+            } else {
+            	executeMotorCommand(id, command);
+            }
 
          } catch (IOException e) {
          //A.stop();
diff --git a/src/slave/RemoteUltrasonicPoller.java b/src/slave/RemoteUltrasonicPoller.java
index 990c6a3..7d915ad 100644
--- a/src/slave/RemoteUltrasonicPoller.java
+++ b/src/slave/RemoteUltrasonicPoller.java
@@ -64,9 +64,7 @@ public class RemoteUltrasonicPoller implements TimerListener {
 		this.centerUS = new Thread(new CenterUS());
 		this.rightUS = new Thread(new RightUS());
 		
-		this.state = USPState.PING_ALL;
-		
-		this.start();
+		this.state = USPState.PING_CENTER;
 	}
 	
 	public void setUSPState(USPState state) {
diff --git a/src/slave/Responder.java b/src/slave/Responder.java
index 49d676d..4fdaac8 100644
--- a/src/slave/Responder.java
+++ b/src/slave/Responder.java
@@ -47,7 +47,8 @@ public class Responder {
 	 */
 	
 	public static void main(String[] args) throws Exception {
-		//RConsole.openUSB(20000);
+		
+		RConsole.openUSB(20000);
 		LCD.drawString("Connecting", 1, 1);
 		//ResponderTool resp = new ResponderTool(RS485.getConnector());
 		//resp.start();

commit 2225298191e9c72b6edde73614283d3e3bc21dc2
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Sat Nov 23 01:58:51 2013 -0500

    Wrote up the code to perform ultrasonic poller on the external NXT.
    Throws an exception 31 for the moment. Will be debugged tomorrow.

diff --git a/src/hardwareAbstraction/NXTRemoteUltrasonicPoller.java b/src/hardwareAbstraction/NXTRemoteUltrasonicPoller.java
index 3080b92..4829665 100644
--- a/src/hardwareAbstraction/NXTRemoteUltrasonicPoller.java
+++ b/src/hardwareAbstraction/NXTRemoteUltrasonicPoller.java
@@ -1,5 +1,133 @@
 package hardwareAbstraction;
 
-public class NXTRemoteUltrasonicPoller {
+import java.io.IOException;
 
+import lejos.nxt.comm.RConsole;
+
+public class NXTRemoteUltrasonicPoller implements RemoteCommands, UltrasonicPoller {
+	private int id;
+	private NXTRemoteCommand sensorCommand;
+	
+	public NXTRemoteUltrasonicPoller(NXTRemoteCommand nxtCommand, int id) {
+		this.id = id;
+		this.sensorCommand = nxtCommand;
+	}
+	
+
+	@Override
+	public void start() {
+		RConsole.println("start USP");
+		sensorCommand.send(id, START_USP);
+	}
+	
+	@Override
+	public void stop() {
+		RConsole.println("stop USP");
+		sensorCommand.send(id, STOP_USP);
+	}
+	
+	@Override
+	public void resetUSP() {
+		RConsole.println("reset USP");
+		sensorCommand.send(id, RESET_USP);
+	}
+
+
+	@Override
+	public boolean isSetup() {
+		boolean setup = false;
+		RConsole.println("reset USP");
+		sensorCommand.send(id, IS_SETUP);
+		try {
+			setup = sensorCommand.getBool();
+		} catch (IOException e) {
+			//no exception expected here. 
+		}
+		return setup;
+	}
+
+	@Override
+	public int getUSReading(int sensor) {
+		int reading = -1;
+		RConsole.println("getUSReading from USP");
+		sensorCommand.send(id, GET_US_READING, sensor);
+		try {
+			reading = sensorCommand.getInt();
+		} catch (IOException e) {
+			//no exception expected here. 
+		}
+		return reading;	
+	}
+
+
+	@Override
+	public int getLowestReading() {
+		int reading = -1;
+		RConsole.println("getLowestReading from USP");
+		sensorCommand.send(id, GET_LOWEST_READING);
+		try {
+			reading = sensorCommand.getInt();
+		} catch (IOException e) {
+			//no exception expected here. 
+		}
+		return reading;	
+	}
+
+
+	@Override
+	public USPosition getLowestSensor() {
+		int reading = -1;
+		RConsole.println("getLowestReading from USP");
+		sensorCommand.send(id, GET_LOWEST_READING);
+		try {
+			reading = sensorCommand.getInt();
+		} catch (IOException e) {
+			//no exception expected here. 
+		}
+		USPosition usPos = null;
+		switch(reading) {
+		case left : usPos = USPosition.LEFT;
+		break;
+		case center : usPos =  USPosition.CENTER;
+		break;
+		case right : usPos = USPosition.RIGHT;
+		break;
+		}
+		return usPos;
+	}
+
+
+	@Override
+	public void pingLeft() {
+		RConsole.println("ping left USP");
+		sensorCommand.send(id, PING_LEFT);
+	}
+
+
+	@Override
+	public void pingRight() {
+		RConsole.println("ping right USP");
+		sensorCommand.send(id, PING_RIGHT);
+	}
+
+
+	@Override
+	public void pingCenter() {
+		RConsole.println("ping center USP");
+		sensorCommand.send(id, PING_CENTER);
+	}
+
+
+	@Override
+	public void pingAll() {
+		RConsole.println("ping all USP");
+		sensorCommand.send(id, PING_ALL);
+	}
+
+
+	@Override
+	public void pingSequential() {
+		RConsole.println("ping sequential USP");
+		sensorCommand.send(id, PING_SEQUENTIAL);
+	}
 }
diff --git a/src/hardwareAbstraction/RemoteCommands.java b/src/hardwareAbstraction/RemoteCommands.java
index 97aabb2..f86fcf9 100644
--- a/src/hardwareAbstraction/RemoteCommands.java
+++ b/src/hardwareAbstraction/RemoteCommands.java
@@ -11,32 +11,40 @@ package hardwareAbstraction;
  */
 
 public interface RemoteCommands {
-	  public static final int FORWARD = 0;
-	  public static final int BACKWARD = 1;
-	  public static final int ROTATE = 2;
-	  public static final int STOP = 3;
-	  public static final int ROTATE_TO = 4;
-	  public static final int FLT = 5;
-	  public static final int GET_TACHO_COUNT = 6;
-	  public static final int IS_MOVING = 7;
-	  public static final int SET_SPEED = 8;
-	  public static final int SET_ACCELERATION = 9;
-	  public static final int GET_ACCELERETION = 10;
-	  public static final int GET_LIMIT_ANGLE = 11;
-	  public static final int RESET_TACHO_COUNT = 12;
-	  public static final int GET_SPEED = 13;
-	  public static final int IS_STALLED = 14;
-	  public static final int GET_ROTATION_SPEED= 15;
-	  public static final int GET_MAX_SPEED= 16;
-	  public static final int SUSPEND_REGULATION= 17;
-	  public static final int ADD_LISTENER= 18;
-	  public static final int ROTATION_STARTED= 19;
-	  public static final int ROTATION_STOPPED= 20;
-	  
-	  
-	  //ultrasonic commands
-	  public static final int PING_CENTER = 21;
-	  public static final int PING_LEFT = 22;
-	  public static final int PING_RIGHT = 23;
-	  public static final int PING_ALL = 24;
+	// motor commands
+	public static final int FORWARD = 0;
+	public static final int BACKWARD = 1;
+	public static final int ROTATE = 2;
+	public static final int STOP = 3;
+	public static final int ROTATE_TO = 4;
+	public static final int FLT = 5;
+	public static final int GET_TACHO_COUNT = 6;
+	public static final int IS_MOVING = 7;
+	public static final int SET_SPEED = 8;
+	public static final int SET_ACCELERATION = 9;
+	public static final int GET_ACCELERETION = 10;
+	public static final int GET_LIMIT_ANGLE = 11;
+	public static final int RESET_TACHO_COUNT = 12;
+	public static final int GET_SPEED = 13;
+	public static final int IS_STALLED = 14;
+	public static final int GET_ROTATION_SPEED = 15;
+	public static final int GET_MAX_SPEED = 16;
+	public static final int SUSPEND_REGULATION = 17;
+	public static final int ADD_LISTENER = 18;
+	public static final int ROTATION_STARTED = 19;
+	public static final int ROTATION_STOPPED = 20;
+
+	// ultrasonic commands
+	public static final int START_USP = 50;
+	public static final int STOP_USP = 51;
+	public static final int RESET_USP = 52;
+	public static final int IS_SETUP = 53;
+	public static final int GET_US_READING = 54;
+	public static final int GET_LOWEST_READING = 55;
+	public static final int GET_LOWEST_SENSOR = 56;
+	public static final int PING_CENTER = 57;
+	public static final int PING_LEFT = 58;
+	public static final int PING_RIGHT = 59;
+	public static final int PING_ALL = 60;
+	public static final int PING_SEQUENTIAL = 61;
 }
diff --git a/src/hardwareAbstraction/UltrasonicPoller.java b/src/hardwareAbstraction/UltrasonicPoller.java
index fa9709a..d4f0245 100644
--- a/src/hardwareAbstraction/UltrasonicPoller.java
+++ b/src/hardwareAbstraction/UltrasonicPoller.java
@@ -1,123 +1,25 @@
 package hardwareAbstraction;
 
-import controllers.State;
-import utilities.Settings;
-import lejos.nxt.LCD;
-import lejos.nxt.UltrasonicSensor;
-import lejos.nxt.comm.RConsole;
-import lejos.util.Timer;
-import lejos.util.TimerListener;
-import manager.Manager;
-
 /**
  * This class serves as a higher level abstraction of a ultrasonic sensor. It is
  * wrapped in a poller class which will now handle the returned values and the
- * polling of that sensor
+ * polling of that sensor. The ultrasonic sensors are assumed on the slave brick. 
  * <p>
  * 
  * @author danielle, Riley
- * @deprecated Not used anymore. Will have its own implementation in the slaveNXT. 
  */
-public class UltrasonicPoller implements TimerListener {
-	private UltrasonicSensor[] us = new UltrasonicSensor[3];
-	public int pollRate;
-	private Timer poller;
-	private int readings[][];
-	private boolean running = false;
-	
-	private int left = 0;
-	private int center = 1;
-	private int right = 2;
-	private int counter;
-
-	private Thread leftUS;
-	private Thread centerUS;
-	private Thread rightUS;
-	
-	private Manager manager;
-
-	// TODO figure out what exactly this constructor should be.
-	public UltrasonicPoller(Manager manager) {
-		us[left] = Settings.leftUltrasonic;
-		us[center] = Settings.centerUltrasonic;
-		us[right] = Settings.rightUltrasonic;
-
-		this.pollRate = 100;
-		this.readings = new int[3][5];
-
-		us[left].off();
-		us[center].off();
-		us[right].off();
-
-		this.leftUS = new Thread(new LeftUS());
-		this.centerUS = new Thread(new CenterUS());
-		this.rightUS = new Thread(new RightUS());
-
-		this.manager = manager;
-		
-		this.start();
-	}
-
-	/**
-	 * Pings all three ultrasonic sensors and gets their values. Puts them into
-	 * the readings array
-	 */
-	@Override
-	public void timedOut() {
-		
-		/*
-		 * Ensures minimal lag for ultrasonic localization 
-		 */
-		if(manager.cm.getState() != State.LOCALIZING) {
-		
-			/*
-			 * If the ultrasonics are facing forward, poll only one at a time.
-			 * Else poll them all simultaneously. 
-			 */
-			if(UltrasonicMotor.isForward) {
-				switch(counter) {
-				case 0 : leftUS.run();
-				break;
-				case 1 : centerUS.run();
-				break;
-				case 2 : rightUS.run();
-				break;
-				}
-				counter += 1;
-				counter = counter % 3;
-			}
-			else {
-				leftUS.run();
-				centerUS.run();
-				rightUS.run();
-				RConsole.println(toStringLastValues());
-			}
-		} else {
-			centerUS.run();
-		}
-	}
-
-	// For debugging purposes.
-	private String toStringLastValues() {
-		String out = "";
-		out += " L: " + getUSReading(left);
-		out += " C: " + getUSReading(center);
-		out += " R: " + getUSReading(right);
-		return out;
-	}
+public interface UltrasonicPoller {
+	public int pollRate = 100;
+	public boolean running = false;
+	public int left = 0;
+	public int center = 1;
+	public int right = 2;
 
 	/**
 	 * Starts this instance of the ultrasonic poller Stop must be called to stop
 	 * the reading again.
 	 */
-	public void start() {
-		counter = 0;
-
-		// for filtering purposes
-		this.poller = new Timer(pollRate, this);
-		this.poller.start();
-		running = true;
-	}
+	public void start();
 
 	/**
 	 * Resets the ultrasonic sensor values to the default -1 values. The
@@ -126,37 +28,29 @@ public class UltrasonicPoller implements TimerListener {
 	 * good data.
 	 * @bug throws null pointer exception. Has potentially been fixed. Needs to be tested.
 	 */
-	public void resetUSP() {
-		this.stop();
-		for (int i = 0; i < readings.length; ++i) {
-			for (int j = 0; j < readings[1].length; ++j) {
-				RConsole.println("" + i + "," + j);
-				readings[i][j] = -1;
-			}
-		}
-		this.start();
-	}
+	public void resetUSP();
 
 	/**
 	 * Checks if the ultrasonic sensor has collected atleast 5 values. It does
 	 * this by checking for any negative numbers in the readings.
 	 */
-	public boolean isSetup() {
-		if (readings[2][4] == -1 || readings[0][4] == -1 || readings[1][4] == -1)
-			return false;
-		else
-			return true;
-	}
+	public boolean isSetup();
 
+	public void pingLeft();
+	
+	public void pingRight();
+	
+	public void pingCenter();
+	
+	public void pingAll();
+	
+	public void pingSequential();
+	
 	/**
 	 * Stops this instance of the ultrasonic poller Start must be called to
 	 * start reading again.
 	 */
-	public void stop() {
-		this.poller.stop();
-		this.poller = null;
-		running = false;
-	}
+	public void stop();
 
 	/**
 	 * Returns the filtered data for the sensor (median filtering)
@@ -164,36 +58,7 @@ public class UltrasonicPoller implements TimerListener {
 	 * @param sensor
 	 * @return
 	 */
-	public int getUSReading(int sensor) {
-
-		// makes sure readings array is full of values so we have enough to
-		// filter with
-		if (readings[sensor][4] > -1) {
-
-			// initialize vars
-			int size = 5;
-			int[] usReadingsSorted = new int[5];
-			// Copy array
-			System.arraycopy(readings[sensor], 0, usReadingsSorted, 0, 5);
-
-			// sort the values: lowest to highest
-			for (int i = 0; i < size; i++) {
-				for (int j = i + 1; j < size; j++) {
-					if (usReadingsSorted[i] > usReadingsSorted[j]) {
-						int temp = usReadingsSorted[i];
-						usReadingsSorted[i] = usReadingsSorted[j];
-						usReadingsSorted[j] = temp;
-					}
-				}
-			}
-
-			// return the median
-			return usReadingsSorted[2];
-
-		} else {
-			return readings[sensor][0];
-		}
-	}
+	public int getUSReading(int sensor);
 
 	/**
 	 * gets the lowest reading in the ultrasonicPoller at that time. Readings
@@ -202,132 +67,13 @@ public class UltrasonicPoller implements TimerListener {
 	 * 
 	 * @return The smallest reading of the last 5 polls.
 	 */
-	public int getLowestReading() {
-		// stop reading if the robot was taking readings.
-		boolean takingReadings = false;
-		if (this.poller != null) {
-			stop();
-			takingReadings = true;
-		}
-
-		// calculate median value by sorting the readings
-		int minValue = readings[0][0]; // get a value to start
-		for (int usReadings[] : readings) {
-			int i = 0;
-			for (int reading : usReadings) {
-				if (minValue > reading && reading != -1)
-					minValue = reading;
-				++i;
-			}
-		}
-
-		// start the readings again if the robot was taking readings before.
-		if (takingReadings)
-			start();
-		return minValue;
-	}
+	public int getLowestReading();
 	
 	/**
 	 * This method gets the number representation of the US with the lowest value out of all the ultrasonic sensor. 
 	 * So if the center has the lowest reading, 
 	 */
-	public USPosition getLowestSensor() {
-		boolean takingReadings = false;
-		if (this.poller != null) {
-			stop();
-			takingReadings = true;
-		}
-
-		// calculate median value by sorting the readings
-		int minValue = readings[0][0]; // get a value to start
-		int sensor = 0;
-		int smallestSensor = 0;
-		for (int usReadings[] : readings) {
-			for (int reading : usReadings) {
-				if (minValue > reading && reading != -1) {
-					minValue = reading;
-					smallestSensor = sensor;
-				}
-			}
-			sensor++;
-		}
-
-		// start the readings again if the robot was taking readings before.
-		if (takingReadings)
-			start();
-		if(smallestSensor == left)
-			return USPosition.LEFT;
-		else if(smallestSensor == center)
-			return USPosition.CENTER;
-		else
-			return USPosition.RIGHT;
-	}
-
-	/**
-	 * Pings ultrasonic sensor and records the result in readings
-	 */
-	private void pingUS(int sensor) {
-		int distance;
-
-		// do a ping
-		us[sensor].ping();
-
-		// wait for the ping to complete
-		try {
-			Thread.sleep(20);
-		} catch (InterruptedException e) {
-		}
-
-		// there will be a delay here
-		distance = us[sensor].getDistance();
-
-		addReading(sensor, distance);
-	}
-
-	// helper method.
-	private void addReading(int sensor, int reading) {
-		readings[sensor][4] = readings[sensor][3];
-		readings[sensor][3] = readings[sensor][2];
-		readings[sensor][2] = readings[sensor][1];
-		readings[sensor][1] = readings[sensor][0];
-		readings[sensor][0] = reading;
-	}
-	
-	/**
-	 * Computes the average values read by a sensor
-	 * @param sensor	The integer value corresponding to the ultrasonic sensor
-	 * @return The average integer value, in integer value.
-	 */
-	public int computeAverage(int sensor) {
-		int sum = 0;
-		for(int i = 0; i < readings[sensor].length; i++)
-			sum += readings[sensor][i];
-		return (sum / readings[sensor].length);
-	}
-
-	public class LeftUS implements Runnable {
-
-		@Override
-		public void run() {
-			pingUS(left);
-		}
-	}
-
-	public class RightUS implements Runnable {
-
-		@Override
-		public void run() {
-			pingUS(right);
-		}
-	}
-
-	public class CenterUS implements Runnable {
-
-		@Override
-		public void run() {
-			pingUS(center);
-		}
-	}
+	public USPosition getLowestSensor();
 	
 	public enum USPosition {
 		LEFT, CENTER, RIGHT
diff --git a/src/launcher/Launcher.java b/src/launcher/Launcher.java
index 3518c13..56bbd30 100644
--- a/src/launcher/Launcher.java
+++ b/src/launcher/Launcher.java
@@ -8,6 +8,7 @@ import hardwareAbstraction.Forklift;
 import hardwareAbstraction.Forklift.ForkliftState;
 import hardwareAbstraction.NXTRemoteCommand;
 import hardwareAbstraction.NXTRemoteMotor;
+import hardwareAbstraction.NXTRemoteUltrasonicPoller;
 import hardwareAbstraction.UltrasonicMotor;
 import hardwareAbstraction.UltrasonicPoller;
 import utilities.Communicator;
@@ -35,7 +36,7 @@ public class Launcher {
 	 * @param args
 	 */
 	public static void main(String[] args) {
-		//RConsole.openUSB(20000);
+		RConsole.openUSB(20000);
 		
 		
 		//Manager manager = new Manager();
@@ -44,32 +45,43 @@ public class Launcher {
 		
 		Communicator com = new Communicator("NXT");
 		
-		NXTRemoteCommand motorCommand = new NXTRemoteCommand(com);
-		
-		NXTRemoteMotor clawMotor = new NXTRemoteMotor(motorCommand, 1);
-		NXTRemoteMotor ultrasonicMotor = new NXTRemoteMotor(motorCommand, 2);
-		NXTRemoteMotor liftMotor = new NXTRemoteMotor(motorCommand, 3);
-		
-		ultrasonicMotor.setAcceleration(100);
-		ultrasonicMotor.setSpeed(100);
-		clawMotor.setAcceleration(100);
-		liftMotor.setAcceleration(100);
-		clawMotor.setSpeed(100);
-		liftMotor.setSpeed(100);
-		
-		
-		for(int i=0; i<10; i++) {
-			
-			if(i % 2 == 0) {
-				ultrasonicMotor.rotateTo(0);
-			} else {
-				ultrasonicMotor.rotateTo(-40);
-			}
-			
-			while(ultrasonicMotor.isMoving()) {
-				sleep(40);
-			}
+		NXTRemoteCommand command = new NXTRemoteCommand(com);
+		
+//		NXTRemoteMotor clawMotor = new NXTRemoteMotor(command, 1);
+//		NXTRemoteMotor ultrasonicMotor = new NXTRemoteMotor(command, 2);
+//		NXTRemoteMotor liftMotor = new NXTRemoteMotor(command, 3);
+		
+		NXTRemoteUltrasonicPoller usp = new NXTRemoteUltrasonicPoller(command, 4);
+		usp.start();
+		try {
+			Thread.sleep(100);
+		} catch (InterruptedException e) {
+			// TODO Auto-generated catch block
+			e.printStackTrace();
 		}
+		RConsole.print("reading:" + usp.getUSReading(1));
+		usp.stop();
+		
+//		ultrasonicMotor.setAcceleration(100);
+//		ultrasonicMotor.setSpeed(100);
+//		clawMotor.setAcceleration(100);
+//		liftMotor.setAcceleration(100);
+//		clawMotor.setSpeed(100);
+//		liftMotor.setSpeed(100);
+//		
+//		
+//		for(int i=0; i<10; i++) {
+//			
+//			if(i % 2 == 0) {
+//				ultrasonicMotor.rotateTo(0);
+//			} else {
+//				ultrasonicMotor.rotateTo(-40);
+//			}
+//			
+//			while(ultrasonicMotor.isMoving()) {
+//				sleep(40);
+//			}
+//		}
 		
 		
 		/*manager.sm.localization.start();
diff --git a/src/slave/NXTRemoteControl.java b/src/slave/NXTRemoteControl.java
index f99edb1..f843efd 100644
--- a/src/slave/NXTRemoteControl.java
+++ b/src/slave/NXTRemoteControl.java
@@ -81,7 +81,33 @@ public class NXTRemoteControl extends Thread implements RemoteCommands, Regulate
 		RemoteUltrasonicPoller usp = getSensor(id);
 		
 		if (usp != null) {
-			switch( command) {
+			switch (command) {
+			case START_USP: {
+				RConsole.println("START_USP");
+				usp.start();
+			}
+			case STOP_USP: {
+				RConsole.println("STOP_USP");
+				usp.stop();
+			}
+			case RESET_USP: {
+				RConsole.println("RESET_USP");
+				usp.resetUSP();
+			}
+			case IS_SETUP: {
+				RConsole.println("IS_SETUP");
+				usp.isSetup();
+			}
+			case GET_US_READING: {
+				RConsole.println("GET_US_READING");
+				int sensor = dis.readInt();
+				RConsole.println("sensor= " + sensor);
+				usp.getUSReading(sensor);
+			}
+			case GET_LOWEST_READING: {
+				RConsole.println("GET_LOWEST_READING");
+				usp.getLowestReading();
+			}
 			case PING_CENTER: {
 				RConsole.println("PING_CENTER");
 				usp.setUSPState(USPState.PING_CENTER);
diff --git a/src/slave/RemoteUltrasonicPoller.java b/src/slave/RemoteUltrasonicPoller.java
index 950964c..990c6a3 100644
--- a/src/slave/RemoteUltrasonicPoller.java
+++ b/src/slave/RemoteUltrasonicPoller.java
@@ -23,27 +23,31 @@ import manager.Manager;
 public class RemoteUltrasonicPoller implements TimerListener {
 	private UltrasonicSensor[] us = new UltrasonicSensor[3];
 	
+	//properties of the USPoller
 	private int pollRate;
 	private Timer poller;
 	private int readings[][];
-	private boolean running = false;
 	
+	//internal designation of the sensors
 	private int left = 0;
 	private int center = 1;
 	private int right = 2;
+	
+	// internal use of a counter for sequential pinging.
 	private int counter;
 
+	// the threads which run the US.
 	private Thread leftUS;
 	private Thread centerUS;
 	private Thread rightUS;
 	
+	// the instruction to the USP.
 	public USPState state;
 	
 	public enum USPState {
-		PING_CENTER, PING_ALL, PING_LEFT, PING_RIGHT;
+		PING_CENTER, PING_ALL, PING_LEFT, PING_RIGHT, PING_SEQUENTIAL;
 	}
 
-	// TODO figure out what exactly this constructor should be.
 	public RemoteUltrasonicPoller() {
 		us[left] = new UltrasonicSensor(SensorPort.S3);
 		us[center] = new UltrasonicSensor(SensorPort.S1);
@@ -79,32 +83,27 @@ public class RemoteUltrasonicPoller implements TimerListener {
 		/*
 		 * Ensures minimal lag for ultrasonic localization 
 		 */
-		if(manager.cm.getState() != State.LOCALIZING) {
-		
-			/*
-			 * If the ultrasonics are facing forward, poll only one at a time.
-			 * Else poll them all simultaneously. 
-			 */
-			if(UltrasonicMotor.isForward) {
-				switch(counter) {
-				case 0 : leftUS.run();
-				break;
-				case 1 : centerUS.run();
-				break;
-				case 2 : rightUS.run();
-				break;
-				}
-				counter += 1;
-				counter = counter % 3;
-			}
-			else {
-				leftUS.run();
-				centerUS.run();
-				rightUS.run();
-				RConsole.println(toStringLastValues());
+		if(state == USPState.PING_CENTER) {
+			centerUS.run();
+		} else if(state == USPState.PING_LEFT) {
+			leftUS.run();
+		} else if(state == USPState.PING_RIGHT) {
+			rightUS.run();
+		} else if(state == USPState.PING_SEQUENTIAL) {
+			switch(counter) {
+			case 0 : leftUS.run();
+			break;
+			case 1 : centerUS.run();
+			break;
+			case 2 : rightUS.run();
+			break;
 			}
-		} else {
+			counter += 1;
+			counter = counter % 3;
+		} else { //if state is PING_ALL
 			centerUS.run();
+			leftUS.run();
+			rightUS.run();
 		}
 	}
 
@@ -123,11 +122,8 @@ public class RemoteUltrasonicPoller implements TimerListener {
 	 */
 	public void start() {
 		counter = 0;
-
-		// for filtering purposes
 		this.poller = new Timer(pollRate, this);
 		this.poller.start();
-		running = true;
 	}
 
 	/**
@@ -141,7 +137,6 @@ public class RemoteUltrasonicPoller implements TimerListener {
 		this.stop();
 		for (int i = 0; i < readings.length; ++i) {
 			for (int j = 0; j < readings[1].length; ++j) {
-				RConsole.println("" + i + "," + j);
 				readings[i][j] = -1;
 			}
 		}
@@ -166,7 +161,6 @@ public class RemoteUltrasonicPoller implements TimerListener {
 	public void stop() {
 		this.poller.stop();
 		this.poller = null;
-		running = false;
 	}
 
 	/**
@@ -224,11 +218,9 @@ public class RemoteUltrasonicPoller implements TimerListener {
 		// calculate median value by sorting the readings
 		int minValue = readings[0][0]; // get a value to start
 		for (int usReadings[] : readings) {
-			int i = 0;
 			for (int reading : usReadings) {
 				if (minValue > reading && reading != -1)
 					minValue = reading;
-				++i;
 			}
 		}
 

commit 7de3564617a7505277ba989cdce10bbe22f6dfb4
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Fri Nov 22 21:53:08 2013 -0500

    Reformatted code.

diff --git a/src/hardwareAbstraction/NXTRemoteCommand.java b/src/hardwareAbstraction/NXTRemoteCommand.java
index 54108e6..f9594af 100644
--- a/src/hardwareAbstraction/NXTRemoteCommand.java
+++ b/src/hardwareAbstraction/NXTRemoteCommand.java
@@ -7,80 +7,73 @@ import java.io.IOException;
 import utilities.Communicator;
 
 public class NXTRemoteCommand {
-	   DataInputStream dis;
-	   DataOutputStream dos;
-	   
-	   
-	    public NXTRemoteCommand(Communicator communicator) {
-	    	this.dis = communicator.dis;
-	    	this.dos = communicator.dos;
-	    }
-	   
-	    public void send(int id,int command)
-	     {
-	       try
-	       { dos.writeInt(id);
-	         dos.writeInt(command);
-	        
-	         dos.flush();
-	       
-	         
-	       } catch (IOException e)
-	       {
-	       
-	         System.out.println("send problem " + e);
-	          
-	         }
-	       }
-	    public void send(int id,int command, int param1 ,boolean immediateReturn)
-	     {
-	       try
-	       { dos.writeInt(id);
-	         dos.writeInt(command);
-	         dos.writeInt(param1);
-	         dos.writeBoolean(immediateReturn);
-	         dos.flush();
-	        
-	         
-	       } catch (IOException e)
-	       {
-	       
-	         System.out.println("send problem " + e);
-	          
-	         }
-	       }
-	    
-	    public void send(int id,int command, int param1 )
-	     {
-	       try
-	       { dos.writeInt(id);
-	         dos.writeInt(command);
-	         dos.writeInt(param1);
-	        
-	         dos.flush();
-	         
-	         
-	       } catch (IOException e)
-	       {
-	       
-	         System.out.println("send problem " + e);
-	          
-	         }
-	       }
-	    public int getInt() throws IOException{
-	       
-	       return dis.readInt();
-	       
-	    }
-	 public float getFloat() throws IOException{
-	       
-	       return dis.readFloat();
-	       
-	    }
-	 
-	 public boolean getBool() throws IOException{
-	    
-	    return dis.readBoolean();
-	    
-	 }
+	DataInputStream dis;
+	DataOutputStream dos;
+
+	public NXTRemoteCommand(Communicator communicator) {
+		this.dis = communicator.dis;
+		this.dos = communicator.dos;
+	}
+
+	public void send(int id, int command) {
+		try {
+			dos.writeInt(id);
+			dos.writeInt(command);
+
+			dos.flush();
+
+		} catch (IOException e) {
+
+			System.out.println("send problem " + e);
+
+		}
+	}
+
+	public void send(int id, int command, int param1, boolean immediateReturn) {
+		try {
+			dos.writeInt(id);
+			dos.writeInt(command);
+			dos.writeInt(param1);
+			dos.writeBoolean(immediateReturn);
+			dos.flush();
+
+		} catch (IOException e) {
+
+			System.out.println("send problem " + e);
+
+		}
+	}
+
+	public void send(int id, int command, int param1) {
+		try {
+			dos.writeInt(id);
+			dos.writeInt(command);
+			dos.writeInt(param1);
+
+			dos.flush();
+
+		} catch (IOException e) {
+
+			System.out.println("send problem " + e);
+
+		}
+	}
+
+	public int getInt() throws IOException {
+
+		return dis.readInt();
+
+	}
+
+	public float getFloat() throws IOException {
+
+		return dis.readFloat();
+
+	}
+
+	public boolean getBool() throws IOException {
+
+		return dis.readBoolean();
+
+	}
 }

commit db766e982247e919a30ebd056f0a2903e542d7a3
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Fri Nov 22 21:17:33 2013 -0500

    Added to deprication status.

diff --git a/src/hardwareAbstraction/UltrasonicPoller.java b/src/hardwareAbstraction/UltrasonicPoller.java
index 4ad0dfb..fa9709a 100644
--- a/src/hardwareAbstraction/UltrasonicPoller.java
+++ b/src/hardwareAbstraction/UltrasonicPoller.java
@@ -16,7 +16,7 @@ import manager.Manager;
  * <p>
  * 
  * @author danielle, Riley
- * @deprecated Not used anymore.
+ * @deprecated Not used anymore. Will have its own implementation in the slaveNXT. 
  */
 public class UltrasonicPoller implements TimerListener {
 	private UltrasonicSensor[] us = new UltrasonicSensor[3];

commit 1d0c3191ab8f6c256d71d54c35a92d1672606b31
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Fri Nov 22 17:52:21 2013 -0500

    Worked on the new remote ultrasonic sensor. Still needs a considerable
    amount of work. Created a new package for items on the Slave NXT brick.

diff --git a/src/hardwareAbstraction/Claw.java b/src/hardwareAbstraction/Claw.java
index 05221db..c642ac4 100644
--- a/src/hardwareAbstraction/Claw.java
+++ b/src/hardwareAbstraction/Claw.java
@@ -5,7 +5,7 @@ import lejos.nxt.comm.RConsole;
 import lejos.nxt.remote.RemoteMotor;
 
 public class Claw {
-	static RemoteMotor claw = Settings.clawMotor;
+	static NXTRemoteMotor claw = Settings.clawMotor;
 	static int value = 70; // 45 degrees. needs to be tested. 
 	
 	/**
diff --git a/src/hardwareAbstraction/Forklift.java b/src/hardwareAbstraction/Forklift.java
index aa809d6..16a16f2 100644
--- a/src/hardwareAbstraction/Forklift.java
+++ b/src/hardwareAbstraction/Forklift.java
@@ -6,7 +6,7 @@ import lejos.nxt.remote.RemoteMotor;
 import utilities.Settings;
 
 public class Forklift {
-	static RemoteMotor lift = Settings.forkliftMotor;
+	static NXTRemoteMotor lift = Settings.liftMotor;
 	static int liftHeight = 15; // 15 cm upwards. Should be ok
 	static int scanHeight = 10; // 10 cm upwards. Needs to be tested. 
 	static int scanHeightLow = 7; // 7 cm upwards. Needs to be tested. 
diff --git a/src/hardwareAbstraction/NXTRemoteUltrasonicPoller.java b/src/hardwareAbstraction/NXTRemoteUltrasonicPoller.java
new file mode 100644
index 0000000..3080b92
--- /dev/null
+++ b/src/hardwareAbstraction/NXTRemoteUltrasonicPoller.java
@@ -0,0 +1,5 @@
+package hardwareAbstraction;
+
+public class NXTRemoteUltrasonicPoller {
+
+}
diff --git a/src/hardwareAbstraction/RemoteCommands.java b/src/hardwareAbstraction/RemoteCommands.java
index 8f227cb..97aabb2 100644
--- a/src/hardwareAbstraction/RemoteCommands.java
+++ b/src/hardwareAbstraction/RemoteCommands.java
@@ -32,4 +32,11 @@ public interface RemoteCommands {
 	  public static final int ADD_LISTENER= 18;
 	  public static final int ROTATION_STARTED= 19;
 	  public static final int ROTATION_STOPPED= 20;
+	  
+	  
+	  //ultrasonic commands
+	  public static final int PING_CENTER = 21;
+	  public static final int PING_LEFT = 22;
+	  public static final int PING_RIGHT = 23;
+	  public static final int PING_ALL = 24;
 }
diff --git a/src/hardwareAbstraction/RemoteUltrasonicPoller.java b/src/hardwareAbstraction/RemoteUltrasonicPoller.java
deleted file mode 100644
index 7de0ef7..0000000
--- a/src/hardwareAbstraction/RemoteUltrasonicPoller.java
+++ /dev/null
@@ -1,331 +0,0 @@
-package hardwareAbstraction;
-
-import controllers.State;
-import utilities.Settings;
-import lejos.nxt.LCD;
-import lejos.nxt.UltrasonicSensor;
-import lejos.nxt.comm.RConsole;
-import lejos.util.Timer;
-import lejos.util.TimerListener;
-import manager.Manager;
-
-/**
- * This class serves as a higher level abstraction of a ultrasonic sensor. It is
- * wrapped in a poller class which will now handle the returned values and the
- * polling of that sensor
- * <p>
- * 
- * @author Danielle
- * @author Riley
- */
-public class RemoteUltrasonicPoller implements TimerListener {
-	private UltrasonicSensor[] us = new UltrasonicSensor[3];
-	public int pollRate;
-	private Timer poller;
-	private int readings[][];
-	private boolean running = false;
-	
-	private int left = 0;
-	private int center = 1;
-	private int right = 2;
-	private int counter;
-
-	private Thread leftUS;
-	private Thread centerUS;
-	private Thread rightUS;
-
-	// TODO figure out what exactly this constructor should be.
-	public RemoteUltrasonicPoller() {
-		us[left] = Settings.leftUltrasonic;
-		us[center] = Settings.centerUltrasonic;
-		us[right] = Settings.rightUltrasonic;
-
-		this.pollRate = 100;
-		this.readings = new int[3][5];
-
-		us[left].off();
-		us[center].off();
-		us[right].off();
-
-		this.leftUS = new Thread(new LeftUS());
-		this.centerUS = new Thread(new CenterUS());
-		this.rightUS = new Thread(new RightUS());
-		
-		this.start();
-	}
-
-	/**
-	 * Pings all three ultrasonic sensors and gets their values. Puts them into
-	 * the readings array
-	 */
-	@Override
-	public void timedOut() {
-		
-		/*
-		 * Ensures minimal lag for ultrasonic localization 
-		 */
-		if(manager.cm.getState() != State.LOCALIZING) {
-		
-			/*
-			 * If the ultrasonics are facing forward, poll only one at a time.
-			 * Else poll them all simultaneously. 
-			 */
-			if(UltrasonicMotor.isForward) {
-				switch(counter) {
-				case 0 : leftUS.run();
-				break;
-				case 1 : centerUS.run();
-				break;
-				case 2 : rightUS.run();
-				break;
-				}
-				counter += 1;
-				counter = counter % 3;
-			}
-			else {
-				leftUS.run();
-				centerUS.run();
-				rightUS.run();
-				RConsole.println(toStringLastValues());
-			}
-		} else {
-			centerUS.run();
-		}
-	}
-
-	// For debugging purposes.
-	private String toStringLastValues() {
-		String out = "";
-		out += " L: " + getUSReading(left);
-		out += " C: " + getUSReading(center);
-		out += " R: " + getUSReading(right);
-		return out;
-	}
-
-	/**
-	 * Starts this instance of the ultrasonic poller Stop must be called to stop
-	 * the reading again.
-	 */
-	public void start() {
-		counter = 0;
-
-		// for filtering purposes
-		this.poller = new Timer(pollRate, this);
-		this.poller.start();
-		running = true;
-	}
-
-	/**
-	 * Resets the ultrasonic sensor values to the default -1 values. The
-	 * ultrasonic sensor will never return negative values during normal
-	 * operation. Stops the polling during this operation to avoid overwriting
-	 * good data.
-	 * @bug throws null pointer exception. Has potentially been fixed. Needs to be tested.
-	 */
-	public void resetUSP() {
-		this.stop();
-		for (int i = 0; i < readings.length; ++i) {
-			for (int j = 0; j < readings[1].length; ++j) {
-				RConsole.println("" + i + "," + j);
-				readings[i][j] = -1;
-			}
-		}
-		this.start();
-	}
-
-	/**
-	 * Checks if the ultrasonic sensor has collected atleast 5 values. It does
-	 * this by checking for any negative numbers in the readings.
-	 */
-	public boolean isSetup() {
-		if (readings[2][4] == -1 || readings[0][4] == -1 || readings[1][4] == -1)
-			return false;
-		else
-			return true;
-	}
-
-	/**
-	 * Stops this instance of the ultrasonic poller Start must be called to
-	 * start reading again.
-	 */
-	public void stop() {
-		this.poller.stop();
-		this.poller = null;
-		running = false;
-	}
-
-	/**
-	 * Returns the filtered data for the sensor (median filtering)
-	 * 
-	 * @param sensor
-	 * @return
-	 */
-	public int getUSReading(int sensor) {
-
-		// makes sure readings array is full of values so we have enough to
-		// filter with
-		if (readings[sensor][4] > -1) {
-
-			// initialize vars
-			int size = 5;
-			int[] usReadingsSorted = new int[5];
-			// Copy array
-			System.arraycopy(readings[sensor], 0, usReadingsSorted, 0, 5);
-
-			// sort the values: lowest to highest
-			for (int i = 0; i < size; i++) {
-				for (int j = i + 1; j < size; j++) {
-					if (usReadingsSorted[i] > usReadingsSorted[j]) {
-						int temp = usReadingsSorted[i];
-						usReadingsSorted[i] = usReadingsSorted[j];
-						usReadingsSorted[j] = temp;
-					}
-				}
-			}
-
-			// return the median
-			return usReadingsSorted[2];
-
-		} else {
-			return readings[sensor][0];
-		}
-	}
-
-	/**
-	 * gets the lowest reading in the ultrasonicPoller at that time. Readings
-	 * are not taken temporarily as they are not needed;
-	 * <p>
-	 * 
-	 * @return The smallest reading of the last 5 polls.
-	 */
-	public int getLowestReading() {
-		// stop reading if the robot was taking readings.
-		boolean takingReadings = false;
-		if (this.poller != null) {
-			stop();
-			takingReadings = true;
-		}
-
-		// calculate median value by sorting the readings
-		int minValue = readings[0][0]; // get a value to start
-		for (int usReadings[] : readings) {
-			int i = 0;
-			for (int reading : usReadings) {
-				if (minValue > reading && reading != -1)
-					minValue = reading;
-				++i;
-			}
-		}
-
-		// start the readings again if the robot was taking readings before.
-		if (takingReadings)
-			start();
-		return minValue;
-	}
-	
-	/**
-	 * This method gets the number representation of the US with the lowest value out of all the ultrasonic sensor. 
-	 * So if the center has the lowest reading, 
-	 */
-	public USPosition getLowestSensor() {
-		boolean takingReadings = false;
-		if (this.poller != null) {
-			stop();
-			takingReadings = true;
-		}
-
-		// calculate median value by sorting the readings
-		int minValue = readings[0][0]; // get a value to start
-		int sensor = 0;
-		int smallestSensor = 0;
-		for (int usReadings[] : readings) {
-			for (int reading : usReadings) {
-				if (minValue > reading && reading != -1) {
-					minValue = reading;
-					smallestSensor = sensor;
-				}
-			}
-			sensor++;
-		}
-
-		// start the readings again if the robot was taking readings before.
-		if (takingReadings)
-			start();
-		if(smallestSensor == left)
-			return USPosition.LEFT;
-		else if(smallestSensor == center)
-			return USPosition.CENTER;
-		else
-			return USPosition.RIGHT;
-	}
-
-	/**
-	 * Pings ultrasonic sensor and records the result in readings
-	 */
-	private void pingUS(int sensor) {
-		int distance;
-
-		// do a ping
-		us[sensor].ping();
-
-		// wait for the ping to complete
-		try {
-			Thread.sleep(20);
-		} catch (InterruptedException e) {
-		}
-
-		// there will be a delay here
-		distance = us[sensor].getDistance();
-
-		addReading(sensor, distance);
-	}
-
-	// helper method.
-	private void addReading(int sensor, int reading) {
-		readings[sensor][4] = readings[sensor][3];
-		readings[sensor][3] = readings[sensor][2];
-		readings[sensor][2] = readings[sensor][1];
-		readings[sensor][1] = readings[sensor][0];
-		readings[sensor][0] = reading;
-	}
-	
-	/**
-	 * Computes the average values read by a sensor
-	 * @param sensor	The integer value corresponding to the ultrasonic sensor
-	 * @return The average integer value, in integer value.
-	 */
-	public int computeAverage(int sensor) {
-		int sum = 0;
-		for(int i = 0; i < readings[sensor].length; i++)
-			sum += readings[sensor][i];
-		return (sum / readings[sensor].length);
-	}
-
-	public class LeftUS implements Runnable {
-
-		@Override
-		public void run() {
-			pingUS(left);
-		}
-	}
-
-	public class RightUS implements Runnable {
-
-		@Override
-		public void run() {
-			pingUS(right);
-		}
-	}
-
-	public class CenterUS implements Runnable {
-
-		@Override
-		public void run() {
-			pingUS(center);
-		}
-	}
-	
-	public enum USPosition {
-		LEFT, CENTER, RIGHT
-	}
-}
diff --git a/src/hardwareAbstraction/UltrasonicPoller.java b/src/hardwareAbstraction/UltrasonicPoller.java
index a5df636..4ad0dfb 100644
--- a/src/hardwareAbstraction/UltrasonicPoller.java
+++ b/src/hardwareAbstraction/UltrasonicPoller.java
@@ -16,6 +16,7 @@ import manager.Manager;
  * <p>
  * 
  * @author danielle, Riley
+ * @deprecated Not used anymore.
  */
 public class UltrasonicPoller implements TimerListener {
 	private UltrasonicSensor[] us = new UltrasonicSensor[3];
diff --git a/src/launcher/Launcher.java b/src/launcher/Launcher.java
index c9642fa..3518c13 100644
--- a/src/launcher/Launcher.java
+++ b/src/launcher/Launcher.java
@@ -6,7 +6,7 @@ package launcher;
 import hardwareAbstraction.Claw;
 import hardwareAbstraction.Forklift;
 import hardwareAbstraction.Forklift.ForkliftState;
-import hardwareAbstraction.NXTMotorCommand;
+import hardwareAbstraction.NXTRemoteCommand;
 import hardwareAbstraction.NXTRemoteMotor;
 import hardwareAbstraction.UltrasonicMotor;
 import hardwareAbstraction.UltrasonicPoller;
@@ -44,7 +44,7 @@ public class Launcher {
 		
 		Communicator com = new Communicator("NXT");
 		
-		NXTMotorCommand motorCommand = new NXTMotorCommand(com);
+		NXTRemoteCommand motorCommand = new NXTRemoteCommand(com);
 		
 		NXTRemoteMotor clawMotor = new NXTRemoteMotor(motorCommand, 1);
 		NXTRemoteMotor ultrasonicMotor = new NXTRemoteMotor(motorCommand, 2);
diff --git a/src/slave/NXTRemoteControl.java b/src/slave/NXTRemoteControl.java
new file mode 100644
index 0000000..f99edb1
--- /dev/null
+++ b/src/slave/NXTRemoteControl.java
@@ -0,0 +1,396 @@
+package slave;
+
+import hardwareAbstraction.RemoteCommands;
+import hardwareAbstraction.UltrasonicPoller;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+
+import slave.RemoteUltrasonicPoller.USPState;
+import lejos.nxt.*;
+import lejos.nxt.comm.NXTCommConnector;
+import lejos.nxt.comm.NXTConnection;
+import lejos.nxt.comm.RConsole;
+import lejos.nxt.comm.RS485;
+import lejos.robotics.RegulatedMotor;
+import lejos.robotics.RegulatedMotorListener;
+
+/**
+ * Enables remote control of a motor object using RS485. 
+ **/
+public class NXTRemoteControl extends Thread implements RemoteCommands, RegulatedMotorListener {
+
+   private DataInputStream dis = null;
+   private DataOutputStream dos = null;
+   
+   //private DataInputStream lisdis = null;
+   //private DataOutputStream lisdos = null;
+   
+   private NXTCommConnector connector;
+   private NXTConnection con;
+   
+   
+   //private NXTConnection listenersCon;
+   private int id;
+   private int command;
+   private int tachoCount;
+   private boolean isMoving;
+   private int speed;
+   private float maxSpeed;
+   private int acceleration;
+   private int angle;
+   private boolean immediateReturn, isStalled;
+
+   private static NXTRegulatedMotor A = null;
+   private static NXTRegulatedMotor B = null;
+   private static NXTRegulatedMotor C = null;
+   private static RemoteUltrasonicPoller usp = null;
+
+   public NXTRemoteControl(MotorPort portA) {
+      
+      A = new NXTRegulatedMotor(portA);
+
+}
+   public NXTRemoteControl(MotorPort portA, MotorPort portB) {
+      
+         A = new NXTRegulatedMotor(portA);
+         B = new NXTRegulatedMotor(portB);
+         
+
+   }
+   public NXTRemoteControl(MotorPort portA, MotorPort portB,
+         MotorPort portC) {
+      
+         A = new NXTRegulatedMotor(portA);
+         B = new NXTRegulatedMotor(portB);
+         C = new NXTRegulatedMotor(portC);
+
+   }
+   
+   public NXTRemoteControl(MotorPort portA, MotorPort portB, MotorPort portC, RemoteUltrasonicPoller usp) {
+	   A = new NXTRegulatedMotor(portA);
+       B = new NXTRegulatedMotor(portB);
+       C = new NXTRegulatedMotor(portC);
+       usp = new RemoteUltrasonicPoller();
+   }
+
+   protected void executeCommand(int id, int command) throws IOException {
+
+		NXTRegulatedMotor motor = getMotor(id);
+		RemoteUltrasonicPoller usp = getSensor(id);
+		
+		if (usp != null) {
+			switch( command) {
+			case PING_CENTER: {
+				RConsole.println("PING_CENTER");
+				usp.setUSPState(USPState.PING_CENTER);
+			}
+			case PING_LEFT: {
+				RConsole.println("PING_LEFT");
+				usp.setUSPState(USPState.PING_LEFT);
+			}
+			case PING_RIGHT: {
+				RConsole.println("PING_RIGHT");
+				usp.setUSPState(USPState.PING_RIGHT);
+			}
+			case PING_ALL: {
+				RConsole.println("PING_ALL");
+				usp.setUSPState(USPState.PING_ALL);
+			}
+			}
+		}
+		else {
+			switch (command) {
+
+			case FORWARD: {
+				RConsole.println("FORWARD");
+				motor.forward();
+				break;
+			}
+
+			case BACKWARD: {
+				RConsole.println("BACKWARD");
+				motor.backward();
+				break;
+			}
+
+			case ROTATE: {
+				RConsole.println("ROTATE");
+				angle = dis.readInt();
+				RConsole.println("angle" + angle);
+				immediateReturn = dis.readBoolean();
+				RConsole.println("immediateReturn" + immediateReturn);
+				motor.rotate(angle, immediateReturn);
+				break;
+			}
+
+			case STOP: {
+				RConsole.println("STOP");
+				motor.stop();
+				break;
+			}
+
+			case ROTATE_TO: {
+				RConsole.println("ROTATE_TO");
+				angle = dis.readInt();
+				immediateReturn = dis.readBoolean();
+				RConsole.println("angle" + angle);
+				RConsole.println("immediateReturn" + immediateReturn);
+				motor.rotateTo(angle, immediateReturn);
+				break;
+			}
+
+			case FLT: {
+				RConsole.println("FLT");
+				motor.flt();
+				break;
+			}
+
+			case GET_TACHO_COUNT: {
+				RConsole.println("GET_TACHO_COUNT");
+				tachoCount = motor.getTachoCount();
+				RConsole.println("tachoCount" + tachoCount);
+				dos.writeInt(tachoCount);
+				dos.flush();
+				break;
+			}
+
+			case IS_MOVING: {
+				RConsole.println("IS_MOVING");
+				isMoving = motor.isMoving();
+				RConsole.println("isMoving" + isMoving);
+				dos.writeBoolean(isMoving);
+				dos.flush();
+				break;
+			}
+
+			case SET_SPEED: {
+				int speed;
+				RConsole.println("SET_SPEED");
+				speed = dis.readInt();
+				RConsole.println("SET_SPEED=" + speed);
+				motor.setSpeed(speed);
+				break;
+			}
+
+			case SET_ACCELERATION: {
+				RConsole.println("SET_ACCELERATION");
+				acceleration = dis.readInt();
+				RConsole.println("acceleration=" + acceleration);
+				motor.setAcceleration(acceleration);
+
+				break;
+			}
+
+			case GET_LIMIT_ANGLE: {
+				RConsole.println("GET_LIMIT_ANGLE");
+				angle = motor.getLimitAngle();
+				RConsole.println("angle=" + angle);
+				dos.writeInt(angle);
+				dos.flush();
+				break;
+			}
+
+			case RESET_TACHO_COUNT: {
+				RConsole.println("RESET_TACHO_COUNT");
+				motor.resetTachoCount();
+				break;
+			}
+
+			case GET_SPEED: {
+				RConsole.println("GET_SPEED");
+				speed = motor.getSpeed();
+				RConsole.println("speed=" + speed);
+				dos.writeInt(speed);
+				dos.flush();
+				break;
+			}
+
+			case IS_STALLED: {
+				RConsole.println("IS_STALLED");
+				isStalled = motor.isMoving();
+				RConsole.println("isStalled=" + isStalled);
+				dos.writeBoolean(isStalled);
+				dos.flush();
+				break;
+
+			}
+
+			case GET_ROTATION_SPEED: {
+				RConsole.println("GET_ROTATION_SPEED");
+				speed = motor.getRotationSpeed();
+				RConsole.println("speed=" + speed);
+				dos.writeInt(speed);
+				dos.flush();
+				break;
+			}
+
+			case GET_MAX_SPEED: {
+				RConsole.println("GET_MAX_SPEED");
+				maxSpeed = motor.getMaxSpeed();
+				RConsole.println("maxSpeed=" + maxSpeed);
+				dos.writeFloat(maxSpeed);
+				dos.flush();
+				break;
+
+			}
+			case ADD_LISTENER: {
+				motor.addListener(this);
+				// if (listenersCon==null){
+				// connectionThread connect=new connectionThread();
+				// connect.start();
+				// }
+
+				break;
+
+			}
+
+			case SUSPEND_REGULATION: {
+				boolean suspended;
+				RConsole.println("SUSPEND_REGULATION");
+				suspended = motor.suspendRegulation();
+				dos.writeBoolean(suspended);
+				dos.flush();
+				break;
+
+			}
+			}
+		}
+
+   }
+
+   protected RemoteUltrasonicPoller getSensor(int id) {
+
+	      switch (id) {
+	      case 4:
+	         return usp;
+	      }
+	      return null;
+	   }   
+   protected NXTRegulatedMotor getMotor(int id) {
+
+      switch (id) {
+      case 1:
+         return A;
+
+      case 2:
+         return B;
+
+      case 3:
+         return C;
+      }
+
+      return null;
+   }   
+   
+   protected int getMotor(RegulatedMotor motor) {
+
+      if(motor.equals(Motor.A))
+         return 1;
+      else  if(motor.equals(Motor.B))
+         return 2;
+      else  if(motor.equals(Motor.C))
+         return 3;
+      
+      return -1;
+   }
+   
+   public void run() {
+
+      while (true) {
+         
+         // Wait for connection if not connected
+         if (con == null) {
+            LCD.drawString("waiting", 0, 2);
+
+            connector = RS485.getConnector();
+            con = connector.waitForConnection(0, NXTConnection.RAW);
+
+            if (con != null) {
+               dis = con.openDataInputStream();
+               dos = con.openDataOutputStream();
+            }
+            LCD.drawString("Connected", 0, 2);
+            LCD.refresh();
+         }
+         
+         try {
+            id = dis.readInt();
+            command = dis.readInt();
+            RConsole.println("id="+id +"command =" +command);
+            executeCommand(id, command);
+
+         } catch (IOException e) {
+         //A.stop();
+         //B.stop();
+            //con.close();
+            //con = null;
+            //e.printStackTrace();
+         }
+
+      
+   
+      }
+}
+   @Override
+   public void rotationStarted(RegulatedMotor motor, int tachoCount, boolean stalled,
+         long timeStamp) {
+      
+//      try {
+//         
+//         int id=getMotor( motor);
+//         lisdos.writeInt(id);
+//         lisdos.writeInt(ROTATION_STARTED);
+//         lisdos.writeInt(tachoCount);
+//         lisdos.writeBoolean(stalled);
+//         lisdos.writeLong(timeStamp);
+//         lisdos.flush();
+//      } catch (IOException e) {
+//         // TODO Auto-generated catch block
+//         e.printStackTrace();
+      }
+      
+   
+   @Override
+   public void rotationStopped(RegulatedMotor motor, int tachoCount, boolean stalled,
+         long timeStamp) {
+      
+//try {
+//         
+//         int id=getMotor(motor);
+//         lisdos.writeInt(id);
+//         lisdos.writeInt(ROTATION_STOPPED);
+//         lisdos.writeInt(tachoCount);
+//         lisdos.writeBoolean(stalled);
+//         lisdos.writeLong(timeStamp);
+//         lisdos.flush();
+//      } catch (IOException e) {
+//         // TODO Auto-generated catch block
+//         e.printStackTrace();
+//      }
+         
+   }
+   
+//   public class connectionThread extends Thread {
+//      
+//      public void run(){
+//   
+//         // Wait for connection if not connected
+//         if (listenersCon == null) {
+//            LCD.drawString("waiting", 0, 2);
+//
+//            connector = RS485.getConnector();
+//            listenersCon = connector.waitForConnection(0, NXTConnection.RAW);
+//
+//            if (con != null) {
+//               lisdis = con.openDataInputStream();
+//               lisdos = con.openDataOutputStream();
+//            }
+//            LCD.drawString("Connected", 0, 2);
+//            LCD.refresh();
+//         }
+//}
+//   }
+   
+   }
\ No newline at end of file
diff --git a/src/slave/RemoteUltrasonicPoller.java b/src/slave/RemoteUltrasonicPoller.java
new file mode 100644
index 0000000..950964c
--- /dev/null
+++ b/src/slave/RemoteUltrasonicPoller.java
@@ -0,0 +1,346 @@
+package slave;
+
+import hardwareAbstraction.UltrasonicMotor;
+import controllers.State;
+import utilities.Settings;
+import lejos.nxt.LCD;
+import lejos.nxt.SensorPort;
+import lejos.nxt.UltrasonicSensor;
+import lejos.nxt.comm.RConsole;
+import lejos.util.Timer;
+import lejos.util.TimerListener;
+import manager.Manager;
+
+/**
+ * This class serves as a higher level abstraction of a ultrasonic sensor. It is
+ * wrapped in a poller class which will now handle the returned values and the
+ * polling of that sensor
+ * <p>
+ * 
+ * @author Danielle
+ * @author Riley
+ */
+public class RemoteUltrasonicPoller implements TimerListener {
+	private UltrasonicSensor[] us = new UltrasonicSensor[3];
+	
+	private int pollRate;
+	private Timer poller;
+	private int readings[][];
+	private boolean running = false;
+	
+	private int left = 0;
+	private int center = 1;
+	private int right = 2;
+	private int counter;
+
+	private Thread leftUS;
+	private Thread centerUS;
+	private Thread rightUS;
+	
+	public USPState state;
+	
+	public enum USPState {
+		PING_CENTER, PING_ALL, PING_LEFT, PING_RIGHT;
+	}
+
+	// TODO figure out what exactly this constructor should be.
+	public RemoteUltrasonicPoller() {
+		us[left] = new UltrasonicSensor(SensorPort.S3);
+		us[center] = new UltrasonicSensor(SensorPort.S1);
+		us[right] = new UltrasonicSensor(SensorPort.S2);
+
+		this.pollRate = 100;
+		this.readings = new int[3][5];
+
+		us[left].off();
+		us[center].off();
+		us[right].off();
+
+		this.leftUS = new Thread(new LeftUS());
+		this.centerUS = new Thread(new CenterUS());
+		this.rightUS = new Thread(new RightUS());
+		
+		this.state = USPState.PING_ALL;
+		
+		this.start();
+	}
+	
+	public void setUSPState(USPState state) {
+		this.state = state;
+	}
+
+	/**
+	 * Pings all three ultrasonic sensors and gets their values. Puts them into
+	 * the readings array
+	 */
+	@Override
+	public void timedOut() {
+		
+		/*
+		 * Ensures minimal lag for ultrasonic localization 
+		 */
+		if(manager.cm.getState() != State.LOCALIZING) {
+		
+			/*
+			 * If the ultrasonics are facing forward, poll only one at a time.
+			 * Else poll them all simultaneously. 
+			 */
+			if(UltrasonicMotor.isForward) {
+				switch(counter) {
+				case 0 : leftUS.run();
+				break;
+				case 1 : centerUS.run();
+				break;
+				case 2 : rightUS.run();
+				break;
+				}
+				counter += 1;
+				counter = counter % 3;
+			}
+			else {
+				leftUS.run();
+				centerUS.run();
+				rightUS.run();
+				RConsole.println(toStringLastValues());
+			}
+		} else {
+			centerUS.run();
+		}
+	}
+
+	// For debugging purposes.
+	private String toStringLastValues() {
+		String out = "";
+		out += " L: " + getUSReading(left);
+		out += " C: " + getUSReading(center);
+		out += " R: " + getUSReading(right);
+		return out;
+	}
+
+	/**
+	 * Starts this instance of the ultrasonic poller Stop must be called to stop
+	 * the reading again.
+	 */
+	public void start() {
+		counter = 0;
+
+		// for filtering purposes
+		this.poller = new Timer(pollRate, this);
+		this.poller.start();
+		running = true;
+	}
+
+	/**
+	 * Resets the ultrasonic sensor values to the default -1 values. The
+	 * ultrasonic sensor will never return negative values during normal
+	 * operation. Stops the polling during this operation to avoid overwriting
+	 * good data.
+	 * @bug throws null pointer exception. Has potentially been fixed. Needs to be tested.
+	 */
+	public void resetUSP() {
+		this.stop();
+		for (int i = 0; i < readings.length; ++i) {
+			for (int j = 0; j < readings[1].length; ++j) {
+				RConsole.println("" + i + "," + j);
+				readings[i][j] = -1;
+			}
+		}
+		this.start();
+	}
+
+	/**
+	 * Checks if the ultrasonic sensor has collected atleast 5 values. It does
+	 * this by checking for any negative numbers in the readings.
+	 */
+	public boolean isSetup() {
+		if (readings[2][4] == -1 || readings[0][4] == -1 || readings[1][4] == -1)
+			return false;
+		else
+			return true;
+	}
+
+	/**
+	 * Stops this instance of the ultrasonic poller Start must be called to
+	 * start reading again.
+	 */
+	public void stop() {
+		this.poller.stop();
+		this.poller = null;
+		running = false;
+	}
+
+	/**
+	 * Returns the filtered data for the sensor (median filtering)
+	 * 
+	 * @param sensor
+	 * @return
+	 */
+	public int getUSReading(int sensor) {
+
+		// makes sure readings array is full of values so we have enough to
+		// filter with
+		if (readings[sensor][4] > -1) {
+
+			// initialize vars
+			int size = 5;
+			int[] usReadingsSorted = new int[5];
+			// Copy array
+			System.arraycopy(readings[sensor], 0, usReadingsSorted, 0, 5);
+
+			// sort the values: lowest to highest
+			for (int i = 0; i < size; i++) {
+				for (int j = i + 1; j < size; j++) {
+					if (usReadingsSorted[i] > usReadingsSorted[j]) {
+						int temp = usReadingsSorted[i];
+						usReadingsSorted[i] = usReadingsSorted[j];
+						usReadingsSorted[j] = temp;
+					}
+				}
+			}
+
+			// return the median
+			return usReadingsSorted[2];
+
+		} else {
+			return readings[sensor][0];
+		}
+	}
+
+	/**
+	 * gets the lowest reading in the ultrasonicPoller at that time. Readings
+	 * are not taken temporarily as they are not needed;
+	 * <p>
+	 * 
+	 * @return The smallest reading of the last 5 polls.
+	 */
+	public int getLowestReading() {
+		// stop reading if the robot was taking readings.
+		boolean takingReadings = false;
+		if (this.poller != null) {
+			stop();
+			takingReadings = true;
+		}
+
+		// calculate median value by sorting the readings
+		int minValue = readings[0][0]; // get a value to start
+		for (int usReadings[] : readings) {
+			int i = 0;
+			for (int reading : usReadings) {
+				if (minValue > reading && reading != -1)
+					minValue = reading;
+				++i;
+			}
+		}
+
+		// start the readings again if the robot was taking readings before.
+		if (takingReadings)
+			start();
+		return minValue;
+	}
+	
+	/**
+	 * This method gets the number representation of the US with the lowest value out of all the ultrasonic sensor. 
+	 * So if the center has the lowest reading, 
+	 */
+	public USPosition getLowestSensor() {
+		boolean takingReadings = false;
+		if (this.poller != null) {
+			stop();
+			takingReadings = true;
+		}
+
+		// calculate median value by sorting the readings
+		int minValue = readings[0][0]; // get a value to start
+		int sensor = 0;
+		int smallestSensor = 0;
+		for (int usReadings[] : readings) {
+			for (int reading : usReadings) {
+				if (minValue > reading && reading != -1) {
+					minValue = reading;
+					smallestSensor = sensor;
+				}
+			}
+			sensor++;
+		}
+
+		// start the readings again if the robot was taking readings before.
+		if (takingReadings)
+			start();
+		if(smallestSensor == left)
+			return USPosition.LEFT;
+		else if(smallestSensor == center)
+			return USPosition.CENTER;
+		else
+			return USPosition.RIGHT;
+	}
+
+	/**
+	 * Pings ultrasonic sensor and records the result in readings
+	 */
+	private void pingUS(int sensor) {
+		int distance;
+
+		// do a ping
+		us[sensor].ping();
+
+		// wait for the ping to complete
+		try {
+			Thread.sleep(20);
+		} catch (InterruptedException e) {
+		}
+
+		// there will be a delay here
+		distance = us[sensor].getDistance();
+
+		addReading(sensor, distance);
+	}
+
+	// helper method.
+	private void addReading(int sensor, int reading) {
+		readings[sensor][4] = readings[sensor][3];
+		readings[sensor][3] = readings[sensor][2];
+		readings[sensor][2] = readings[sensor][1];
+		readings[sensor][1] = readings[sensor][0];
+		readings[sensor][0] = reading;
+	}
+	
+	/**
+	 * Computes the average values read by a sensor
+	 * @param sensor	The integer value corresponding to the ultrasonic sensor
+	 * @return The average integer value, in integer value.
+	 */
+	public int computeAverage(int sensor) {
+		int sum = 0;
+		for(int i = 0; i < readings[sensor].length; i++)
+			sum += readings[sensor][i];
+		return (sum / readings[sensor].length);
+	}
+
+	public class LeftUS implements Runnable {
+
+		@Override
+		public void run() {
+			pingUS(left);
+		}
+	}
+
+	public class RightUS implements Runnable {
+
+		@Override
+		public void run() {
+			pingUS(right);
+		}
+	}
+
+	public class CenterUS implements Runnable {
+
+		@Override
+		public void run() {
+			pingUS(center);
+		}
+	}
+	
+	public enum USPosition {
+		LEFT, CENTER, RIGHT
+	}
+}
diff --git a/src/slave/Responder.java b/src/slave/Responder.java
new file mode 100644
index 0000000..49d676d
--- /dev/null
+++ b/src/slave/Responder.java
@@ -0,0 +1,62 @@
+package slave;
+
+import lejos.nxt.LCD;
+import lejos.nxt.MotorPort;
+import lejos.nxt.comm.Bluetooth;
+import lejos.nxt.comm.LCPResponder;
+import lejos.nxt.comm.NXTCommConnector;
+import lejos.nxt.comm.NXTConnection;
+import lejos.nxt.comm.RConsole;
+import lejos.nxt.comm.RS485;
+
+/**
+ * The responder class responds to the LCP requests sent by the Communicator.java class. 
+ * Uses by default Bluetooth.
+ * 
+ * Slight modification for LeJOS samples
+ * <p> 
+ * @author Andy Shaw
+ * @author danielle
+ * 
+ */
+public class Responder {
+	
+	/**
+	 * The subclass that handles the LCP connections. In particular, it is modified version of the LCPResponder to shutdown the connection once the program disconnects.
+	 * @author Andy Shaw
+	 * @author danielle
+	 *
+	 */
+	public static class ResponderTool extends LCPResponder {
+		ResponderTool(NXTCommConnector con) {
+            super(con);
+        }
+
+         protected void disconnect() {
+            super.disconnect();
+            super.shutdown();
+        }
+	}
+	
+	/**
+	 * This program has a main as it is to be loaded on the slaveNXT brick. Has
+	 * almost no functionality otherwise.
+	 * <p>
+	 * @param args
+	 *            This is the default constructor, not needed.
+	 */
+	
+	public static void main(String[] args) throws Exception {
+		//RConsole.openUSB(20000);
+		LCD.drawString("Connecting", 1, 1);
+		//ResponderTool resp = new ResponderTool(RS485.getConnector());
+		//resp.start();
+		//resp.join();
+		RemoteUltrasonicPoller remoteUSP = new RemoteUltrasonicPoller();
+		NXTRemoteControl motorControl = new NXTRemoteControl(MotorPort.A, MotorPort.B, MotorPort.C, remoteUSP);
+		
+		motorControl.start();
+		
+    }
+	
+}
\ No newline at end of file
diff --git a/src/utilities/NXTRemoteControl.java b/src/utilities/NXTRemoteControl.java
deleted file mode 100644
index 974ca4c..0000000
--- a/src/utilities/NXTRemoteControl.java
+++ /dev/null
@@ -1,367 +0,0 @@
-package utilities;
-
-import hardwareAbstraction.RemoteCommands;
-import hardwareAbstraction.UltrasonicPoller;
-
-import java.io.DataInputStream;
-import java.io.DataOutputStream;
-import java.io.IOException;
-
-import lejos.nxt.*;
-import lejos.nxt.comm.NXTCommConnector;
-import lejos.nxt.comm.NXTConnection;
-import lejos.nxt.comm.RConsole;
-import lejos.nxt.comm.RS485;
-import lejos.robotics.RegulatedMotor;
-import lejos.robotics.RegulatedMotorListener;
-
-/**
- * Enables remote control of a motor object using RS485. 
- **/
-public class NXTRemoteControl extends Thread implements RemoteCommands, RegulatedMotorListener {
-
-   private DataInputStream dis = null;
-   private DataOutputStream dos = null;
-   
-   //private DataInputStream lisdis = null;
-   //private DataOutputStream lisdos = null;
-   
-   private NXTCommConnector connector;
-   private NXTConnection con;
-   
-   
-   //private NXTConnection listenersCon;
-   private int id;
-   private int command;
-   private int tachoCount;
-   private boolean isMoving;
-   private int speed;
-   private float maxSpeed;
-   private int acceleration;
-   private int angle;
-   private boolean immediateReturn, isStalled;
-
-   private static NXTRegulatedMotor A = null;
-   private static NXTRegulatedMotor B = null;
-   private static NXTRegulatedMotor C = null;
-   private RemoteUltrasonicPoller usp = null;
-
-   public NXTRemoteControl(MotorPort portA) {
-      
-      A = new NXTRegulatedMotor(portA);
-
-}
-   public NXTRemoteControl(MotorPort portA, MotorPort portB) {
-      
-         A = new NXTRegulatedMotor(portA);
-         B = new NXTRegulatedMotor(portB);
-         
-
-   }
-   public NXTRemoteControl(MotorPort portA, MotorPort portB,
-         MotorPort portC) {
-      
-         A = new NXTRegulatedMotor(portA);
-         B = new NXTRegulatedMotor(portB);
-         C = new NXTRegulatedMotor(portC);
-
-   }
-   
-   public NXTRemoteControl(MotorPort portA, MotorPort portB, MotorPort portC, RemoteUltrasonicPoller usp) {
-	   A = new NXTRegulatedMotor(portA);
-       B = new NXTRegulatedMotor(portB);
-       C = new NXTRegulatedMotor(portC);
-       usp = new RemoteUltrasonicPoller();
-   }
-
-   protected void executeCommand(int id, int command) throws IOException {
-
-      NXTRegulatedMotor motor = getMotor(id);
-
-      switch (command) {
-
-      case FORWARD: {
-         RConsole.println("FORWARD");
-         motor.forward();
-         break;
-      }
-
-      case BACKWARD: {
-         RConsole.println("BACKWARD");
-         motor.backward();
-         break;
-      }
-
-      case ROTATE: {
-         RConsole.println("ROTATE");
-         angle = dis.readInt();
-         RConsole.println("angle"+angle);
-         immediateReturn = dis.readBoolean();
-         RConsole.println("immediateReturn"+immediateReturn);
-         motor.rotate(angle, immediateReturn);
-         break;
-      }
-
-      case STOP: {
-         RConsole.println("STOP");
-         motor.stop();
-         break;
-      }
-
-      case ROTATE_TO: {
-         RConsole.println("ROTATE_TO");
-         angle = dis.readInt();
-         immediateReturn = dis.readBoolean();
-         RConsole.println("angle"+angle);
-         RConsole.println("immediateReturn"+immediateReturn);
-         motor.rotateTo(angle, immediateReturn);
-         break;
-      }
-
-      case FLT: {
-         RConsole.println("FLT");
-         motor.flt();
-         break;
-      }
-
-      case GET_TACHO_COUNT: {
-         RConsole.println("GET_TACHO_COUNT");
-         tachoCount = motor.getTachoCount();
-         RConsole.println("tachoCount"+tachoCount);
-         dos.writeInt(tachoCount);
-         dos.flush();
-         break;
-      }
-
-      case IS_MOVING: {
-         RConsole.println("IS_MOVING");
-         isMoving = motor.isMoving();
-         RConsole.println("isMoving"+isMoving);
-         dos.writeBoolean(isMoving);
-         dos.flush();
-         break;
-      }
-
-      case SET_SPEED: {
-         int speed;
-         RConsole.println("SET_SPEED");
-         speed = dis.readInt();
-         RConsole.println("SET_SPEED="+speed);
-         motor.setSpeed(speed);
-         break;
-      }
-
-      case SET_ACCELERATION: {
-         RConsole.println("SET_ACCELERATION");
-         acceleration = dis.readInt();
-         RConsole.println("acceleration="+acceleration);
-         motor.setAcceleration(acceleration);
-      
-         break;
-      }
-
-      case GET_LIMIT_ANGLE: {
-         RConsole.println("GET_LIMIT_ANGLE");
-         angle = motor.getLimitAngle();
-         RConsole.println("angle="+angle);
-         dos.writeInt(angle);
-         dos.flush();
-         break;
-      }
-
-      case RESET_TACHO_COUNT: {
-         RConsole.println("RESET_TACHO_COUNT");
-         motor.resetTachoCount();
-         break;
-      }
-
-      case GET_SPEED: {
-         RConsole.println("GET_SPEED");
-         speed = motor.getSpeed();
-         RConsole.println("speed="+speed);
-         dos.writeInt(speed);
-         dos.flush();
-         break;
-      }
-
-      case IS_STALLED: {
-         RConsole.println("IS_STALLED");
-         isStalled = motor.isMoving();
-         RConsole.println("isStalled="+isStalled);
-         dos.writeBoolean(isStalled);
-         dos.flush();
-         break;
-         
-      }
-
-      case GET_ROTATION_SPEED: {
-         RConsole.println("GET_ROTATION_SPEED");
-         speed = motor.getRotationSpeed();
-         RConsole.println("speed="+speed);
-         dos.writeInt(speed);
-         dos.flush();
-         break;
-      }
-
-      case GET_MAX_SPEED: {
-         RConsole.println("GET_MAX_SPEED");
-         maxSpeed = motor.getMaxSpeed();
-         RConsole.println("maxSpeed="+maxSpeed);
-         dos.writeFloat(maxSpeed);
-         dos.flush();
-         break;
-         
-      }
-      case ADD_LISTENER: {
-         motor.addListener(this);
-      //   if (listenersCon==null){
-         //   connectionThread connect=new connectionThread();
-         //   connect.start();
-      //   }
-         
-         
-         break;
-         
-      }
-      
-      
-      case SUSPEND_REGULATION: {
-         boolean suspended;
-         RConsole.println("SUSPEND_REGULATION");
-         suspended=motor.suspendRegulation();
-         dos.writeBoolean(suspended);
-         dos.flush();
-         break;
-         
-      }
-      }
-
-   }
-
-   protected NXTRegulatedMotor getMotor(int id) {
-
-      switch (id) {
-      case 1:
-         return A;
-
-      case 2:
-         return B;
-
-      case 3:
-         return C;
-
-      }
-
-      return null;
-
-   }   
-   protected int getMotor(RegulatedMotor motor) {
-
-      if(motor.equals(Motor.A))
-         return 1;
-      else  if(motor.equals(Motor.B))
-         return 2;
-      else  if(motor.equals(Motor.C))
-         return 3;
-      
-      return -1;
-   }
-
-   public void run() {
-
-      while (true) {
-         
-         // Wait for connection if not connected
-         if (con == null) {
-            LCD.drawString("waiting", 0, 2);
-
-            connector = RS485.getConnector();
-            con = connector.waitForConnection(0, NXTConnection.RAW);
-
-            if (con != null) {
-               dis = con.openDataInputStream();
-               dos = con.openDataOutputStream();
-            }
-            LCD.drawString("Connected", 0, 2);
-            LCD.refresh();
-         }
-         
-         try {
-            id = dis.readInt();
-            command = dis.readInt();
-            RConsole.println("id="+id +"command =" +command);
-            executeCommand(id, command);
-
-         } catch (IOException e) {
-         //A.stop();
-         //B.stop();
-            //con.close();
-            //con = null;
-            //e.printStackTrace();
-         }
-
-      
-   
-      }
-}
-   @Override
-   public void rotationStarted(RegulatedMotor motor, int tachoCount, boolean stalled,
-         long timeStamp) {
-      
-//      try {
-//         
-//         int id=getMotor( motor);
-//         lisdos.writeInt(id);
-//         lisdos.writeInt(ROTATION_STARTED);
-//         lisdos.writeInt(tachoCount);
-//         lisdos.writeBoolean(stalled);
-//         lisdos.writeLong(timeStamp);
-//         lisdos.flush();
-//      } catch (IOException e) {
-//         // TODO Auto-generated catch block
-//         e.printStackTrace();
-      }
-      
-   
-   @Override
-   public void rotationStopped(RegulatedMotor motor, int tachoCount, boolean stalled,
-         long timeStamp) {
-      
-//try {
-//         
-//         int id=getMotor(motor);
-//         lisdos.writeInt(id);
-//         lisdos.writeInt(ROTATION_STOPPED);
-//         lisdos.writeInt(tachoCount);
-//         lisdos.writeBoolean(stalled);
-//         lisdos.writeLong(timeStamp);
-//         lisdos.flush();
-//      } catch (IOException e) {
-//         // TODO Auto-generated catch block
-//         e.printStackTrace();
-//      }
-         
-   }
-   
-//   public class connectionThread extends Thread {
-//      
-//      public void run(){
-//   
-//         // Wait for connection if not connected
-//         if (listenersCon == null) {
-//            LCD.drawString("waiting", 0, 2);
-//
-//            connector = RS485.getConnector();
-//            listenersCon = connector.waitForConnection(0, NXTConnection.RAW);
-//
-//            if (con != null) {
-//               lisdis = con.openDataInputStream();
-//               lisdos = con.openDataOutputStream();
-//            }
-//            LCD.drawString("Connected", 0, 2);
-//            LCD.refresh();
-//         }
-//}
-//   }
-   
-   }
\ No newline at end of file
diff --git a/src/utilities/Responder.java b/src/utilities/Responder.java
deleted file mode 100644
index b34a4ec..0000000
--- a/src/utilities/Responder.java
+++ /dev/null
@@ -1,60 +0,0 @@
-package utilities;
-
-import lejos.nxt.LCD;
-import lejos.nxt.MotorPort;
-import lejos.nxt.comm.Bluetooth;
-import lejos.nxt.comm.LCPResponder;
-import lejos.nxt.comm.NXTCommConnector;
-import lejos.nxt.comm.NXTConnection;
-import lejos.nxt.comm.RConsole;
-import lejos.nxt.comm.RS485;
-
-/**
- * The responder class responds to the LCP requests sent by the Communicator.java class. 
- * Uses by default Bluetooth.
- * 
- * Slight modification for LeJOS samples
- * <p> 
- * @author Andy Shaw
- * @author danielle
- * 
- */
-public class Responder {
-	
-	/**
-	 * The subclass that handles the LCP connections. In particular, it is modified version of the LCPResponder to shutdown the connection once the program disconnects.
-	 * @author Andy Shaw
-	 * @author danielle
-	 *
-	 */
-	public static class ResponderTool extends LCPResponder {
-		ResponderTool(NXTCommConnector con) {
-            super(con);
-        }
-
-         protected void disconnect() {
-            super.disconnect();
-            super.shutdown();
-        }
-	}
-	
-	/**
-	 * This program has a main as it is to be loaded on the slaveNXT brick. Has
-	 * almost no functionality otherwise.
-	 * <p>
-	 * @param args
-	 *            This is the default constructor, not needed.
-	 */
-	
-	public static void main(String[] args) throws Exception {
-		//RConsole.openUSB(20000);
-		LCD.drawString("Connecting", 1, 1);
-		//ResponderTool resp = new ResponderTool(RS485.getConnector());
-		//resp.start();
-		//resp.join();
-		NXTRemoteMotorControl motorControl = new NXTRemoteMotorControl(MotorPort.A, MotorPort.B, MotorPort.C);
-		motorControl.start();
-		
-    }
-	
-}
\ No newline at end of file
diff --git a/src/utilities/Settings.java b/src/utilities/Settings.java
index 3105a3f..ecb6085 100644
--- a/src/utilities/Settings.java
+++ b/src/utilities/Settings.java
@@ -1,30 +1,33 @@
 package utilities;
 
+import hardwareAbstraction.NXTRemoteCommand;
+import hardwareAbstraction.NXTRemoteMotor;
 import lejos.nxt.ColorSensor;
 import lejos.nxt.Motor;
 import lejos.nxt.NXTRegulatedMotor;
 import lejos.nxt.SensorPort;
 import lejos.nxt.UltrasonicSensor;
-import lejos.nxt.remote.RemoteMotor;
 
 public class Settings {
 
+	private static Communicator com = new Communicator("NXT");
 	
+	private static NXTRemoteCommand motorCommand = new NXTRemoteCommand(com);
 	
 	public static ColorSensor frontColorSensor = new ColorSensor(SensorPort.S1);
 	public static ColorSensor rearLeftColorSensor = new ColorSensor(SensorPort.S2);
 	public static ColorSensor rearRightColorSensor = new ColorSensor(SensorPort.S3);
 	
-	public static UltrasonicSensor leftUltrasonic;
-	public static UltrasonicSensor centerUltrasonic;
-	public static UltrasonicSensor rightUltrasonic;
+//	public static UltrasonicSensor leftUltrasonic;
+//	public static UltrasonicSensor centerUltrasonic;
+//	public static UltrasonicSensor rightUltrasonic;
 	
 	public static NXTRegulatedMotor leftDriveMotor = Motor.B;
 	public static NXTRegulatedMotor rightDriveMotor = Motor.A;
 	
-	public static RemoteMotor forkliftMotor;
-	public static RemoteMotor ultrasonicMotor;
-	public static RemoteMotor clawMotor;
+	public static NXTRemoteMotor clawMotor = new NXTRemoteMotor(motorCommand, 1);
+	public static NXTRemoteMotor ultrasonicMotor = new NXTRemoteMotor(motorCommand, 2);
+	public static NXTRemoteMotor liftMotor = new NXTRemoteMotor(motorCommand, 3);
 	
 	public static final String NXTSlaveName = "NXT";
 	

commit 156585e8cccd4f6a70ef7e9943c49e7a19d09df3
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Fri Nov 22 16:00:11 2013 -0500

    Formatted the code.

diff --git a/src/hardwareAbstraction/NXTRemoteMotor.java b/src/hardwareAbstraction/NXTRemoteMotor.java
index 6e01414..d9005e6 100644
--- a/src/hardwareAbstraction/NXTRemoteMotor.java
+++ b/src/hardwareAbstraction/NXTRemoteMotor.java
@@ -6,243 +6,237 @@ import lejos.nxt.comm.RConsole;
 import lejos.robotics.RegulatedMotor;
 import lejos.robotics.RegulatedMotorListener;
 
-public class NXTRemoteMotor implements RemoteCommands, RegulatedMotor{
-	   
-	   
-
-    private int id;
-
-    private NXTRemoteCommand  motorCommand;
-  
-  //  private ListenerConnection listenerConnection=null;
-
-    public  NXTRemoteMotor(NXTRemoteCommand nxtCommand, int id){
-       
-        this.id = id;
-        this.motorCommand=nxtCommand;
-         //this.listenerConnection=listenersConnection;
-    }
-    
- 
-    public boolean suspendRegulation(){
-     boolean suspended=false;
-       motorCommand.send(id, SUSPEND_REGULATION);
-        try {
-           suspended=motorCommand.getBool();
-           
-        } catch (IOException e) {
-           // TODO Auto-generated catch block
-           e.printStackTrace();
-        }
-       
-    return suspended;
-    }
-@Override
-public void flt() {
-  RConsole.println("flt");
-  motorCommand.send(id, FLT);
-  
-}
-
-@Override
-public int getRotationSpeed() {
-  int speed=0;
-  RConsole.println("getRotationSpeed");
-  motorCommand.send(id, GET_ROTATION_SPEED);
-  try {
-     speed=motorCommand.getInt();
-     RConsole.println("speed="+speed);
-  } catch (IOException e) {
-     // TODO Auto-generated catch block
-     e.printStackTrace();
-  }
-  return speed;
-}
-
-@Override
-public int getTachoCount() {
-  RConsole.println("getTachoCount");
-  int tachoCount=0;
-  motorCommand.send(id, GET_TACHO_COUNT);
-  try {
-     tachoCount=motorCommand.getInt();
-     RConsole.println("tachoCount="+tachoCount);
-  } catch (IOException e) {
-     // TODO Auto-generated catch block
-     e.printStackTrace();
-  }
-  return tachoCount;
-}
-
-@Override
-public void resetTachoCount() {
-  RConsole.println("resetTachoCount");
-  motorCommand.send(id, RESET_TACHO_COUNT);
-  
-}
-
-@Override
-public int getLimitAngle() {
-  RConsole.println("getLimitAngle");
-  
-  int angle=0;
-  motorCommand.send(id, GET_LIMIT_ANGLE);
-  try {
-     angle=motorCommand.getInt();
-     RConsole.println("angle="+angle);
-  } catch (IOException e) {
-     // TODO Auto-generated catch block
-     e.printStackTrace();
-  }
-  return angle;
-}
-
-@Override
-public float getMaxSpeed() {
-  RConsole.println("getMaxSpeed=");
-  float speed=0;
-  motorCommand.send(id,GET_MAX_SPEED);
-  try {
-     speed=motorCommand.getFloat();
-     RConsole.println("speed="+speed);
-  } catch (IOException e) {
-     // TODO Auto-generated catch block
-     e.printStackTrace();
-  }
-  return speed;
-}
-
-@Override
-public int getSpeed() {
-  RConsole.println("getSpeed=");
-  int speed=0;
-  motorCommand.send(id, GET_SPEED);
-  try {
-     speed=motorCommand.getInt();
-     RConsole.println("speed="+speed);
-  } catch (IOException e) {
-     // TODO Auto-generated catch block
-     e.printStackTrace();
-  }
-  return speed;
-}
-
-@Override
-public boolean isStalled() {
-  RConsole.println("isStalled");
-  boolean isStalled=false;
-  motorCommand.send(id, IS_STALLED);
-  try {
-     isStalled=motorCommand.getBool();
-     RConsole.println("isStalled="+isStalled);
-  } catch (IOException e) {
-     // TODO Auto-generated catch block
-     e.printStackTrace();
-  }
-  return isStalled;
-
-}
-
-@Override
-public void rotate(int angle) {
-  RConsole.println("rotate");
-  motorCommand.send(id, ROTATE, angle, false);
-  
-}
-
-@Override
-public void rotate(int angle, boolean immediateReturn) {
-  RConsole.println("rotate");
-  motorCommand.send(id, ROTATE, angle, immediateReturn);
-  
-}
-
-@Override
-public void rotateTo(int angle) {
-  RConsole.println("rotateTo");
-  motorCommand.send(id, ROTATE_TO, angle, false);
-}
-
-@Override
-public void rotateTo(int angle, boolean immediateReturn) {
-  motorCommand.send(id, ROTATE_TO, angle, immediateReturn);
-}
+public class NXTRemoteMotor implements RemoteCommands, RegulatedMotor {
+
+	private int id;
+
+	private NXTRemoteCommand motorCommand;
+
+	// private ListenerConnection listenerConnection=null;
+
+	public NXTRemoteMotor(NXTRemoteCommand nxtCommand, int id) {
+
+		this.id = id;
+		this.motorCommand = nxtCommand;
+		// this.listenerConnection=listenersConnection;
+	}
+
+	public boolean suspendRegulation() {
+		boolean suspended = false;
+		motorCommand.send(id, SUSPEND_REGULATION);
+		try {
+			suspended = motorCommand.getBool();
+
+		} catch (IOException e) {
+			// TODO Auto-generated catch block
+			e.printStackTrace();
+		}
+
+		return suspended;
+	}
+
+	@Override
+	public void flt() {
+		RConsole.println("flt");
+		motorCommand.send(id, FLT);
+
+	}
+
+	@Override
+	public int getRotationSpeed() {
+		int speed = 0;
+		RConsole.println("getRotationSpeed");
+		motorCommand.send(id, GET_ROTATION_SPEED);
+		try {
+			speed = motorCommand.getInt();
+			RConsole.println("speed=" + speed);
+		} catch (IOException e) {
+			// TODO Auto-generated catch block
+			e.printStackTrace();
+		}
+		return speed;
+	}
+
+	@Override
+	public int getTachoCount() {
+		RConsole.println("getTachoCount");
+		int tachoCount = 0;
+		motorCommand.send(id, GET_TACHO_COUNT);
+		try {
+			tachoCount = motorCommand.getInt();
+			RConsole.println("tachoCount=" + tachoCount);
+		} catch (IOException e) {
+			// TODO Auto-generated catch block
+			e.printStackTrace();
+		}
+		return tachoCount;
+	}
+
+	@Override
+	public void resetTachoCount() {
+		RConsole.println("resetTachoCount");
+		motorCommand.send(id, RESET_TACHO_COUNT);
+
+	}
+
+	@Override
+	public int getLimitAngle() {
+		RConsole.println("getLimitAngle");
+
+		int angle = 0;
+		motorCommand.send(id, GET_LIMIT_ANGLE);
+		try {
+			angle = motorCommand.getInt();
+			RConsole.println("angle=" + angle);
+		} catch (IOException e) {
+			// TODO Auto-generated catch block
+			e.printStackTrace();
+		}
+		return angle;
+	}
+
+	@Override
+	public float getMaxSpeed() {
+		RConsole.println("getMaxSpeed=");
+		float speed = 0;
+		motorCommand.send(id, GET_MAX_SPEED);
+		try {
+			speed = motorCommand.getFloat();
+			RConsole.println("speed=" + speed);
+		} catch (IOException e) {
+			// TODO Auto-generated catch block
+			e.printStackTrace();
+		}
+		return speed;
+	}
+
+	@Override
+	public int getSpeed() {
+		RConsole.println("getSpeed=");
+		int speed = 0;
+		motorCommand.send(id, GET_SPEED);
+		try {
+			speed = motorCommand.getInt();
+			RConsole.println("speed=" + speed);
+		} catch (IOException e) {
+			// TODO Auto-generated catch block
+			e.printStackTrace();
+		}
+		return speed;
+	}
+
+	@Override
+	public boolean isStalled() {
+		RConsole.println("isStalled");
+		boolean isStalled = false;
+		motorCommand.send(id, IS_STALLED);
+		try {
+			isStalled = motorCommand.getBool();
+			RConsole.println("isStalled=" + isStalled);
+		} catch (IOException e) {
+			// TODO Auto-generated catch block
+			e.printStackTrace();
+		}
+		return isStalled;
+
+	}
+
+	@Override
+	public void rotate(int angle) {
+		RConsole.println("rotate");
+		motorCommand.send(id, ROTATE, angle, false);
+
+	}
+
+	@Override
+	public void rotate(int angle, boolean immediateReturn) {
+		RConsole.println("rotate");
+		motorCommand.send(id, ROTATE, angle, immediateReturn);
+
+	}
+
+	@Override
+	public void rotateTo(int angle) {
+		RConsole.println("rotateTo");
+		motorCommand.send(id, ROTATE_TO, angle, false);
+	}
+
+	@Override
+	public void rotateTo(int angle, boolean immediateReturn) {
+		motorCommand.send(id, ROTATE_TO, angle, immediateReturn);
+	}
+
+	@Override
+	public void setAcceleration(int accel) {
+
+		motorCommand.send(id, SET_ACCELERATION, accel);
+
+	}
+
+	@Override
+	public void setSpeed(int speed) {
+		RConsole.println("setSpeed " + speed);
+		motorCommand.send(id, SET_SPEED, speed);
+
+	}
+
+	@Override
+	public void backward() {
+		motorCommand.send(id, BACKWARD);
+
+	}
+
+	@Override
+	public void forward() {
+
+		motorCommand.send(id, FORWARD);
+
+	}
+
+	@Override
+	public boolean isMoving() {
+		RConsole.println("isMoving=");
+
+		boolean isMoving = false;
+		motorCommand.send(id, IS_MOVING);
+		try {
+			isMoving = motorCommand.getBool();
+			RConsole.println("isMoving=" + isMoving);
+		} catch (IOException e) {
+			// TODO Auto-generated catch block
+			e.printStackTrace();
+		}
+		return isMoving;
+	}
+
+	@Override
+	public void stop() {
+		motorCommand.send(id, STOP);
+
+	}
+
+	@Override
+	public void addListener(RegulatedMotorListener arg0) {
+		// TODO Auto-generated method stub
 
-@Override
-public void setAcceleration(int accel) {
+	}
 
-  motorCommand.send(id, SET_ACCELERATION, accel);
-  
-}
+	@Override
+	public void flt(boolean arg0) {
+		// TODO Auto-generated method stub
 
-@Override
-public void setSpeed(int speed) {
-  RConsole.println("setSpeed " +speed);
-  motorCommand.send(id, SET_SPEED, speed);
-  
-}
+	}
 
-@Override
-public void backward() {
-  motorCommand.send(id, BACKWARD);
-  
-}
+	@Override
+	public void stop(boolean arg0) {
+		// TODO Auto-generated method stub
 
-@Override
-public void forward() {
-  
-  motorCommand.send(id, FORWARD);
-  
-}
-
-@Override
-public boolean isMoving() {
-  RConsole.println("isMoving=");
-  
-  boolean isMoving=false;
-  motorCommand.send(id, IS_MOVING);
-  try {
-     isMoving=motorCommand.getBool();
-     RConsole.println("isMoving="+isMoving);
-  } catch (IOException e) {
-     // TODO Auto-generated catch block
-     e.printStackTrace();
-  }
-  return isMoving;
-}
-
-@Override
-public void stop() {
-  motorCommand.send(id, STOP);
-  
-}
+	}
 
+	@Override
+	public void waitComplete() {
+		// TODO Auto-generated method stub
 
-@Override
-public void addListener(RegulatedMotorListener arg0) {
-	// TODO Auto-generated method stub
-	
-}
-
-
-@Override
-public void flt(boolean arg0) {
-	// TODO Auto-generated method stub
-	
-}
-
-
-@Override
-public void stop(boolean arg0) {
-	// TODO Auto-generated method stub
-	
-}
-
-
-@Override
-public void waitComplete() {
-	// TODO Auto-generated method stub
-	
-}
+	}
 
 }

commit 29b192bfbe4c3b20ce2ab89e9833806dc69523b1
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Fri Nov 22 15:55:05 2013 -0500

    Small changes.

diff --git a/src/hardwareAbstraction/RemoteUltrasonicPoller.java b/src/hardwareAbstraction/RemoteUltrasonicPoller.java
index 3645c47..7de0ef7 100644
--- a/src/hardwareAbstraction/RemoteUltrasonicPoller.java
+++ b/src/hardwareAbstraction/RemoteUltrasonicPoller.java
@@ -15,7 +15,8 @@ import manager.Manager;
  * polling of that sensor
  * <p>
  * 
- * @author danielle, Riley
+ * @author Danielle
+ * @author Riley
  */
 public class RemoteUltrasonicPoller implements TimerListener {
 	private UltrasonicSensor[] us = new UltrasonicSensor[3];
diff --git a/src/utilities/Communicator.java b/src/utilities/Communicator.java
index f188b23..2d7d0e3 100644
--- a/src/utilities/Communicator.java
+++ b/src/utilities/Communicator.java
@@ -14,7 +14,8 @@ import lejos.nxt.comm.NXTConnection;
  * it. Only uses the motor and the ultrasonicSensors on the other NXT as it is
  * impossible to initialize a ColorSensor on the remote NXT.
  * <p>
- * @author danielle
+ * @author Danielle Mustillo
+ * @author Riley
  * 
  */
 public class Communicator {

commit c9acf0d25e685bd8efb1b5a974466543f9120204
Merge: 66a6f76 d51db9d
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Fri Nov 22 15:40:57 2013 -0500

    Merge branch 'master' of https://github.com/danielle-mustillo/ECSE-211-Team-5.git

commit 66a6f7694b8be5308bc0baa5236dea0f7ef320fc
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Fri Nov 22 15:40:46 2013 -0500

    Added the commit log to the repo. Will be updated.

diff --git a/logNov20.txt b/logNov20.txt
new file mode 100644
index 0000000..bc9ffb8
--- /dev/null
+++ b/logNov20.txt
@@ -0,0 +1,1210 @@
+commit bf304c3d58ccecc9d58d04a79e26386d0abf468c
+Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
+Date:   Wed Nov 20 16:05:04 2013 -0500
+
+    Finished testing the collect sequence. There is a concurrency error in
+    the forklift motors for the moment. Code will be written to stop this.
+
+ src/controllers/Recognize.java        | 11 -----------
+ src/hardwareAbstraction/Forklift.java |  5 +++--
+ src/launcher/Launcher.java            |  9 +++++++++
+ src/services/Navigation.java          |  7 ++++---
+ 4 files changed, 16 insertions(+), 16 deletions(-)
+
+commit e732830bec5fdfaf1e39c3fcd89dce1aa705e49a
+Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
+Date:   Wed Nov 20 03:22:22 2013 -0500
+
+    Small change to UltrasonicMotor that was not done earlier. This should
+    avoid thrown exceptions.
+
+ src/hardwareAbstraction/UltrasonicMotor.java | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+commit 66ff60a38bd2f6c5abba56b4f2a3072123d3e3ca
+Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
+Date:   Wed Nov 20 03:19:44 2013 -0500
+
+    Cleaned up and fixed potential bugs in Recognize and Collect classes.
+    Added constant value to Settings
+
+ src/controllers/Collect.java   |  60 ++++++++++---
+ src/controllers/Recognize.java | 185 +++++++++++------------------------------
+ src/utilities/Settings.java    |   2 +
+ 3 files changed, 98 insertions(+), 149 deletions(-)
+
+commit d81a7742e464bc4a921441aba65d0a2656faefed
+Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
+Date:   Wed Nov 20 03:18:50 2013 -0500
+
+    Corrected small annotation in position.
+
+ src/utilities/Position.java | 4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+commit d1c84822e8eb0fc9c6794f1d2a683fd3e8a7f5b0
+Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
+Date:   Wed Nov 20 02:31:11 2013 -0500
+
+    Created a prototype for the Search, Recognize and Collect sequence.
+    Needs heavy debugging.
+
+ src/controllers/Collect.java          | 18 ++++++------
+ src/controllers/Recognize.java        | 55 +++++++++++++++++++++++++----------
+ src/controllers/Search.java           |  4 +--
+ src/hardwareAbstraction/Forklift.java |  2 +-
+ src/launcher/Launcher.java            | 14 +++++++--
+ src/services/Navigation.java          | 33 ++++++++++++++-------
+ 6 files changed, 85 insertions(+), 41 deletions(-)
+
+commit e331ce0e6c8e695217f7f676e3df24fbe10fe2d5
+Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
+Date:   Tue Nov 19 22:16:02 2013 -0500
+
+    Debugged the claw and ultrasonic motors. They should work relatively ok
+    now. The code should be changed to reflect the new mechanism.
+
+ src/hardwareAbstraction/Claw.java            | 12 ++++++++----
+ src/hardwareAbstraction/UltrasonicMotor.java | 14 +++++++++-----
+ 2 files changed, 17 insertions(+), 9 deletions(-)
+
+commit 6600b413afc80236c687f045e18557726b8c964e
+Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
+Date:   Tue Nov 19 22:02:01 2013 -0500
+
+    Forklift debugged, now it should work consistently and rotate to the
+    right height.
+
+ src/hardwareAbstraction/Forklift.java | 135 ++++++++++++++++++----------------
+ 1 file changed, 73 insertions(+), 62 deletions(-)
+
+commit 84ffe627c9cf4f1e46c94829356d7bedb76b647f
+Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
+Date:   Tue Nov 19 19:56:54 2013 -0500
+
+    Added a useful method in colorPoller to allow Recognize.java to work.
+    Also added a supporting enum.
+
+ src/hardwareAbstraction/ColorPoller.java | 10 +++++++++-
+ 1 file changed, 9 insertions(+), 1 deletion(-)
+
+commit 41dd7c90103f2cecdcbe9902d5915f48a48aeb56
+Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
+Date:   Tue Nov 19 19:56:21 2013 -0500
+
+    Changed the Recognize.java to work with the newly mounted colorsensor.
+    Removed the ultrasonic logic which was overly complicated for the
+    moment.
+
+ src/controllers/Recognize.java | 173 ++++++++++++++++++++++++-----------------
+ 1 file changed, 103 insertions(+), 70 deletions(-)
+
+commit f5f119211e64ffc4479c35f35bd69d3b653ffdac
+Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
+Date:   Tue Nov 19 19:52:50 2013 -0500
+
+    The Launcher is modified to test the scanning function in navigation.
+
+ src/launcher/Launcher.java | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+commit 645b97a6d276cd718aa5ce2155f8e35d303a5b15
+Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
+Date:   Tue Nov 19 19:52:17 2013 -0500
+
+    Worked on fixing the object detection and scan ahead algorithm. Should
+    scan ahead. May not work however. Needs to be tested.
+
+ src/services/Navigation.java | 44 +++++++++++++++++++++++++++++---------------
+ 1 file changed, 29 insertions(+), 15 deletions(-)
+
+commit bf2777f732923f5b2b055b979a062a0f67106bb8
+Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
+Date:   Tue Nov 19 19:15:13 2013 -0500
+
+    Created a useful method in ultrasonic poller to determine which
+    ultrasonic  poller is the lowest value. Will be used to orient robot
+    towards that.
+
+ src/hardwareAbstraction/UltrasonicPoller.java | 39 +++++++++++++++++++++++++++
+ 1 file changed, 39 insertions(+)
+
+commit f3bec86902bd8479f1caa3375e9f5be65715600e
+Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
+Date:   Tue Nov 19 18:25:57 2013 -0500
+
+    Few bug fixes for navigation.
+
+ src/services/Navigation.java | 115 ++++++++++++++++++++++++-------------------
+ 1 file changed, 64 insertions(+), 51 deletions(-)
+
+commit 29197f9ea4d2a27043f069b9f042dc92ad8204ee
+Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
+Date:   Tue Nov 19 15:35:41 2013 -0500
+
+    Fixed an issue with the external motors timing out. The robot now grabs
+    an object and lifts it. However, no intelligence has been provided to
+    find when it must lift.
+
+ src/hardwareAbstraction/UltrasonicMotor.java | 14 +++--
+ src/launcher/Launcher.java                   | 16 +++---
+ src/services/Navigation.java                 | 78 +++++++++++++++++-----------
+ 3 files changed, 66 insertions(+), 42 deletions(-)
+
+commit 1e699c0f83591abbce87aee184d949a66aa33402
+Author: RileyvanRyswyk <rileyvan@gmail.com>
+Date:   Tue Nov 19 12:07:15 2013 -0500
+
+    Odo Correction Test
+
+ src/launcher/Launcher.java | 20 ++++++++++++++++----
+ 1 file changed, 16 insertions(+), 4 deletions(-)
+
+commit ee59ffecf9ce7b473e330decb705ada07166d903
+Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
+Date:   Mon Nov 18 13:26:14 2013 -0500
+
+    Made small change to Navigation, hopefully to implement scanAhead
+    properly.
+
+ src/services/Navigation.java | 21 ++++++++++++++++-----
+ 1 file changed, 16 insertions(+), 5 deletions(-)
+
+commit 4e13809cb1812ca4cbb891d5b6342411102bb563
+Author: RileyvanRyswyk <rileyvan@gmail.com>
+Date:   Mon Nov 18 10:09:42 2013 -0500
+
+    Odometry Correction Update
+    
+    Should fix the problem of not correcting after missing a line.
+
+ src/services/OdometryCorrection.java | 8 ++++----
+ 1 file changed, 4 insertions(+), 4 deletions(-)
+
+commit facbcfce8a7921ceb53f0d77b9e936b6167aa9a7
+Author: RileyvanRyswyk <rileyvan@gmail.com>
+Date:   Sun Nov 17 17:05:30 2013 -0500
+
+    Odometry Correction
+    
+    Ultrasonic Poller Stop fix.
+    Removed beeping from line poller
+
+ src/hardwareAbstraction/LinePoller.java       |   2 +-
+ src/hardwareAbstraction/UltrasonicPoller.java |   1 +
+ src/services/Navigation.java                  |   7 +-
+ src/services/OdometryCorrection.java          | 210 +++++++++++++++++++++++++-
+ src/utilities/Point.java                      |   4 +
+ src/utilities/Settings.java                   |   3 +
+ 6 files changed, 222 insertions(+), 5 deletions(-)
+
+commit 281e6b4abcacadfb12dcd4ef21d35e7f041db721
+Author: RileyvanRyswyk <rileyvan@gmail.com>
+Date:   Sun Nov 17 13:52:10 2013 -0500
+
+    Line Localization now Works
+    
+    Ultrasonic Poller fixed for localization
+    Adjusted Navigation speed
+
+ src/controllers/State.java                    |  2 +-
+ src/hardwareAbstraction/LinePoller.java       |  8 ++--
+ src/hardwareAbstraction/UltrasonicPoller.java | 51 +++++++++++++++---------
+ src/manager/ControllerManager.java            |  2 +-
+ src/manager/HardwareManager.java              |  2 +-
+ src/manager/UtilityManager.java               | 14 +++++++
+ src/services/Localization.java                | 57 +++++++++------------------
+ src/services/Navigation.java                  |  6 +--
+ 8 files changed, 75 insertions(+), 67 deletions(-)
+
+commit e0d057d387a2f43f053f47920476ab359346e2a0
+Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
+Date:   Sat Nov 16 13:38:57 2013 -0500
+
+    Cleaned up some items on Search, collect, dropoff and recognize.
+    Prepared for future changes.
+
+ src/controllers/Collect.java   | 10 +++++++++-
+ src/controllers/DropOff.java   |  4 +++-
+ src/controllers/Recognize.java | 20 ++++++++++----------
+ src/controllers/Search.java    |  3 ++-
+ 4 files changed, 24 insertions(+), 13 deletions(-)
+
+commit d4829f57ed2627f89ca0c6be03bff2e2e26c5977
+Author: RileyvanRyswyk <rileyvan@gmail.com>
+Date:   Fri Nov 15 21:57:35 2013 -0500
+
+    Localization Tweaks
+
+ src/services/Localization.java | 12 ++----------
+ 1 file changed, 2 insertions(+), 10 deletions(-)
+
+commit 5325f7fdf52a6a69a7b5650b0e97c8e08249a72d
+Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
+Date:   Fri Nov 15 18:43:38 2013 -0500
+
+    Cleaned up lingering commented-out code on UltrasonicPoller and
+    UltrasonicMotor. Added functionality to poll only one us at a time if
+    facing forward).
+
+ src/hardwareAbstraction/UltrasonicMotor.java  |  4 ++
+ src/hardwareAbstraction/UltrasonicPoller.java | 61 +++++++++++++--------------
+ 2 files changed, 33 insertions(+), 32 deletions(-)
+
+commit bb8646bdb8da84edf39a25b538daf0d7ca77bc34
+Author: RileyvanRyswyk <rileyvan@gmail.com>
+Date:   Fri Nov 15 12:19:58 2013 -0500
+
+    Navigation fixed
+    
+    Should remove or sufficiently eliminate oscillation.
+
+ src/services/Navigation.java | 14 +++++++++++---
+ 1 file changed, 11 insertions(+), 3 deletions(-)
+
+commit 528141f0fb1bfff8d078bc835168dde5b81d23e8
+Author: RileyvanRyswyk <rileyvan@gmail.com>
+Date:   Fri Nov 15 12:02:47 2013 -0500
+
+    LCD Info Fixes, Angle helper updated and localization tweaked
+
+ src/services/LCDInfo.java      | 3 ++-
+ src/services/Localization.java | 2 +-
+ src/utilities/Angle.java       | 4 ++++
+ 3 files changed, 7 insertions(+), 2 deletions(-)
+
+commit 4cf9c0c588bc4e8b2051134d63d1a41c8cb4796e
+Author: RileyvanRyswyk <rileyvan@gmail.com>
+Date:   Fri Nov 15 11:54:04 2013 -0500
+
+    LCD Info for odometer information
+
+ src/manager/ServiceManager.java |  2 ++
+ src/services/LCDInfo.java       | 39 +++++++++++++++++++++++++++++++++++++++
+ 2 files changed, 41 insertions(+)
+
+commit fc10fb18f8c7e39c04aa5f71afd20053903653ce
+Author: RileyvanRyswyk <rileyvan@gmail.com>
+Date:   Fri Nov 15 11:47:29 2013 -0500
+
+    Localization Fixs
+
+ src/launcher/Launcher.java     | 4 ++--
+ src/services/Localization.java | 2 +-
+ src/services/Navigation.java   | 2 ++
+ 3 files changed, 5 insertions(+), 3 deletions(-)
+
+commit 918cb39cd9474f1ae268e15203838ce2de8d7531
+Author: RileyvanRyswyk <rileyvan@gmail.com>
+Date:   Fri Nov 15 11:38:28 2013 -0500
+
+    Forklift Simplications (incl delay) and other tweaks
+
+ src/controllers/Recognize.java           |  6 +--
+ src/hardwareAbstraction/Forklift.java    | 65 +++++++++++++++++++++-----------
+ src/launcher/Launcher.java               | 25 ++++++------
+ src/manager/UtilityManager.java          |  2 +-
+ src/services/Localization.java           |  8 +++-
+ src/services/Navigation.java             | 12 +++---
+ src/utilities/BluetoothTransmission.java |  8 ++++
+ src/utilities/Settings.java              |  2 +-
+ 8 files changed, 82 insertions(+), 46 deletions(-)
+
+commit 25f77012c64038cda152ca7bd4f435088c831fb8
+Author: RileyvanRyswyk <rileyvan@gmail.com>
+Date:   Fri Nov 15 10:18:00 2013 -0500
+
+    Updated Bluetooth (Attempt 3)
+
+ src/controllers/Recognize.java           | 21 +++++++++++++++++++++
+ src/hardwareAbstraction/Forklift.java    |  2 +-
+ src/manager/UtilityManager.java          |  4 ++--
+ src/utilities/BluetoothTransmission.java | 19 +++++++++++++------
+ src/utilities/Settings.java              |  2 +-
+ 5 files changed, 38 insertions(+), 10 deletions(-)
+
+commit a6c76c1b3e08cb4e9cc190029b33b162f679ad5d
+Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
+Date:   Fri Nov 15 02:13:32 2013 -0500
+
+    Added some comments for Recognize.java. Should be more readable now.
+    Also removed useless logic where appropriate.
+
+ src/controllers/Recognize.java | 68 +++++++++++++++++++++---------------------
+ 1 file changed, 34 insertions(+), 34 deletions(-)
+
+commit 07aa23c6bccf13a12fafe392f1f95ee7ce3b129f
+Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
+Date:   Thu Nov 14 23:51:20 2013 -0500
+
+    The recognize function was worked on however it does not work at this
+    moment. Ultrasonic poller was cut down to one sensor for the moment.
+    Small changes in navigatio and controllerManager. Launcher was changed
+    to match the test.
+
+ src/controllers/Recognize.java                | 93 ++++++++++++++++++++++-----
+ src/controllers/State.java                    |  2 +-
+ src/hardwareAbstraction/UltrasonicPoller.java | 50 ++++++++------
+ src/launcher/Launcher.java                    |  7 +-
+ src/manager/ControllerManager.java            |  3 +-
+ src/services/Navigation.java                  | 16 ++---
+ 6 files changed, 122 insertions(+), 49 deletions(-)
+
+commit 3dd19573f6289fc505b5880a01c2d0d9e7a8f1f7
+Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
+Date:   Thu Nov 14 21:26:33 2013 -0500
+
+    Modified the code so we can conduct the Size View US Test
+
+ src/hardwareAbstraction/UltrasonicPoller.java | 17 +++++++++--------
+ src/launcher/Launcher.java                    | 16 ++++++++--------
+ 2 files changed, 17 insertions(+), 16 deletions(-)
+
+commit f61a524503fb37f3f723c6d2ca1fe4f3edd5a658
+Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
+Date:   Thu Nov 14 21:06:03 2013 -0500
+
+    Formatted USP class.
+
+ src/hardwareAbstraction/UltrasonicPoller.java | 168 ++++++++++++++------------
+ 1 file changed, 88 insertions(+), 80 deletions(-)
+
+commit 3e5922239188f0046bb685a946620088408bdf61
+Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
+Date:   Thu Nov 14 21:05:38 2013 -0500
+
+    Wrote useful method in ultrasonicPoller that will reset and check the
+    status of the USP.
+
+ src/hardwareAbstraction/UltrasonicPoller.java | 16 +++++++++++++++-
+ 1 file changed, 15 insertions(+), 1 deletion(-)
+
+commit 01fdd0dedc223159c29896fa39f7a397bc867fb5
+Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
+Date:   Thu Nov 14 21:00:06 2013 -0500
+
+    Modified forklift so the commands issued by other classes will always
+    work, regardless of the state of the forklift. Avoids errors later on.
+
+ src/hardwareAbstraction/Forklift.java | 47 ++++++++++++++++++++++++-----------
+ 1 file changed, 32 insertions(+), 15 deletions(-)
+
+commit 94ec2b4fa63a4f3f6f49efff9aa94e3448536b94
+Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
+Date:   Thu Nov 14 20:22:45 2013 -0500
+
+    The forklift will now be used to detect obstacles and blue blocks. The
+    method to do this is that it will go to a default height and detect the
+    objects in the range and compare that with the values at its default
+    height. The difference of these two will uniquely identify the obstacle.
+    This has all been documented elsewhere. The work done sofar on this
+    forklift is minimal just to allow this to happen. Also boolean
+    identifiers of the forklift current state was added for convenience.
+
+ src/hardwareAbstraction/Forklift.java | 43 ++++++++++++++++++++++++++++++++---
+ 1 file changed, 40 insertions(+), 3 deletions(-)
+
+commit bc18f99aa430374c78961962f40e4b31b5201aa1
+Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
+Date:   Thu Nov 14 20:20:09 2013 -0500
+
+    Began working on a search algorithm. Added a useful method in
+    ultrasonicPoller for the moment. The Navigation class was modified to
+    accomodate the Recogintion step.
+
+ src/controllers/Recognize.java                | 25 +++++++++++++++++++++++++
+ src/hardwareAbstraction/UltrasonicPoller.java | 22 +++++++++++++++-------
+ src/services/Navigation.java                  | 12 ++++++------
+ 3 files changed, 46 insertions(+), 13 deletions(-)
+
+commit af45e56805cf4653977bd560b9a396277a08232e
+Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
+Date:   Thu Nov 14 20:17:36 2013 -0500
+
+    Began an implementation of a scanning feature for the robot. The robot
+    side ultrasonic sensors should be able to move back and forward now.
+
+ src/hardwareAbstraction/UltrasonicMotor.java | 21 +++++++++++++++++++++
+ 1 file changed, 21 insertions(+)
+
+commit a5a8492f9ed48672ff5accdad528a8b61e45fded
+Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
+Date:   Thu Nov 14 20:16:14 2013 -0500
+
+    Created a default path for the robot to navigate around in its search
+    algorithm. Its a very primitive search algorithm.
+
+ src/controllers/Search.java | 2 ++
+ 1 file changed, 2 insertions(+)
+
+commit d335dd38db14aa73bac1ce7ea264c87a86209c86
+Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
+Date:   Thu Nov 14 20:15:27 2013 -0500
+
+    Started the implementation of a colorPoller detector system. May be used
+    or may be discarded.
+
+ src/hardwareAbstraction/ColorPoller.java | 42 +++++++++++++++++++++++++++++---
+ 1 file changed, 38 insertions(+), 4 deletions(-)
+
+commit c3ec89a3079843ce1a9ce755adfcec018c86a059
+Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
+Date:   Thu Nov 14 18:55:39 2013 -0500
+
+    Added some default ocations to head toduring dropoff. Small corrections
+    made to all the other classes. Test..
+
+ src/controllers/DropOff.java                  |  3 +--
+ src/controllers/Search.java                   |  2 +-
+ src/hardwareAbstraction/UltrasonicPoller.java |  3 ---
+ src/launcher/Launcher.java                    | 10 +++++-----
+ src/services/Navigation.java                  |  2 --
+ 5 files changed, 7 insertions(+), 13 deletions(-)
+
+commit 7b3cf99a3461d55088dc2093f3a69e2272347cb2
+Merge: 6c29f0a 361f8f7
+Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
+Date:   Thu Nov 14 17:38:29 2013 -0500
+
+    Merge branch 'master' of https://github.com/danielle-mustillo/ECSE-211-Team-5.git
+
+commit 6c29f0a1f8cd391ef0f3d0644ba3b0a5204e2436
+Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
+Date:   Thu Nov 14 17:38:16 2013 -0500
+
+    Made some forklift and ultrasonic changes
+
+ src/controllers/Search.java                   | 34 ++++++++++++++++++++++++++-
+ src/hardwareAbstraction/Claw.java             |  2 ++
+ src/hardwareAbstraction/Forklift.java         |  4 +++-
+ src/hardwareAbstraction/UltrasonicPoller.java |  3 ++-
+ 4 files changed, 40 insertions(+), 3 deletions(-)
+
+commit 361f8f75bf65d2cab45677f29902c5b049f726b7
+Author: RileyvanRyswyk <rileyvan@gmail.com>
+Date:   Thu Nov 14 17:37:39 2013 -0500
+
+    Line Poller Update
+
+ src/hardwareAbstraction/LinePoller.java | 26 ++++++++++++++++++++++++--
+ 1 file changed, 24 insertions(+), 2 deletions(-)
+
+commit 359586f154e3b41bc85c48ceada65a0b396ab06c
+Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
+Date:   Thu Nov 14 17:06:47 2013 -0500
+
+    Made a multi-threaded implementation of USPoller. Needs to be threaded
+    though.
+
+ src/hardwareAbstraction/UltrasonicPoller.java | 73 ++++++++++++++++++++-------
+ 1 file changed, 56 insertions(+), 17 deletions(-)
+
+commit 35b55ee360a2e4094f1859188631283d2364e6c4
+Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
+Date:   Thu Nov 14 03:36:16 2013 -0500
+
+    Added some intelligence to Dropoff.java. Should fix the issue with
+    Dropoff. The try-catch blocks in Collect were moved to the
+    hardwareAbstraction package.
+
+ src/controllers/Collect.java | 15 ++-----------
+ src/controllers/DropOff.java | 51 +++++++++++++++++++++++++++++++++-----------
+ src/utilities/Settings.java  |  2 +-
+ 3 files changed, 41 insertions(+), 27 deletions(-)
+
+commit e984d8dccec4055aebfb42e2476f96fb45726c94
+Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
+Date:   Thu Nov 14 03:34:49 2013 -0500
+
+    Added some useful methods in claw/forklift.java. Cleaned up some of the
+    code worked on today. Added annotations of locations where more work
+    must be done. @bug was used to in-code javadocs to explain the bugs in
+    different methods.
+
+ src/hardwareAbstraction/Claw.java     | 23 +++++++++++++++++++++--
+ src/hardwareAbstraction/Forklift.java | 24 ++++++++++++++++++++++--
+ src/services/Navigation.java          | 20 ++++++++++++--------
+ 3 files changed, 55 insertions(+), 12 deletions(-)
+
+commit ac607096bb6ead226732ac1abca38d71fe27a871
+Author: Nicole <witternicole@gmail.com>
+Date:   Wed Nov 13 22:44:45 2013 -0500
+
+    Heavy changes were made today. Collect and dropoff were modified to work
+    with the curent implementation of the hardware. Many lines of code were
+    commented out for the moment. ControllerMananger.java was modified to
+    start the state. Communicator.java had its remoteMotors modifeid to match
+    the hardware design. Launcher should work aswell. Robot currently
+    localizes and then moves to a location.
+
+ src/controllers/Collect.java          | 17 +++++++++++++++--
+ src/controllers/DropOff.java          |  3 ++-
+ src/hardwareAbstraction/Claw.java     |  2 +-
+ src/hardwareAbstraction/Forklift.java |  2 +-
+ src/launcher/Launcher.java            |  4 ++--
+ src/manager/ControllerManager.java    |  1 +
+ src/manager/Manager.java              |  4 ++--
+ src/utilities/Communicator.java       |  4 ++--
+ 8 files changed, 26 insertions(+), 11 deletions(-)
+
+commit ac0607d7c941679b0ab9eb11a01af307e1fefb13
+Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
+Date:   Wed Nov 13 21:33:46 2013 -0500
+
+    Got Navigation to work, working on localization and navigation
+    integration together.
+
+ src/launcher/Launcher.java     |   5 +-
+ src/services/Localization.java | 238 +++++++++++++++++++++--------------------
+ src/services/Navigation.java   |  18 ++--
+ 3 files changed, 136 insertions(+), 125 deletions(-)
+
+commit 7f7e7629b22fd1abf59d6fe4ec3fd72e21252ec8
+Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
+Date:   Wed Nov 13 20:46:29 2013 -0500
+
+    Added commentary.
+
+ src/services/Localization.java | 237 ++++++++++++++++++++---------------------
+ 1 file changed, 118 insertions(+), 119 deletions(-)
+
+commit c11fa239a249184cf521c2c720385f0e190b8663
+Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
+Date:   Wed Nov 13 20:29:58 2013 -0500
+
+    UltrasonicLocalization should work now. Ready to be tested.
+
+ src/services/Localization.java | 40 +++++++++++++++++++++++++++-------------
+ 1 file changed, 27 insertions(+), 13 deletions(-)
+
+commit 3eafe30fcb2e39576c334860d4abdf265e860525
+Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
+Date:   Wed Nov 13 20:29:29 2013 -0500
+
+    Added RConsole for debugging purposes. Seems to work fine for
+    localization.
+
+ src/launcher/Launcher.java | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+commit 90c407edf9cce581bdfaed686c73f638158728d0
+Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
+Date:   Wed Nov 13 20:29:02 2013 -0500
+
+    Fixed printing issue. Small bug fix.
+
+ src/hardwareAbstraction/UltrasonicPoller.java | 1 +
+ 1 file changed, 1 insertion(+)
+
+commit 897fefed57f5bf48bb5303bd793236002f17e3c8
+Author: RileyvanRyswyk <rileyvan@gmail.com>
+Date:   Wed Nov 13 15:58:24 2013 -0500
+
+    Updates
+    
+    Use LCD to debug.  Bluetooth is too laggy.  RS485 is now used again.
+    Minimum Ultrasonic poller period is about 100ms.  Started localization,
+    but it needs some work.
+
+ src/hardwareAbstraction/Drive.java            |  2 +
+ src/hardwareAbstraction/UltrasonicPoller.java | 44 ++++++++++++++----
+ src/launcher/Launcher.java                    |  4 +-
+ src/manager/Manager.java                      | 10 ++--
+ src/manager/ServiceManager.java               |  4 +-
+ src/services/HardwareViewer.java              |  2 +-
+ src/services/Localization.java                | 67 +++++++++++++++++++++------
+ src/utilities/Communicator.java               |  6 +--
+ src/utilities/Responder.java                  |  2 +-
+ src/utilities/Settings.java                   |  2 +-
+ 10 files changed, 105 insertions(+), 38 deletions(-)
+
+commit 63ee6c0d133ec17a274ab8b13218f129683122bb
+Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
+Date:   Mon Nov 11 15:49:35 2013 -0500
+
+    Updated ObstacleAvoidance.java method to scanAhead() method. It now
+    should work, pending a final revision. Added a helper method (and
+    documented it) in Position to allow scanAhead() to work. scan() still
+    needs work.
+
+ src/services/ObstacleAvoidance.java | 17 +++++++++++------
+ src/utilities/Position.java         | 24 +++++++++++++++++++++---
+ 2 files changed, 32 insertions(+), 9 deletions(-)
+
+commit 2b128aa900ec849229aacd0754ef2e84937d41db
+Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
+Date:   Mon Nov 11 14:30:27 2013 -0500
+
+    Updated the Point.java class with a useful getter.
+    ObstacleAvoidance.java has holes that were documented.
+
+ src/services/ObstacleAvoidance.java | 64 +++++++++++++++++++++++++++++--------
+ src/utilities/Point.java            |  5 +++
+ 2 files changed, 55 insertions(+), 14 deletions(-)
+
+commit 05f5ab2723d351e1e403731b086672f6eb360295
+Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
+Date:   Mon Nov 11 14:18:58 2013 -0500
+
+    Cleaned up some of the comments in Responder.java.
+
+ src/utilities/Responder.java | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+commit f20e37c7a34239dc75ab9c49d3779a37859eeab9
+Author: RileyvanRyswyk <rileyvan@gmail.com>
+Date:   Sun Nov 10 23:26:46 2013 -0500
+
+    NXT-NXT communicator fixes
+    
+    Also setup for localization debugging.
+
+ src/hardwareAbstraction/Drive.java |  6 +++---
+ src/launcher/Launcher.java         | 14 +-------------
+ src/manager/Manager.java           |  2 ++
+ src/manager/ServiceManager.java    |  5 +++++
+ src/services/HardwareViewer.java   |  8 +-------
+ src/services/Localization.java     | 34 +++++++++++++++++++---------------
+ src/services/Navigation.java       |  2 --
+ src/utilities/Communicator.java    | 13 ++++++++++---
+ src/utilities/Responder.java       | 19 ++++++++++---------
+ src/utilities/Settings.java        |  4 ++--
+ 10 files changed, 53 insertions(+), 54 deletions(-)
+
+commit be49c7f7613f231ef0c111b47ca0a9324a013c0f
+Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
+Date:   Sun Nov 10 16:27:31 2013 -0500
+
+    Collect and dropoff commentation updated.
+
+ src/controllers/Collect.java | 8 ++++++--
+ src/controllers/DropOff.java | 7 ++++++-
+ 2 files changed, 12 insertions(+), 3 deletions(-)
+
+commit 659e3d6d2e543ba22a1b253fe36ff6353048f06d
+Author: RileyvanRyswyk <rileyvan@gmail.com>
+Date:   Sun Nov 10 15:04:53 2013 -0500
+
+    CollerPoller fix
+
+ src/hardwareAbstraction/ColorPoller.java | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+commit 3ab0d7d26920be0fa4afec395a166ca7b6f8f8ed
+Author: RileyvanRyswyk <rileyvan@gmail.com>
+Date:   Sun Nov 10 13:45:04 2013 -0500
+
+    Navigation Fix
+
+ src/services/Navigation.java | 1 +
+ 1 file changed, 1 insertion(+)
+
+commit 16df0944d8d7a18b67f6ae2756d025cf829898e6
+Author: RileyvanRyswyk <rileyvan@gmail.com>
+Date:   Sun Nov 10 11:58:03 2013 -0500
+
+    Localization testing
+
+ src/launcher/Launcher.java     |  8 +++++++-
+ src/services/Localization.java |  4 +++-
+ src/services/Navigation.java   | 19 +++++++++++++++++--
+ src/utilities/Settings.java    |  2 +-
+ 4 files changed, 28 insertions(+), 5 deletions(-)
+
+commit 301d077c51f80203bf18ab7d3f5b4e4721064f50
+Author: RileyvanRyswyk <rileyvan@gmail.com>
+Date:   Sun Nov 10 11:24:40 2013 -0500
+
+    hardwareViewer export modification
+
+ src/services/HardwareViewer.java | 5 +----
+ 1 file changed, 1 insertion(+), 4 deletions(-)
+
+commit cd97374415c30da0728b24bd4e266d450e67c6db
+Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
+Date:   Sun Nov 10 01:34:26 2013 -0500
+
+    Developed further the collect and dropoff controllers. Needed to
+    implement a new state in order to avoid overlapping executions of a
+    single activity. Settings and Point were updated for convenience.
+    Navigation was updated to alter route.
+
+ src/controllers/Collect.java       | 10 ++++++++--
+ src/controllers/DropOff.java       | 16 ++++++++++++++++
+ src/controllers/State.java         |  2 +-
+ src/manager/ControllerManager.java | 12 ++++++++++++
+ src/services/Navigation.java       | 23 +++++++++++++++++++++--
+ src/utilities/Point.java           |  5 +++++
+ src/utilities/Settings.java        |  1 +
+ 7 files changed, 64 insertions(+), 5 deletions(-)
+
+commit d5026b78c0223fa049238190857dcd3b54542788
+Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
+Date:   Sun Nov 10 01:07:22 2013 -0500
+
+    Added bluetooth results in settings. Now it is globally accessible in a
+    logical place.
+
+ src/utilities/BluetoothTransmission.java | 31 +++++++++++++++++++------------
+ src/utilities/Settings.java              |  4 ++++
+ 2 files changed, 23 insertions(+), 12 deletions(-)
+
+commit d79fb5058e525f79ca39808f9bb95e18eed7f857
+Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
+Date:   Sun Nov 10 00:25:05 2013 -0500
+
+    Implemented simple collection logic. Maintains state. Still needs work
+    determining if "dropoff" or "search" must be called.
+
+ src/controllers/Collect.java          | 10 ++++++++++
+ src/controllers/State.java            |  5 +++++
+ src/hardwareAbstraction/Forklift.java | 16 ++++++++++++++--
+ 3 files changed, 29 insertions(+), 2 deletions(-)
+
+commit 9fb7aa62e35caa0606800423ed316e51bdeddbf9
+Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
+Date:   Sat Nov 9 23:55:42 2013 -0500
+
+    Made protoype of Claw and Forklift. Simple methods. Must be adjusted
+
+ src/hardwareAbstraction/Claw.java     | 12 ++++++++++++
+ src/hardwareAbstraction/Forklift.java | 13 ++++++++++++-
+ 2 files changed, 24 insertions(+), 1 deletion(-)
+
+commit fae15dc28906127ce7f66dee5ff3641950a31975
+Author: RileyvanRyswyk <rileyvan@gmail.com>
+Date:   Sat Nov 9 21:09:13 2013 -0500
+
+    Angle.java fixed
+    
+    Hopefully for the last time.
+
+ src/launcher/Launcher.java | 2 +-
+ src/utilities/Angle.java   | 7 ++++---
+ 2 files changed, 5 insertions(+), 4 deletions(-)
+
+commit a0b85abdb9b0aac9d971f8f66e5daa0256a49c94
+Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
+Date:   Sat Nov 9 20:58:04 2013 -0500
+
+    Created a ultrasonicPoller as per request from Riley. To be tested.
+    Prints to RConsole using bluetooth. To be removed when final project is
+    to be handed in.
+
+ src/hardwareAbstraction/LinePoller.java |  2 +-
+ src/manager/HardwareManager.java        |  3 --
+ src/manager/ServiceManager.java         |  2 +
+ src/services/HardwareViewer.java        | 80 +++++++++++++++++++++++++++++++++
+ 4 files changed, 83 insertions(+), 4 deletions(-)
+
+commit 5f1ee104eb0ca3cd18d420b1cfac92c7608693e7
+Author: RileyvanRyswyk <rileyvan@gmail.com>
+Date:   Sat Nov 9 20:24:11 2013 -0500
+
+    fixed angle class problem
+
+ src/utilities/Angle.java | 4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+commit 21fba8028fc3a49e7a54bb19030f5aa31e520e80
+Author: RileyvanRyswyk <rileyvan@gmail.com>
+Date:   Sat Nov 9 20:15:48 2013 -0500
+
+    Odo test
+
+ src/hardwareAbstraction/Drive.java | 2 +-
+ src/launcher/Launcher.java         | 7 ++++++-
+ src/services/Odometer.java         | 4 ++--
+ 3 files changed, 9 insertions(+), 4 deletions(-)
+
+commit c7aa7cfc6c7f5f43e676e87948440fe1f60924f9
+Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
+Date:   Sat Nov 9 20:04:12 2013 -0500
+
+    Created a protoype of a bluetoothTransmission class. It is implemented
+    using a static method that can be called from the main. Will have to be
+    reconfigured and tested however.
+
+ src/utilities/BluetoothTransmission.java | 70 ++++++++++++++++++++++++++++++++
+ 1 file changed, 70 insertions(+)
+
+commit 61dbb95efe3673d3666fbb1d6e498fdbd3286eac
+Author: RileyvanRyswyk <rileyvan@gmail.com>
+Date:   Sat Nov 9 19:58:56 2013 -0500
+
+    Odometer fix
+
+ src/hardwareAbstraction/Drive.java | 4 ++--
+ src/services/Odometer.java         | 4 ++--
+ 2 files changed, 4 insertions(+), 4 deletions(-)
+
+commit 930cf763771cb891074514a99f91193f17a7a43f
+Author: RileyvanRyswyk <rileyvan@gmail.com>
+Date:   Sat Nov 9 19:54:01 2013 -0500
+
+    Drive direction fix
+
+ src/hardwareAbstraction/Drive.java | 4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+commit 442d5e81b2e90eeae4532fb4c394f62d43e72525
+Author: RileyvanRyswyk <rileyvan@gmail.com>
+Date:   Sat Nov 9 19:07:52 2013 -0500
+
+    Odometer Tweaking
+
+ src/launcher/Launcher.java   | 9 +++++++--
+ src/services/Navigation.java | 1 -
+ 2 files changed, 7 insertions(+), 3 deletions(-)
+
+commit 50d88f6abdc5fa9690bffcf3964c97811fb9a577
+Author: RileyvanRyswyk <rileyvan@gmail.com>
+Date:   Sat Nov 9 18:22:05 2013 -0500
+
+    Navigation
+    
+    Remove exception caused by route.peek() when route is empty
+
+ src/services/Navigation.java | 5 +++--
+ 1 file changed, 3 insertions(+), 2 deletions(-)
+
+commit 3209a5cbc57e23973c507bad491686ba0f1125d1
+Author: RileyvanRyswyk <rileyvan@gmail.com>
+Date:   Sat Nov 9 18:17:39 2013 -0500
+
+    The second half
+
+ .gitignore                         |  4 +++-
+ src/controllers/State.java         |  2 +-
+ src/hardwareAbstraction/Drive.java |  2 +-
+ src/manager/ControllerManager.java |  2 +-
+ src/manager/Manager.java           | 13 +++++++++++--
+ src/services/Navigation.java       | 16 +++++++++-------
+ src/utilities/Communicator.java    | 15 ++++++++-------
+ src/utilities/Responder.java       |  3 +++
+ 8 files changed, 37 insertions(+), 20 deletions(-)
+
+commit 08074a31deedd14a61e51a98e8f106c757e22681
+Author: RileyvanRyswyk <rileyvan@gmail.com>
+Date:   Sat Nov 9 13:23:33 2013 -0500
+
+    Localization + bug fixes
+
+ src/hardwareAbstraction/LinePoller.java       | 110 +++++++++++++++++++++++---
+ src/hardwareAbstraction/UltrasonicPoller.java | 105 ++++++++++++++++++++----
+ src/launcher/Launcher.java                    |  15 ++++
+ src/services/Localization.java                |  85 ++++++++++++++++----
+ src/utilities/Settings.java                   |  15 ++--
+ 5 files changed, 284 insertions(+), 46 deletions(-)
+
+commit a10c3762f7890412801f10ed7c2fc0dc069df8ab
+Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
+Date:   Fri Nov 8 22:08:52 2013 -0500
+
+    Created the RS485 connection and Responder. Settings had to be changed
+    to account for the RemoteMotors (changed from NXTRegulatedMotor). The
+    ports used on the slave are all UltrasonicSensors as the code for a
+    remote ColorSensor is not supported.
+
+ src/utilities/Communicator.java | 58 +++++++++++++++++++++++++++++++++++++++--
+ src/utilities/Responder.java    | 49 ++++++++++++++++++++++++++++++++++
+ src/utilities/Settings.java     |  8 +++---
+ 3 files changed, 110 insertions(+), 5 deletions(-)
+
+commit 5b3c6b98b5808d38a3c2f32ec996e1bcaa802044
+Author: RileyvanRyswyk <rileyvan@gmail.com>
+Date:   Fri Nov 8 13:17:13 2013 -0500
+
+    Mostly Localization
+
+ src/hardwareAbstraction/LinePoller.java       |  15 +++
+ src/hardwareAbstraction/UltrasonicPoller.java |  10 +-
+ src/manager/UtilityManager.java               |  11 ++
+ src/services/Localization.java                | 176 +++++++++++++++++++++++++-
+ src/services/Navigation.java                  |   9 +-
+ src/services/Odometer.java                    |   5 +-
+ src/utilities/Settings.java                   |   2 +
+ src/utilities/StartingCorner.java             |   5 +
+ 8 files changed, 222 insertions(+), 11 deletions(-)
+
+commit 10f87688261b2c05669c82b7727f5cbb9dc74afb
+Author: RileyvanRyswyk <rileyvan@gmail.com>
+Date:   Thu Nov 7 14:54:17 2013 -0500
+
+    Updated Navigation
+
+ src/hardwareAbstraction/Drive.java |  55 +++++++++++++
+ src/services/Navigation.java       | 156 +++++++++++++++----------------------
+ src/services/Odometer.java         |   2 +-
+ 3 files changed, 120 insertions(+), 93 deletions(-)
+
+commit f9ea3e79fa94b4508ff5b29a90e77e93d6792660
+Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
+Date:   Thu Nov 7 14:30:38 2013 -0500
+
+    Created the ultrasonic poller and obstacle avoidance. Many things left
+    undone in obstacle avoidance. The API documents may have to be changed.
+
+ src/hardwareAbstraction/UltrasonicPoller.java | 97 ++++++++++++++++++++++++++-
+ src/services/ObstacleAvoidance.java           | 43 +++++++++++-
+ 2 files changed, 136 insertions(+), 4 deletions(-)
+
+commit 9bdd4c111bc6c8b5475a4c1ed03c0d3a370e0b8b
+Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
+Date:   Thu Nov 7 13:05:08 2013 -0500
+
+    CollerPoller updated to reflect Settings.frontColorSensor
+
+ src/hardwareAbstraction/ColorPoller.java | 3 ++-
+ 1 file changed, 2 insertions(+), 1 deletion(-)
+
+commit ba74248c654eb3e3c60506c789aa044a00cac4cf
+Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
+Date:   Thu Nov 7 12:56:35 2013 -0500
+
+    Small changes in Navigation. Ignore changes in odometer and position.
+
+ src/services/Navigation.java | 16 ++++++++--------
+ src/services/Odometer.java   |  5 -----
+ src/utilities/Position.java  |  2 +-
+ 3 files changed, 9 insertions(+), 14 deletions(-)
+
+commit 006954167585a0e55f361980012c482c2c970dfa
+Merge: 7f645c9 00f63a7
+Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
+Date:   Thu Nov 7 12:30:55 2013 -0500
+
+    Merge branch 'master' of
+    https://github.com/danielle-mustillo/ECSE-211-Team-5.git
+    
+    Conflicts:
+    	src/services/Odometer.java
+    	src/utilities/Point.java
+
+commit 00f63a774bb59f27bc911cecf817d52380ef14fb
+Author: RileyvanRyswyk <rileyvan@gmail.com>
+Date:   Thu Nov 7 11:53:01 2013 -0500
+
+    Updates
+    
+    Mostly Odometer and some of the helper methods
+
+ .gitignore                               |   3 +
+ src/hardwareAbstraction/ColorPoller.java |   4 +-
+ src/hardwareAbstraction/Drive.java       |  27 ++++++
+ src/manager/HardwareManager.java         |   5 +-
+ src/manager/UtilityManager.java          |   2 +-
+ src/services/Odometer.java               | 145 ++++++++++++++++++++++++++++++-
+ src/utilities/Angle.java                 |  33 +++++++
+ src/utilities/Communicator.java          |   3 +
+ src/utilities/Point.java                 |  17 +++-
+ src/utilities/Position.java              |  17 ++++
+ src/utilities/Settings.java              |  20 +++++
+ 11 files changed, 269 insertions(+), 7 deletions(-)
+
+commit 7f645c9cab7a7e8eff3355287b2a126888002215
+Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
+Date:   Thu Nov 7 10:56:26 2013 -0500
+
+    Small edits to pause Navigation when executing scanAhead.
+
+ src/services/Navigation.java | 20 ++++++++++++++++++--
+ 1 file changed, 18 insertions(+), 2 deletions(-)
+
+commit 60469c55d31f3223d3eff80893c2202f0280d879
+Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
+Date:   Thu Nov 7 10:41:00 2013 -0500
+
+    Made navigation based upon previous code of Team 15. Created method
+    stubs for the moment.
+
+ src/services/Navigation.java        | 337 +++++++++++++-----------------------
+ src/services/ObstacleAvoidance.java |   5 +
+ src/services/Odometer.java          |   5 +
+ 3 files changed, 134 insertions(+), 213 deletions(-)
+
+commit 869d8a54c0c531f0e34b611c370a9ab17293c9eb
+Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
+Date:   Wed Nov 6 15:38:43 2013 -0500
+
+    Created getter and setter.
+
+ src/manager/ControllerManager.java | 9 +++++++++
+ 1 file changed, 9 insertions(+)
+
+commit 1fe602bbcdd3fc97a843e17ce7fe6c13b3459bef
+Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
+Date:   Wed Nov 6 15:38:28 2013 -0500
+
+    Point class was created. Please note the X and Y values and their
+    orientation. Programming Guide Specifications contains a quick note on
+    the orientation definitions.
+
+ src/utilities/Point.java | 30 ++++++++++++++++++++++++++++++
+ 1 file changed, 30 insertions(+)
+
+commit 1e9a46596d38d7a50eff19bdf5b32cee5deb3e2a
+Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
+Date:   Wed Nov 6 15:37:30 2013 -0500
+
+    Copied over the code from Team 15, began writing the timedOut() method.
+    Questions will be noted.
+
+ src/services/Navigation.java | 280 ++++++++++++++++++++++++++++++++++++++++---
+ 1 file changed, 265 insertions(+), 15 deletions(-)
+
+commit cecd59756a6b5975885c3cce968a022371544227
+Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
+Date:   Wed Nov 6 14:13:01 2013 -0500
+
+    Begun a ColorPoller class based on code that already exists.
+
+ src/hardwareAbstraction/ColorPoller.java | 46 ++++++++++++++++++++++++++++++--
+ 1 file changed, 44 insertions(+), 2 deletions(-)
+
+commit 98c378ac8f29352d75b1394a876fff6af7692026
+Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
+Date:   Wed Nov 6 13:20:59 2013 -0500
+
+    Should now be compilable as a Lejos project.
+
+ .classpath | 2 +-
+ .project   | 6 ++++++
+ 2 files changed, 7 insertions(+), 1 deletion(-)
+
+commit 4c2b7834d20fcaa917f93a292a283b1b90df2bf7
+Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
+Date:   Wed Nov 6 13:11:17 2013 -0500
+
+    Configured .project/.classpath file to be compilable in eclipse. Master
+    branch should now be compilable on your local machine.
+
+ .classpath |  6 ++++++
+ .gitignore |  1 +
+ .project   | 17 +++++++++++++++++
+ 3 files changed, 24 insertions(+)
+
+commit 4bac7e9c33e651c188dfca451b310c07805b23a2
+Author: RileyvanRyswyk <rileyvan@gmail.com>
+Date:   Wed Nov 6 00:31:29 2013 -0500
+
+    A start, but much more work required
+
+ src/controllers/Collect.java                  | 15 ++++++++
+ src/controllers/Controller.java               |  5 +++
+ src/controllers/ControllerInterface.java      |  6 ++++
+ src/controllers/DropOff.java                  | 15 ++++++++
+ src/controllers/Recognize.java                | 15 ++++++++
+ src/controllers/Search.java                   | 16 +++++++++
+ src/controllers/State.java                    |  5 +++
+ src/controllers/WallFollower.java             | 15 ++++++++
+ src/hardwareAbstraction/Claw.java             |  5 +++
+ src/hardwareAbstraction/ColorPoller.java      |  5 +++
+ src/hardwareAbstraction/Drive.java            |  5 +++
+ src/hardwareAbstraction/Forklift.java         |  5 +++
+ src/hardwareAbstraction/LinePoller.java       |  5 +++
+ src/hardwareAbstraction/UltrasonicMotor.java  |  5 +++
+ src/hardwareAbstraction/UltrasonicPoller.java |  5 +++
+ src/launcher/Launcher.java                    | 28 +++++++++++++++
+ src/manager/ControllerManager.java            | 50 +++++++++++++++++++++++++++
+ src/manager/HardwareManager.java              | 26 ++++++++++++++
+ src/manager/Manager.java                      | 16 +++++++++
+ src/manager/ServiceManager.java               | 24 +++++++++++++
+ src/manager/UtilityManager.java               | 19 ++++++++++
+ src/services/Localization.java                | 10 ++++++
+ src/services/Mapper.java                      | 10 ++++++
+ src/services/Navigation.java                  | 30 ++++++++++++++++
+ src/services/ObstacleAvoidance.java           | 28 +++++++++++++++
+ src/services/Odometer.java                    | 10 ++++++
+ src/services/OdometryCorrection.java          | 10 ++++++
+ src/utilities/Angle.java                      |  5 +++
+ src/utilities/BluetoothTransmission.java      | 12 +++++++
+ src/utilities/Communicator.java               |  5 +++
+ src/utilities/Map.java                        |  5 +++
+ src/utilities/Point.java                      |  5 +++
+ src/utilities/Position.java                   |  5 +++
+ src/utilities/Settings.java                   |  5 +++
+ src/utilities/Tile.java                       |  5 +++
+ 35 files changed, 435 insertions(+)
+
+commit b07e8bd71635bbc4f4772467dea10ec834353db1
+Author: RileyvanRyswyk <rileyvan@gmail.com>
+Date:   Sat Nov 2 18:54:59 2013 -0400
+
+    Revert "Group 15 Lab 2,4,5"
+    
+    This reverts commit fb0fee606bcb5dabcf70f1ae49cddcf12ff3c17b.
+
+ Group-15/Lab2-15/Lab2.java                 |  58 -----
+ Group-15/Lab2-15/Odometer.java             | 163 ------------
+ Group-15/Lab2-15/OdometryCorrection.java   | 212 ---------------
+ Group-15/Lab2-15/OdometryDisplay.java      | 101 --------
+ Group-15/Lab2-15/SquareDriver.java         |  66 -----
+ Group-15/Lab4-15/LCDInfo.java              |  53 ----
+ Group-15/Lab4-15/Lab4.java                 |  68 -----
+ Group-15/Lab4-15/LightLocalizer.java       | 193 --------------
+ Group-15/Lab4-15/Navigation.java           | 246 ------------------
+ Group-15/Lab4-15/Odometer.java             | 176 -------------
+ Group-15/Lab4-15/TwoWheeledRobot.java      | 161 ------------
+ Group-15/Lab4-15/USLocalizer.java          | 325 -----------------------
+ Group-15/Lab5-15/Grid.java                 | 275 --------------------
+ Group-15/Lab5-15/LCDInfo.java              |  77 ------
+ Group-15/Lab5-15/Lab5.java                 |  71 -----
+ Group-15/Lab5-15/LightLocalizer.java       | 199 --------------
+ Group-15/Lab5-15/LightPoller.java          | 131 ----------
+ Group-15/Lab5-15/Navigation.java           | 366 --------------------------
+ Group-15/Lab5-15/ObjectFinding.java        | 253 ------------------
+ Group-15/Lab5-15/ObjectRecognitionOne.java | 217 ----------------
+ Group-15/Lab5-15/ObjectRecognitionTwo.java | 399 -----------------------------
+ Group-15/Lab5-15/Odometer.java             | 205 ---------------
+ Group-15/Lab5-15/TwoWheeledRobot.java      | 165 ------------
+ Group-15/Lab5-15/USLocalizer.java          | 354 -------------------------
+ Group-15/Lab5-15/UltrasonicPoller.java     | 235 -----------------
+ Group-15/Lab5-15/old.zip                   | Bin 21702 -> 0 bytes
+ 26 files changed, 4769 deletions(-)
+
+commit fb0fee606bcb5dabcf70f1ae49cddcf12ff3c17b
+Author: RileyvanRyswyk <rileyvan@gmail.com>
+Date:   Sat Nov 2 18:49:26 2013 -0400
+
+    Group 15 Lab 2,4,5
+    
+    For Lab 5, old.zip contains the original code with the grid and mapping
+    information.
+
+ Group-15/Lab2-15/Lab2.java                 |  58 +++++
+ Group-15/Lab2-15/Odometer.java             | 163 ++++++++++++
+ Group-15/Lab2-15/OdometryCorrection.java   | 212 +++++++++++++++
+ Group-15/Lab2-15/OdometryDisplay.java      | 101 ++++++++
+ Group-15/Lab2-15/SquareDriver.java         |  66 +++++
+ Group-15/Lab4-15/LCDInfo.java              |  53 ++++
+ Group-15/Lab4-15/Lab4.java                 |  68 +++++
+ Group-15/Lab4-15/LightLocalizer.java       | 193 ++++++++++++++
+ Group-15/Lab4-15/Navigation.java           | 246 ++++++++++++++++++
+ Group-15/Lab4-15/Odometer.java             | 176 +++++++++++++
+ Group-15/Lab4-15/TwoWheeledRobot.java      | 161 ++++++++++++
+ Group-15/Lab4-15/USLocalizer.java          | 325 +++++++++++++++++++++++
+ Group-15/Lab5-15/Grid.java                 | 275 ++++++++++++++++++++
+ Group-15/Lab5-15/LCDInfo.java              |  77 ++++++
+ Group-15/Lab5-15/Lab5.java                 |  71 +++++
+ Group-15/Lab5-15/LightLocalizer.java       | 199 ++++++++++++++
+ Group-15/Lab5-15/LightPoller.java          | 131 ++++++++++
+ Group-15/Lab5-15/Navigation.java           | 366 ++++++++++++++++++++++++++
+ Group-15/Lab5-15/ObjectFinding.java        | 253 ++++++++++++++++++
+ Group-15/Lab5-15/ObjectRecognitionOne.java | 217 ++++++++++++++++
+ Group-15/Lab5-15/ObjectRecognitionTwo.java | 399 +++++++++++++++++++++++++++++
+ Group-15/Lab5-15/Odometer.java             | 205 +++++++++++++++
+ Group-15/Lab5-15/TwoWheeledRobot.java      | 165 ++++++++++++
+ Group-15/Lab5-15/USLocalizer.java          | 354 +++++++++++++++++++++++++
+ Group-15/Lab5-15/UltrasonicPoller.java     | 235 +++++++++++++++++
+ Group-15/Lab5-15/old.zip                   | Bin 0 -> 21702 bytes
+ 26 files changed, 4769 insertions(+)
+
+commit 28dcc7a556d15d31e4288c88a897ea5f24d3683e
+Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
+Date:   Sat Nov 2 15:16:55 2013 -0400
+
+    Create README.md
+
+ README.md | 4 ++++
+ 1 file changed, 4 insertions(+)

commit d51db9d4deb670a379e30755fa2bfbea78dcc4ee
Author: RileyvanRyswyk <rileyvan@gmail.com>
Date:   Fri Nov 22 13:30:13 2013 -0500

    Updates on remote NXT

diff --git a/src/hardwareAbstraction/NXTRemoteCommand.java b/src/hardwareAbstraction/NXTRemoteCommand.java
new file mode 100644
index 0000000..54108e6
--- /dev/null
+++ b/src/hardwareAbstraction/NXTRemoteCommand.java
@@ -0,0 +1,86 @@
+package hardwareAbstraction;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+
+import utilities.Communicator;
+
+public class NXTRemoteCommand {
+	   DataInputStream dis;
+	   DataOutputStream dos;
+	   
+	   
+	    public NXTRemoteCommand(Communicator communicator) {
+	    	this.dis = communicator.dis;
+	    	this.dos = communicator.dos;
+	    }
+	   
+	    public void send(int id,int command)
+	     {
+	       try
+	       { dos.writeInt(id);
+	         dos.writeInt(command);
+	        
+	         dos.flush();
+	       
+	         
+	       } catch (IOException e)
+	       {
+	       
+	         System.out.println("send problem " + e);
+	          
+	         }
+	       }
+	    public void send(int id,int command, int param1 ,boolean immediateReturn)
+	     {
+	       try
+	       { dos.writeInt(id);
+	         dos.writeInt(command);
+	         dos.writeInt(param1);
+	         dos.writeBoolean(immediateReturn);
+	         dos.flush();
+	        
+	         
+	       } catch (IOException e)
+	       {
+	       
+	         System.out.println("send problem " + e);
+	          
+	         }
+	       }
+	    
+	    public void send(int id,int command, int param1 )
+	     {
+	       try
+	       { dos.writeInt(id);
+	         dos.writeInt(command);
+	         dos.writeInt(param1);
+	        
+	         dos.flush();
+	         
+	         
+	       } catch (IOException e)
+	       {
+	       
+	         System.out.println("send problem " + e);
+	          
+	         }
+	       }
+	    public int getInt() throws IOException{
+	       
+	       return dis.readInt();
+	       
+	    }
+	 public float getFloat() throws IOException{
+	       
+	       return dis.readFloat();
+	       
+	    }
+	 
+	 public boolean getBool() throws IOException{
+	    
+	    return dis.readBoolean();
+	    
+	 }
+}
diff --git a/src/hardwareAbstraction/NXTRemoteMotor.java b/src/hardwareAbstraction/NXTRemoteMotor.java
new file mode 100644
index 0000000..6e01414
--- /dev/null
+++ b/src/hardwareAbstraction/NXTRemoteMotor.java
@@ -0,0 +1,248 @@
+package hardwareAbstraction;
+
+import java.io.IOException;
+
+import lejos.nxt.comm.RConsole;
+import lejos.robotics.RegulatedMotor;
+import lejos.robotics.RegulatedMotorListener;
+
+public class NXTRemoteMotor implements RemoteCommands, RegulatedMotor{
+	   
+	   
+
+    private int id;
+
+    private NXTRemoteCommand  motorCommand;
+  
+  //  private ListenerConnection listenerConnection=null;
+
+    public  NXTRemoteMotor(NXTRemoteCommand nxtCommand, int id){
+       
+        this.id = id;
+        this.motorCommand=nxtCommand;
+         //this.listenerConnection=listenersConnection;
+    }
+    
+ 
+    public boolean suspendRegulation(){
+     boolean suspended=false;
+       motorCommand.send(id, SUSPEND_REGULATION);
+        try {
+           suspended=motorCommand.getBool();
+           
+        } catch (IOException e) {
+           // TODO Auto-generated catch block
+           e.printStackTrace();
+        }
+       
+    return suspended;
+    }
+@Override
+public void flt() {
+  RConsole.println("flt");
+  motorCommand.send(id, FLT);
+  
+}
+
+@Override
+public int getRotationSpeed() {
+  int speed=0;
+  RConsole.println("getRotationSpeed");
+  motorCommand.send(id, GET_ROTATION_SPEED);
+  try {
+     speed=motorCommand.getInt();
+     RConsole.println("speed="+speed);
+  } catch (IOException e) {
+     // TODO Auto-generated catch block
+     e.printStackTrace();
+  }
+  return speed;
+}
+
+@Override
+public int getTachoCount() {
+  RConsole.println("getTachoCount");
+  int tachoCount=0;
+  motorCommand.send(id, GET_TACHO_COUNT);
+  try {
+     tachoCount=motorCommand.getInt();
+     RConsole.println("tachoCount="+tachoCount);
+  } catch (IOException e) {
+     // TODO Auto-generated catch block
+     e.printStackTrace();
+  }
+  return tachoCount;
+}
+
+@Override
+public void resetTachoCount() {
+  RConsole.println("resetTachoCount");
+  motorCommand.send(id, RESET_TACHO_COUNT);
+  
+}
+
+@Override
+public int getLimitAngle() {
+  RConsole.println("getLimitAngle");
+  
+  int angle=0;
+  motorCommand.send(id, GET_LIMIT_ANGLE);
+  try {
+     angle=motorCommand.getInt();
+     RConsole.println("angle="+angle);
+  } catch (IOException e) {
+     // TODO Auto-generated catch block
+     e.printStackTrace();
+  }
+  return angle;
+}
+
+@Override
+public float getMaxSpeed() {
+  RConsole.println("getMaxSpeed=");
+  float speed=0;
+  motorCommand.send(id,GET_MAX_SPEED);
+  try {
+     speed=motorCommand.getFloat();
+     RConsole.println("speed="+speed);
+  } catch (IOException e) {
+     // TODO Auto-generated catch block
+     e.printStackTrace();
+  }
+  return speed;
+}
+
+@Override
+public int getSpeed() {
+  RConsole.println("getSpeed=");
+  int speed=0;
+  motorCommand.send(id, GET_SPEED);
+  try {
+     speed=motorCommand.getInt();
+     RConsole.println("speed="+speed);
+  } catch (IOException e) {
+     // TODO Auto-generated catch block
+     e.printStackTrace();
+  }
+  return speed;
+}
+
+@Override
+public boolean isStalled() {
+  RConsole.println("isStalled");
+  boolean isStalled=false;
+  motorCommand.send(id, IS_STALLED);
+  try {
+     isStalled=motorCommand.getBool();
+     RConsole.println("isStalled="+isStalled);
+  } catch (IOException e) {
+     // TODO Auto-generated catch block
+     e.printStackTrace();
+  }
+  return isStalled;
+
+}
+
+@Override
+public void rotate(int angle) {
+  RConsole.println("rotate");
+  motorCommand.send(id, ROTATE, angle, false);
+  
+}
+
+@Override
+public void rotate(int angle, boolean immediateReturn) {
+  RConsole.println("rotate");
+  motorCommand.send(id, ROTATE, angle, immediateReturn);
+  
+}
+
+@Override
+public void rotateTo(int angle) {
+  RConsole.println("rotateTo");
+  motorCommand.send(id, ROTATE_TO, angle, false);
+}
+
+@Override
+public void rotateTo(int angle, boolean immediateReturn) {
+  motorCommand.send(id, ROTATE_TO, angle, immediateReturn);
+}
+
+@Override
+public void setAcceleration(int accel) {
+
+  motorCommand.send(id, SET_ACCELERATION, accel);
+  
+}
+
+@Override
+public void setSpeed(int speed) {
+  RConsole.println("setSpeed " +speed);
+  motorCommand.send(id, SET_SPEED, speed);
+  
+}
+
+@Override
+public void backward() {
+  motorCommand.send(id, BACKWARD);
+  
+}
+
+@Override
+public void forward() {
+  
+  motorCommand.send(id, FORWARD);
+  
+}
+
+@Override
+public boolean isMoving() {
+  RConsole.println("isMoving=");
+  
+  boolean isMoving=false;
+  motorCommand.send(id, IS_MOVING);
+  try {
+     isMoving=motorCommand.getBool();
+     RConsole.println("isMoving="+isMoving);
+  } catch (IOException e) {
+     // TODO Auto-generated catch block
+     e.printStackTrace();
+  }
+  return isMoving;
+}
+
+@Override
+public void stop() {
+  motorCommand.send(id, STOP);
+  
+}
+
+
+@Override
+public void addListener(RegulatedMotorListener arg0) {
+	// TODO Auto-generated method stub
+	
+}
+
+
+@Override
+public void flt(boolean arg0) {
+	// TODO Auto-generated method stub
+	
+}
+
+
+@Override
+public void stop(boolean arg0) {
+	// TODO Auto-generated method stub
+	
+}
+
+
+@Override
+public void waitComplete() {
+	// TODO Auto-generated method stub
+	
+}
+
+}
diff --git a/src/hardwareAbstraction/RemoteCommands.java b/src/hardwareAbstraction/RemoteCommands.java
new file mode 100644
index 0000000..8f227cb
--- /dev/null
+++ b/src/hardwareAbstraction/RemoteCommands.java
@@ -0,0 +1,35 @@
+package hardwareAbstraction;
+
+/**
+ * 
+ * Contains a list of integer commands to communicate to the remote motors
+ * 
+ * Code Sourced from Lejos Forums (http://www.lejos.org/forum/viewtopic.php?f=7&t=2620)
+ * 
+ * @author cs07cc4
+ *
+ */
+
+public interface RemoteCommands {
+	  public static final int FORWARD = 0;
+	  public static final int BACKWARD = 1;
+	  public static final int ROTATE = 2;
+	  public static final int STOP = 3;
+	  public static final int ROTATE_TO = 4;
+	  public static final int FLT = 5;
+	  public static final int GET_TACHO_COUNT = 6;
+	  public static final int IS_MOVING = 7;
+	  public static final int SET_SPEED = 8;
+	  public static final int SET_ACCELERATION = 9;
+	  public static final int GET_ACCELERETION = 10;
+	  public static final int GET_LIMIT_ANGLE = 11;
+	  public static final int RESET_TACHO_COUNT = 12;
+	  public static final int GET_SPEED = 13;
+	  public static final int IS_STALLED = 14;
+	  public static final int GET_ROTATION_SPEED= 15;
+	  public static final int GET_MAX_SPEED= 16;
+	  public static final int SUSPEND_REGULATION= 17;
+	  public static final int ADD_LISTENER= 18;
+	  public static final int ROTATION_STARTED= 19;
+	  public static final int ROTATION_STOPPED= 20;
+}
diff --git a/src/hardwareAbstraction/RemoteUltrasonicPoller.java b/src/hardwareAbstraction/RemoteUltrasonicPoller.java
new file mode 100644
index 0000000..3645c47
--- /dev/null
+++ b/src/hardwareAbstraction/RemoteUltrasonicPoller.java
@@ -0,0 +1,330 @@
+package hardwareAbstraction;
+
+import controllers.State;
+import utilities.Settings;
+import lejos.nxt.LCD;
+import lejos.nxt.UltrasonicSensor;
+import lejos.nxt.comm.RConsole;
+import lejos.util.Timer;
+import lejos.util.TimerListener;
+import manager.Manager;
+
+/**
+ * This class serves as a higher level abstraction of a ultrasonic sensor. It is
+ * wrapped in a poller class which will now handle the returned values and the
+ * polling of that sensor
+ * <p>
+ * 
+ * @author danielle, Riley
+ */
+public class RemoteUltrasonicPoller implements TimerListener {
+	private UltrasonicSensor[] us = new UltrasonicSensor[3];
+	public int pollRate;
+	private Timer poller;
+	private int readings[][];
+	private boolean running = false;
+	
+	private int left = 0;
+	private int center = 1;
+	private int right = 2;
+	private int counter;
+
+	private Thread leftUS;
+	private Thread centerUS;
+	private Thread rightUS;
+
+	// TODO figure out what exactly this constructor should be.
+	public RemoteUltrasonicPoller() {
+		us[left] = Settings.leftUltrasonic;
+		us[center] = Settings.centerUltrasonic;
+		us[right] = Settings.rightUltrasonic;
+
+		this.pollRate = 100;
+		this.readings = new int[3][5];
+
+		us[left].off();
+		us[center].off();
+		us[right].off();
+
+		this.leftUS = new Thread(new LeftUS());
+		this.centerUS = new Thread(new CenterUS());
+		this.rightUS = new Thread(new RightUS());
+		
+		this.start();
+	}
+
+	/**
+	 * Pings all three ultrasonic sensors and gets their values. Puts them into
+	 * the readings array
+	 */
+	@Override
+	public void timedOut() {
+		
+		/*
+		 * Ensures minimal lag for ultrasonic localization 
+		 */
+		if(manager.cm.getState() != State.LOCALIZING) {
+		
+			/*
+			 * If the ultrasonics are facing forward, poll only one at a time.
+			 * Else poll them all simultaneously. 
+			 */
+			if(UltrasonicMotor.isForward) {
+				switch(counter) {
+				case 0 : leftUS.run();
+				break;
+				case 1 : centerUS.run();
+				break;
+				case 2 : rightUS.run();
+				break;
+				}
+				counter += 1;
+				counter = counter % 3;
+			}
+			else {
+				leftUS.run();
+				centerUS.run();
+				rightUS.run();
+				RConsole.println(toStringLastValues());
+			}
+		} else {
+			centerUS.run();
+		}
+	}
+
+	// For debugging purposes.
+	private String toStringLastValues() {
+		String out = "";
+		out += " L: " + getUSReading(left);
+		out += " C: " + getUSReading(center);
+		out += " R: " + getUSReading(right);
+		return out;
+	}
+
+	/**
+	 * Starts this instance of the ultrasonic poller Stop must be called to stop
+	 * the reading again.
+	 */
+	public void start() {
+		counter = 0;
+
+		// for filtering purposes
+		this.poller = new Timer(pollRate, this);
+		this.poller.start();
+		running = true;
+	}
+
+	/**
+	 * Resets the ultrasonic sensor values to the default -1 values. The
+	 * ultrasonic sensor will never return negative values during normal
+	 * operation. Stops the polling during this operation to avoid overwriting
+	 * good data.
+	 * @bug throws null pointer exception. Has potentially been fixed. Needs to be tested.
+	 */
+	public void resetUSP() {
+		this.stop();
+		for (int i = 0; i < readings.length; ++i) {
+			for (int j = 0; j < readings[1].length; ++j) {
+				RConsole.println("" + i + "," + j);
+				readings[i][j] = -1;
+			}
+		}
+		this.start();
+	}
+
+	/**
+	 * Checks if the ultrasonic sensor has collected atleast 5 values. It does
+	 * this by checking for any negative numbers in the readings.
+	 */
+	public boolean isSetup() {
+		if (readings[2][4] == -1 || readings[0][4] == -1 || readings[1][4] == -1)
+			return false;
+		else
+			return true;
+	}
+
+	/**
+	 * Stops this instance of the ultrasonic poller Start must be called to
+	 * start reading again.
+	 */
+	public void stop() {
+		this.poller.stop();
+		this.poller = null;
+		running = false;
+	}
+
+	/**
+	 * Returns the filtered data for the sensor (median filtering)
+	 * 
+	 * @param sensor
+	 * @return
+	 */
+	public int getUSReading(int sensor) {
+
+		// makes sure readings array is full of values so we have enough to
+		// filter with
+		if (readings[sensor][4] > -1) {
+
+			// initialize vars
+			int size = 5;
+			int[] usReadingsSorted = new int[5];
+			// Copy array
+			System.arraycopy(readings[sensor], 0, usReadingsSorted, 0, 5);
+
+			// sort the values: lowest to highest
+			for (int i = 0; i < size; i++) {
+				for (int j = i + 1; j < size; j++) {
+					if (usReadingsSorted[i] > usReadingsSorted[j]) {
+						int temp = usReadingsSorted[i];
+						usReadingsSorted[i] = usReadingsSorted[j];
+						usReadingsSorted[j] = temp;
+					}
+				}
+			}
+
+			// return the median
+			return usReadingsSorted[2];
+
+		} else {
+			return readings[sensor][0];
+		}
+	}
+
+	/**
+	 * gets the lowest reading in the ultrasonicPoller at that time. Readings
+	 * are not taken temporarily as they are not needed;
+	 * <p>
+	 * 
+	 * @return The smallest reading of the last 5 polls.
+	 */
+	public int getLowestReading() {
+		// stop reading if the robot was taking readings.
+		boolean takingReadings = false;
+		if (this.poller != null) {
+			stop();
+			takingReadings = true;
+		}
+
+		// calculate median value by sorting the readings
+		int minValue = readings[0][0]; // get a value to start
+		for (int usReadings[] : readings) {
+			int i = 0;
+			for (int reading : usReadings) {
+				if (minValue > reading && reading != -1)
+					minValue = reading;
+				++i;
+			}
+		}
+
+		// start the readings again if the robot was taking readings before.
+		if (takingReadings)
+			start();
+		return minValue;
+	}
+	
+	/**
+	 * This method gets the number representation of the US with the lowest value out of all the ultrasonic sensor. 
+	 * So if the center has the lowest reading, 
+	 */
+	public USPosition getLowestSensor() {
+		boolean takingReadings = false;
+		if (this.poller != null) {
+			stop();
+			takingReadings = true;
+		}
+
+		// calculate median value by sorting the readings
+		int minValue = readings[0][0]; // get a value to start
+		int sensor = 0;
+		int smallestSensor = 0;
+		for (int usReadings[] : readings) {
+			for (int reading : usReadings) {
+				if (minValue > reading && reading != -1) {
+					minValue = reading;
+					smallestSensor = sensor;
+				}
+			}
+			sensor++;
+		}
+
+		// start the readings again if the robot was taking readings before.
+		if (takingReadings)
+			start();
+		if(smallestSensor == left)
+			return USPosition.LEFT;
+		else if(smallestSensor == center)
+			return USPosition.CENTER;
+		else
+			return USPosition.RIGHT;
+	}
+
+	/**
+	 * Pings ultrasonic sensor and records the result in readings
+	 */
+	private void pingUS(int sensor) {
+		int distance;
+
+		// do a ping
+		us[sensor].ping();
+
+		// wait for the ping to complete
+		try {
+			Thread.sleep(20);
+		} catch (InterruptedException e) {
+		}
+
+		// there will be a delay here
+		distance = us[sensor].getDistance();
+
+		addReading(sensor, distance);
+	}
+
+	// helper method.
+	private void addReading(int sensor, int reading) {
+		readings[sensor][4] = readings[sensor][3];
+		readings[sensor][3] = readings[sensor][2];
+		readings[sensor][2] = readings[sensor][1];
+		readings[sensor][1] = readings[sensor][0];
+		readings[sensor][0] = reading;
+	}
+	
+	/**
+	 * Computes the average values read by a sensor
+	 * @param sensor	The integer value corresponding to the ultrasonic sensor
+	 * @return The average integer value, in integer value.
+	 */
+	public int computeAverage(int sensor) {
+		int sum = 0;
+		for(int i = 0; i < readings[sensor].length; i++)
+			sum += readings[sensor][i];
+		return (sum / readings[sensor].length);
+	}
+
+	public class LeftUS implements Runnable {
+
+		@Override
+		public void run() {
+			pingUS(left);
+		}
+	}
+
+	public class RightUS implements Runnable {
+
+		@Override
+		public void run() {
+			pingUS(right);
+		}
+	}
+
+	public class CenterUS implements Runnable {
+
+		@Override
+		public void run() {
+			pingUS(center);
+		}
+	}
+	
+	public enum USPosition {
+		LEFT, CENTER, RIGHT
+	}
+}
diff --git a/src/launcher/Launcher.java b/src/launcher/Launcher.java
index 5b3a6fc..c9642fa 100644
--- a/src/launcher/Launcher.java
+++ b/src/launcher/Launcher.java
@@ -6,8 +6,11 @@ package launcher;
 import hardwareAbstraction.Claw;
 import hardwareAbstraction.Forklift;
 import hardwareAbstraction.Forklift.ForkliftState;
+import hardwareAbstraction.NXTMotorCommand;
+import hardwareAbstraction.NXTRemoteMotor;
 import hardwareAbstraction.UltrasonicMotor;
 import hardwareAbstraction.UltrasonicPoller;
+import utilities.Communicator;
 import utilities.Point;
 import controllers.State;
 import lejos.nxt.Button;
@@ -32,11 +35,43 @@ public class Launcher {
 	 * @param args
 	 */
 	public static void main(String[] args) {
-//		RConsole.openBluetooth(20000);
+		//RConsole.openUSB(20000);
 		
 		
-		Manager manager = new Manager();
+		//Manager manager = new Manager();
 		Button.waitForPress();
+		
+		
+		Communicator com = new Communicator("NXT");
+		
+		NXTMotorCommand motorCommand = new NXTMotorCommand(com);
+		
+		NXTRemoteMotor clawMotor = new NXTRemoteMotor(motorCommand, 1);
+		NXTRemoteMotor ultrasonicMotor = new NXTRemoteMotor(motorCommand, 2);
+		NXTRemoteMotor liftMotor = new NXTRemoteMotor(motorCommand, 3);
+		
+		ultrasonicMotor.setAcceleration(100);
+		ultrasonicMotor.setSpeed(100);
+		clawMotor.setAcceleration(100);
+		liftMotor.setAcceleration(100);
+		clawMotor.setSpeed(100);
+		liftMotor.setSpeed(100);
+		
+		
+		for(int i=0; i<10; i++) {
+			
+			if(i % 2 == 0) {
+				ultrasonicMotor.rotateTo(0);
+			} else {
+				ultrasonicMotor.rotateTo(-40);
+			}
+			
+			while(ultrasonicMotor.isMoving()) {
+				sleep(40);
+			}
+		}
+		
+		
 		/*manager.sm.localization.start();
 		
 		while(manager.cm.getState() == State.LOCALIZING) {
@@ -46,12 +81,12 @@ public class Launcher {
 		//sleep(Forklift.setHeight(ForkliftState.SCAN_HEIGHT_LOW));
 		
 //		manager.sm.odoCorrection.start();
-		manager.hm.ultrasonicPoller.start();
-		manager.sm.nav.start();
+		//manager.hm.ultrasonicPoller.start();
+		//manager.sm.nav.start();
 //		manager.sm.nav.turnToComplete(Math.PI);
 		
 		
-		manager.cm.setState(State.SEARCH);
+		//manager.cm.setState(State.SEARCH);
 		
 //		manager.sm.nav.addToRoute(new Point(15,15));
 //		manager.sm.nav.addToRoute(new Point(45,15));
@@ -72,14 +107,15 @@ public class Launcher {
 //		manager.cm.setState(State.COLLECT);
 		
 		Button.waitForPress();
-		manager.hm.reset();
+		//manager.hm.reset();
 	}
 	
-	private static void sleep(int time){
+	public static void sleep(int ms) {
 		try {
-		Thread.sleep(time);
+			Thread.sleep(ms);
 		} catch (InterruptedException e) {
+			// TODO Auto-generated catch block
+			e.printStackTrace();
 		}
 	}
-
 }
diff --git a/src/utilities/Communicator.java b/src/utilities/Communicator.java
index 59dbeaf..f188b23 100644
--- a/src/utilities/Communicator.java
+++ b/src/utilities/Communicator.java
@@ -1,13 +1,13 @@
 package utilities;
 
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
 import java.io.IOException;
 
 import lejos.nxt.LCD;
-import lejos.nxt.UltrasonicSensor;
-import lejos.nxt.comm.Bluetooth;
-import lejos.nxt.comm.RConsole;
 import lejos.nxt.comm.RS485;
-import lejos.nxt.remote.RemoteNXT;
+import lejos.nxt.comm.NXTCommConnector;
+import lejos.nxt.comm.NXTConnection;
 
 /**
  * This class will communicate with the slave NXT and initialize the ports on
@@ -18,12 +18,31 @@ import lejos.nxt.remote.RemoteNXT;
  * 
  */
 public class Communicator {
-
+	
+	private NXTConnection con;
+	private NXTCommConnector connector;
+	public DataInputStream dis;
+	public DataOutputStream dos;
+	
+	public Communicator(String extendedNXT) {
+		
+	       connector = RS485.getConnector();
+	       con = connector.connect(extendedNXT, NXTConnection.RAW);
+	       if (con == null) 
+	       catchBug("RS485 Failed");
+	      
+	       dis = con.openDataInputStream();
+	       dos = con.openDataOutputStream();
+	}
+	
+	
+	
+	
 	/**
 	 * The Communicator object that will just connect to the slaveNXT. Uses exclusively RS485 for a reliable connection. It initializes the motors from the remote brick.
 	 * @param slaveNXT	A String with the name of the remoteNXT connected via RS485. 
 	 */
-	public Communicator(String slaveNXT) {
+	/*public Communicator(String slaveNXT) {
 		RemoteNXT nxt = null;
 		try {
 			nxt = new RemoteNXT(slaveNXT, RS485.getConnector());
@@ -47,7 +66,7 @@ public class Communicator {
 		Settings.centerUltrasonic = new UltrasonicSensor(nxt.S1);
 		Settings.rightUltrasonic = new UltrasonicSensor(nxt.S2);
 		
-	}
+	}*/
 
 	/**
 	 * The static helper method here just exits the system when commanded. It
diff --git a/src/utilities/NXTRemoteControl.java b/src/utilities/NXTRemoteControl.java
new file mode 100644
index 0000000..974ca4c
--- /dev/null
+++ b/src/utilities/NXTRemoteControl.java
@@ -0,0 +1,367 @@
+package utilities;
+
+import hardwareAbstraction.RemoteCommands;
+import hardwareAbstraction.UltrasonicPoller;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+
+import lejos.nxt.*;
+import lejos.nxt.comm.NXTCommConnector;
+import lejos.nxt.comm.NXTConnection;
+import lejos.nxt.comm.RConsole;
+import lejos.nxt.comm.RS485;
+import lejos.robotics.RegulatedMotor;
+import lejos.robotics.RegulatedMotorListener;
+
+/**
+ * Enables remote control of a motor object using RS485. 
+ **/
+public class NXTRemoteControl extends Thread implements RemoteCommands, RegulatedMotorListener {
+
+   private DataInputStream dis = null;
+   private DataOutputStream dos = null;
+   
+   //private DataInputStream lisdis = null;
+   //private DataOutputStream lisdos = null;
+   
+   private NXTCommConnector connector;
+   private NXTConnection con;
+   
+   
+   //private NXTConnection listenersCon;
+   private int id;
+   private int command;
+   private int tachoCount;
+   private boolean isMoving;
+   private int speed;
+   private float maxSpeed;
+   private int acceleration;
+   private int angle;
+   private boolean immediateReturn, isStalled;
+
+   private static NXTRegulatedMotor A = null;
+   private static NXTRegulatedMotor B = null;
+   private static NXTRegulatedMotor C = null;
+   private RemoteUltrasonicPoller usp = null;
+
+   public NXTRemoteControl(MotorPort portA) {
+      
+      A = new NXTRegulatedMotor(portA);
+
+}
+   public NXTRemoteControl(MotorPort portA, MotorPort portB) {
+      
+         A = new NXTRegulatedMotor(portA);
+         B = new NXTRegulatedMotor(portB);
+         
+
+   }
+   public NXTRemoteControl(MotorPort portA, MotorPort portB,
+         MotorPort portC) {
+      
+         A = new NXTRegulatedMotor(portA);
+         B = new NXTRegulatedMotor(portB);
+         C = new NXTRegulatedMotor(portC);
+
+   }
+   
+   public NXTRemoteControl(MotorPort portA, MotorPort portB, MotorPort portC, RemoteUltrasonicPoller usp) {
+	   A = new NXTRegulatedMotor(portA);
+       B = new NXTRegulatedMotor(portB);
+       C = new NXTRegulatedMotor(portC);
+       usp = new RemoteUltrasonicPoller();
+   }
+
+   protected void executeCommand(int id, int command) throws IOException {
+
+      NXTRegulatedMotor motor = getMotor(id);
+
+      switch (command) {
+
+      case FORWARD: {
+         RConsole.println("FORWARD");
+         motor.forward();
+         break;
+      }
+
+      case BACKWARD: {
+         RConsole.println("BACKWARD");
+         motor.backward();
+         break;
+      }
+
+      case ROTATE: {
+         RConsole.println("ROTATE");
+         angle = dis.readInt();
+         RConsole.println("angle"+angle);
+         immediateReturn = dis.readBoolean();
+         RConsole.println("immediateReturn"+immediateReturn);
+         motor.rotate(angle, immediateReturn);
+         break;
+      }
+
+      case STOP: {
+         RConsole.println("STOP");
+         motor.stop();
+         break;
+      }
+
+      case ROTATE_TO: {
+         RConsole.println("ROTATE_TO");
+         angle = dis.readInt();
+         immediateReturn = dis.readBoolean();
+         RConsole.println("angle"+angle);
+         RConsole.println("immediateReturn"+immediateReturn);
+         motor.rotateTo(angle, immediateReturn);
+         break;
+      }
+
+      case FLT: {
+         RConsole.println("FLT");
+         motor.flt();
+         break;
+      }
+
+      case GET_TACHO_COUNT: {
+         RConsole.println("GET_TACHO_COUNT");
+         tachoCount = motor.getTachoCount();
+         RConsole.println("tachoCount"+tachoCount);
+         dos.writeInt(tachoCount);
+         dos.flush();
+         break;
+      }
+
+      case IS_MOVING: {
+         RConsole.println("IS_MOVING");
+         isMoving = motor.isMoving();
+         RConsole.println("isMoving"+isMoving);
+         dos.writeBoolean(isMoving);
+         dos.flush();
+         break;
+      }
+
+      case SET_SPEED: {
+         int speed;
+         RConsole.println("SET_SPEED");
+         speed = dis.readInt();
+         RConsole.println("SET_SPEED="+speed);
+         motor.setSpeed(speed);
+         break;
+      }
+
+      case SET_ACCELERATION: {
+         RConsole.println("SET_ACCELERATION");
+         acceleration = dis.readInt();
+         RConsole.println("acceleration="+acceleration);
+         motor.setAcceleration(acceleration);
+      
+         break;
+      }
+
+      case GET_LIMIT_ANGLE: {
+         RConsole.println("GET_LIMIT_ANGLE");
+         angle = motor.getLimitAngle();
+         RConsole.println("angle="+angle);
+         dos.writeInt(angle);
+         dos.flush();
+         break;
+      }
+
+      case RESET_TACHO_COUNT: {
+         RConsole.println("RESET_TACHO_COUNT");
+         motor.resetTachoCount();
+         break;
+      }
+
+      case GET_SPEED: {
+         RConsole.println("GET_SPEED");
+         speed = motor.getSpeed();
+         RConsole.println("speed="+speed);
+         dos.writeInt(speed);
+         dos.flush();
+         break;
+      }
+
+      case IS_STALLED: {
+         RConsole.println("IS_STALLED");
+         isStalled = motor.isMoving();
+         RConsole.println("isStalled="+isStalled);
+         dos.writeBoolean(isStalled);
+         dos.flush();
+         break;
+         
+      }
+
+      case GET_ROTATION_SPEED: {
+         RConsole.println("GET_ROTATION_SPEED");
+         speed = motor.getRotationSpeed();
+         RConsole.println("speed="+speed);
+         dos.writeInt(speed);
+         dos.flush();
+         break;
+      }
+
+      case GET_MAX_SPEED: {
+         RConsole.println("GET_MAX_SPEED");
+         maxSpeed = motor.getMaxSpeed();
+         RConsole.println("maxSpeed="+maxSpeed);
+         dos.writeFloat(maxSpeed);
+         dos.flush();
+         break;
+         
+      }
+      case ADD_LISTENER: {
+         motor.addListener(this);
+      //   if (listenersCon==null){
+         //   connectionThread connect=new connectionThread();
+         //   connect.start();
+      //   }
+         
+         
+         break;
+         
+      }
+      
+      
+      case SUSPEND_REGULATION: {
+         boolean suspended;
+         RConsole.println("SUSPEND_REGULATION");
+         suspended=motor.suspendRegulation();
+         dos.writeBoolean(suspended);
+         dos.flush();
+         break;
+         
+      }
+      }
+
+   }
+
+   protected NXTRegulatedMotor getMotor(int id) {
+
+      switch (id) {
+      case 1:
+         return A;
+
+      case 2:
+         return B;
+
+      case 3:
+         return C;
+
+      }
+
+      return null;
+
+   }   
+   protected int getMotor(RegulatedMotor motor) {
+
+      if(motor.equals(Motor.A))
+         return 1;
+      else  if(motor.equals(Motor.B))
+         return 2;
+      else  if(motor.equals(Motor.C))
+         return 3;
+      
+      return -1;
+   }
+
+   public void run() {
+
+      while (true) {
+         
+         // Wait for connection if not connected
+         if (con == null) {
+            LCD.drawString("waiting", 0, 2);
+
+            connector = RS485.getConnector();
+            con = connector.waitForConnection(0, NXTConnection.RAW);
+
+            if (con != null) {
+               dis = con.openDataInputStream();
+               dos = con.openDataOutputStream();
+            }
+            LCD.drawString("Connected", 0, 2);
+            LCD.refresh();
+         }
+         
+         try {
+            id = dis.readInt();
+            command = dis.readInt();
+            RConsole.println("id="+id +"command =" +command);
+            executeCommand(id, command);
+
+         } catch (IOException e) {
+         //A.stop();
+         //B.stop();
+            //con.close();
+            //con = null;
+            //e.printStackTrace();
+         }
+
+      
+   
+      }
+}
+   @Override
+   public void rotationStarted(RegulatedMotor motor, int tachoCount, boolean stalled,
+         long timeStamp) {
+      
+//      try {
+//         
+//         int id=getMotor( motor);
+//         lisdos.writeInt(id);
+//         lisdos.writeInt(ROTATION_STARTED);
+//         lisdos.writeInt(tachoCount);
+//         lisdos.writeBoolean(stalled);
+//         lisdos.writeLong(timeStamp);
+//         lisdos.flush();
+//      } catch (IOException e) {
+//         // TODO Auto-generated catch block
+//         e.printStackTrace();
+      }
+      
+   
+   @Override
+   public void rotationStopped(RegulatedMotor motor, int tachoCount, boolean stalled,
+         long timeStamp) {
+      
+//try {
+//         
+//         int id=getMotor(motor);
+//         lisdos.writeInt(id);
+//         lisdos.writeInt(ROTATION_STOPPED);
+//         lisdos.writeInt(tachoCount);
+//         lisdos.writeBoolean(stalled);
+//         lisdos.writeLong(timeStamp);
+//         lisdos.flush();
+//      } catch (IOException e) {
+//         // TODO Auto-generated catch block
+//         e.printStackTrace();
+//      }
+         
+   }
+   
+//   public class connectionThread extends Thread {
+//      
+//      public void run(){
+//   
+//         // Wait for connection if not connected
+//         if (listenersCon == null) {
+//            LCD.drawString("waiting", 0, 2);
+//
+//            connector = RS485.getConnector();
+//            listenersCon = connector.waitForConnection(0, NXTConnection.RAW);
+//
+//            if (con != null) {
+//               lisdis = con.openDataInputStream();
+//               lisdos = con.openDataOutputStream();
+//            }
+//            LCD.drawString("Connected", 0, 2);
+//            LCD.refresh();
+//         }
+//}
+//   }
+   
+   }
\ No newline at end of file
diff --git a/src/utilities/Responder.java b/src/utilities/Responder.java
index 89c8063..b34a4ec 100644
--- a/src/utilities/Responder.java
+++ b/src/utilities/Responder.java
@@ -1,9 +1,12 @@
 package utilities;
 
 import lejos.nxt.LCD;
+import lejos.nxt.MotorPort;
 import lejos.nxt.comm.Bluetooth;
 import lejos.nxt.comm.LCPResponder;
 import lejos.nxt.comm.NXTCommConnector;
+import lejos.nxt.comm.NXTConnection;
+import lejos.nxt.comm.RConsole;
 import lejos.nxt.comm.RS485;
 
 /**
@@ -17,6 +20,7 @@ import lejos.nxt.comm.RS485;
  * 
  */
 public class Responder {
+	
 	/**
 	 * The subclass that handles the LCP connections. In particular, it is modified version of the LCPResponder to shutdown the connection once the program disconnects.
 	 * @author Andy Shaw
@@ -43,10 +47,13 @@ public class Responder {
 	 */
 	
 	public static void main(String[] args) throws Exception {
+		//RConsole.openUSB(20000);
 		LCD.drawString("Connecting", 1, 1);
-		ResponderTool resp = new ResponderTool(RS485.getConnector());
-		resp.start();
-		resp.join();
+		//ResponderTool resp = new ResponderTool(RS485.getConnector());
+		//resp.start();
+		//resp.join();
+		NXTRemoteMotorControl motorControl = new NXTRemoteMotorControl(MotorPort.A, MotorPort.B, MotorPort.C);
+		motorControl.start();
 		
     }
 	

commit 482268b0581a0fbd749388ea2aa3a37dba3aded7
Author: RileyvanRyswyk <rileyvan@gmail.com>
Date:   Fri Nov 22 11:25:20 2013 -0500

    Updated Claw and Forklift

diff --git a/src/hardwareAbstraction/Claw.java b/src/hardwareAbstraction/Claw.java
index 36cae96..05221db 100644
--- a/src/hardwareAbstraction/Claw.java
+++ b/src/hardwareAbstraction/Claw.java
@@ -6,7 +6,7 @@ import lejos.nxt.remote.RemoteMotor;
 
 public class Claw {
 	static RemoteMotor claw = Settings.clawMotor;
-	static int value = 90; // 45 degrees. needs to be tested. 
+	static int value = 70; // 45 degrees. needs to be tested. 
 	
 	/**
 	 * This method grabs an object. Returns nothing
diff --git a/src/hardwareAbstraction/Forklift.java b/src/hardwareAbstraction/Forklift.java
index ae43765..aa809d6 100644
--- a/src/hardwareAbstraction/Forklift.java
+++ b/src/hardwareAbstraction/Forklift.java
@@ -11,7 +11,7 @@ public class Forklift {
 	static int scanHeight = 10; // 10 cm upwards. Needs to be tested. 
 	static int scanHeightLow = 7; // 7 cm upwards. Needs to be tested. 
 	private static double radius = 1; //radius of "spool". Must be tested. 
-	public static ForkliftState state = ForkliftState.GROUND; //sensor starts on the ground.
+	public static ForkliftState state = ForkliftState.SCAN_HEIGHT; //sensor starts on the ground.
 //	/**
 //	 * This method lifts an object. Returns nothing.
 //	 * @bug the execution of external motors causes exceptions. Try-catch block was put for now. Must be fixed. 

commit 7c209aa05d7084227b7b1d012f985e95e83863ec
Author: RileyvanRyswyk <rileyvan@gmail.com>
Date:   Fri Nov 22 11:25:07 2013 -0500

    Reset function added when stopping the brick.

diff --git a/src/launcher/Launcher.java b/src/launcher/Launcher.java
index a2a20be..5b3a6fc 100644
--- a/src/launcher/Launcher.java
+++ b/src/launcher/Launcher.java
@@ -43,7 +43,7 @@ public class Launcher {
 			manager.um.nap(150);
 		}*/
 		
-		sleep(Forklift.setHeight(ForkliftState.SCAN_HEIGHT_LOW));
+		//sleep(Forklift.setHeight(ForkliftState.SCAN_HEIGHT_LOW));
 		
 //		manager.sm.odoCorrection.start();
 		manager.hm.ultrasonicPoller.start();
@@ -72,7 +72,7 @@ public class Launcher {
 //		manager.cm.setState(State.COLLECT);
 		
 		Button.waitForPress();
-	
+		manager.hm.reset();
 	}
 	
 	private static void sleep(int time){
diff --git a/src/manager/HardwareManager.java b/src/manager/HardwareManager.java
index 731497c..b394455 100644
--- a/src/manager/HardwareManager.java
+++ b/src/manager/HardwareManager.java
@@ -1,5 +1,6 @@
 package manager;
 
+import controllers.State;
 import hardwareAbstraction.*;
 
 public class HardwareManager {
@@ -23,4 +24,12 @@ public class HardwareManager {
 		this.linePoller = new LinePoller();
 		this.ultrasonicPoller = new UltrasonicPoller(manager);
 	}
+	
+	public void reset() {
+		manager.cm.setState(State.PAUSE);
+		drive.stop();		
+		Claw.grabObject();
+		Forklift.setHeight(Forklift.ForkliftState.SCAN_HEIGHT);
+		UltrasonicMotor.setForwardPosition();
+	}
 }

commit 15a1fd593e467a23fb663cc0630d17c0251eb954
Author: RileyvanRyswyk <rileyvan@gmail.com>
Date:   Fri Nov 22 11:24:47 2013 -0500

    Search update.  Not tested yet as it requires improved remote motors. also LCD screen was updated to include more info.

diff --git a/src/controllers/Search.java b/src/controllers/Search.java
index dbcfed6..ff4c68a 100644
--- a/src/controllers/Search.java
+++ b/src/controllers/Search.java
@@ -1,5 +1,6 @@
 package controllers;
 
+import hardwareAbstraction.UltrasonicMotor;
 import utilities.Point;
 import manager.Manager;
 
@@ -16,6 +17,17 @@ public class Search extends Controller  {
 	
 	public void run() {
 		defaultRouter();
+		if(UltrasonicMotor.isForward) {
+			manager.um.nap(UltrasonicMotor.setDefaultPosition());
+			manager.hm.ultrasonicPoller.resetUSP();
+		}
+		
+		Point pointOfInterest = new Point();
+		
+		if(manager.sm.mapper.update(pointOfInterest)) {
+			manager.sm.nav.addToRoute(pointOfInterest);
+		}
+		
 	}
 	/**
 	 * This method will check the route in navigation and add a coordinate in the route. Allows the Navigation to always have "something to do" when nothing interesting is found
@@ -23,11 +35,11 @@ public class Search extends Controller  {
 	private void defaultRouter() {
 		if(manager.sm.nav.getRoute().empty()) {
 			switch(this.defaultPath) {
-			case 0 : manager.sm.nav.addToRoute(new Point(60,60));
+			case 0 : manager.sm.nav.addToRoute(new Point(15,15));
 			break;
-			case 1 : manager.sm.nav.addToRoute(new Point(180,60));
+			case 1 : manager.sm.nav.addToRoute(new Point(15,135));
 			break;
-			case 2 : manager.sm.nav.addToRoute(new Point(00,60));
+			case 2 : manager.sm.nav.addToRoute(new Point(165,45));
 			break;
 			//wont run on the crack
 			case 3 : manager.sm.nav.addToRoute(new Point(00,120)); 
diff --git a/src/hardwareAbstraction/UltrasonicMotor.java b/src/hardwareAbstraction/UltrasonicMotor.java
index 31e3359..916b630 100644
--- a/src/hardwareAbstraction/UltrasonicMotor.java
+++ b/src/hardwareAbstraction/UltrasonicMotor.java
@@ -3,19 +3,19 @@ package hardwareAbstraction;
 import utilities.Settings;
 
 public class UltrasonicMotor {
-	public static boolean isForward = false;
+	public static boolean isForward = true;
 
 	/**
 	 * The default position is set to be with the two side ultrasonic sensors
 	 * pointing away from the center of the robot. Therefore, it will be at an
 	 * angle when viewed from the front of the robot.
 	 */
-	public static int setDefaultPosition() {
-		isForward = false;
+	public static synchronized int setDefaultPosition() {
 		try {
 			Settings.ultrasonicMotor.setAcceleration(200);
 			Settings.ultrasonicMotor.setSpeed(200);
-			Settings.ultrasonicMotor.rotateTo(45, true);
+			Settings.ultrasonicMotor.rotateTo(-90, true);
+			isForward = false;
 		} catch (ArrayIndexOutOfBoundsException e) {
 		} 
 		return 2000;
@@ -26,12 +26,13 @@ public class UltrasonicMotor {
 	 * pointing directly ahead, in line with the centre ultrasonic sensor. Therefore, it will be at an
 	 * angle when viewed from the front of the robot.
 	 */
-	public static int setForwardPosition() {
-		isForward = true;
+	public static synchronized int setForwardPosition() {
+		
 		try {
 			Settings.ultrasonicMotor.setAcceleration(200);
 			Settings.ultrasonicMotor.setSpeed(200);
-			Settings.ultrasonicMotor.rotateTo(-45, true);
+			Settings.ultrasonicMotor.rotateTo(0, true);
+			isForward = true;
 		} catch (ArrayIndexOutOfBoundsException e) {
 		} 
 		return 2000;
diff --git a/src/hardwareAbstraction/UltrasonicPoller.java b/src/hardwareAbstraction/UltrasonicPoller.java
index 4a713bf..a5df636 100644
--- a/src/hardwareAbstraction/UltrasonicPoller.java
+++ b/src/hardwareAbstraction/UltrasonicPoller.java
@@ -141,7 +141,7 @@ public class UltrasonicPoller implements TimerListener {
 	 * this by checking for any negative numbers in the readings.
 	 */
 	public boolean isSetup() {
-		if (readings[2][4] == -1)
+		if (readings[2][4] == -1 || readings[0][4] == -1 || readings[1][4] == -1)
 			return false;
 		else
 			return true;
@@ -167,7 +167,7 @@ public class UltrasonicPoller implements TimerListener {
 
 		// makes sure readings array is full of values so we have enough to
 		// filter with
-		if (readings[2][4] > -1) {
+		if (readings[sensor][4] > -1) {
 
 			// initialize vars
 			int size = 5;
@@ -214,7 +214,7 @@ public class UltrasonicPoller implements TimerListener {
 		for (int usReadings[] : readings) {
 			int i = 0;
 			for (int reading : usReadings) {
-				if (minValue > reading)
+				if (minValue > reading && reading != -1)
 					minValue = reading;
 				++i;
 			}
@@ -243,7 +243,7 @@ public class UltrasonicPoller implements TimerListener {
 		int smallestSensor = 0;
 		for (int usReadings[] : readings) {
 			for (int reading : usReadings) {
-				if (minValue > reading) {
+				if (minValue > reading && reading != -1) {
 					minValue = reading;
 					smallestSensor = sensor;
 				}
diff --git a/src/services/LCDInfo.java b/src/services/LCDInfo.java
index e89282d..1404288 100644
--- a/src/services/LCDInfo.java
+++ b/src/services/LCDInfo.java
@@ -1,6 +1,9 @@
 package services;
 
+
+
 import utilities.Angle;
+import utilities.Point;
 import utilities.Position;
 import lejos.nxt.LCD;
 import lejos.util.Timer;
@@ -8,9 +11,10 @@ import lejos.util.TimerListener;
 import manager.Manager;
 
 public class LCDInfo implements TimerListener{
-	public static final int LCD_REFRESH = 100;
+	public static final int LCD_REFRESH = 300;
 	private Manager manager;
 	private Timer lcdTimer;
+	public double debugValue = Double.NaN;
 	
 	/**
 	 * LCDInfo constructor
@@ -35,6 +39,26 @@ public class LCDInfo implements TimerListener{
 		LCD.drawInt((int)(pos.x * 10), 3, 0);
 		LCD.drawInt((int)(pos.y * 10), 3, 1);
 		LCD.drawInt(Angle.radToDeg(pos.theta), 3, 2);
+		
+		LCD.drawString("L: ", 0, 4);
+		LCD.drawString("C: ", 0, 5);
+		LCD.drawString("R: ", 0, 6);
+		LCD.drawInt(manager.hm.ultrasonicPoller.getUSReading(0), 3, 4);
+		LCD.drawInt(manager.hm.ultrasonicPoller.getUSReading(1), 3, 5);
+		LCD.drawInt(manager.hm.ultrasonicPoller.getUSReading(2), 3, 6);
+		
+		LCD.drawString("D: ", 0, 7);
+		LCD.drawString(String.valueOf(debugValue), 3, 7);
+		
+		if(!manager.sm.nav.getRoute().empty()) {
+			Point next = manager.sm.nav.getRoute().peek();
+			
+			LCD.drawString("PX: ", 8, 0);
+			LCD.drawString("PY: ", 8, 1);
+			LCD.drawInt((int)(next.x * 10), 11, 0);
+			LCD.drawInt((int)(next.y * 10), 11, 1);
+		}
+		
 	}
 
 }
diff --git a/src/services/Mapper.java b/src/services/Mapper.java
index 3a43c75..e41654f 100644
--- a/src/services/Mapper.java
+++ b/src/services/Mapper.java
@@ -1,10 +1,152 @@
 package services;
 
+import hardwareAbstraction.UltrasonicMotor;
+import utilities.Point;
+import utilities.Position;
 import manager.*;
 
 public class Mapper {
 
+	private final int THRESHOLD = 15;
+	private final double ANGLE_THRESHOLD = 0.15;
+	private final int WIDTH_THRESHOLD = 10;
+	
+	private int[] currentValue;
+	private int[] previousValue;
+	private Position[] start;
+	private int[] startValue;
+	private boolean[] startSet;
+	
+	//To match ultrasonic Poller
+	private final int left = 0;
+	private final int right = 2;
+	
+	
+	
+	Manager manager;
+	
 	public Mapper(Manager manager) {
+		this.manager = manager;
+		previousValue = new int[3];
+		start = new Position[3];
+		currentValue = new int[3];
+		startSet = new boolean[]{false, false, false};
+	}
+	
+	public boolean update(Point returnPoint) {
+		if(!UltrasonicMotor.isForward) {
+			currentValue[left] = manager.hm.ultrasonicPoller.getUSReading(left);
+			currentValue[right] = manager.hm.ultrasonicPoller.getUSReading(right);
+			
+			if(!start(left)) {
+				if(end(left)) {
+					if(calculatePoint(left,returnPoint)) {
+						return true;
+					}					
+				}
+			}
+			
+			if(!start(right)) {
+				if(end(right)) {
+					if(calculatePoint(right,returnPoint)) {
+						return true;
+					}
+				}
+			}
+		}
+		
+		return false;
+	}
+	
+	
+	private boolean calculatePoint(int sensor, Point returnPoint) {
+		Position end = manager.sm.odo.getPosition();
+		
+		if(Math.abs(end.theta-start[sensor].theta) < ANGLE_THRESHOLD) {
+			double dx = end.x - start[sensor].x;
+			double dy = end.y - start[sensor].y;
+			
+			if(Math.abs(dx) > WIDTH_THRESHOLD) {
+				returnPoint.x = end.x - dx/2;
+				returnPoint.y = end.y;
+				
+				
+				if(Math.cos(end.x) > 0) {
+					if(sensor == left) {
+						returnPoint.y += calculateDistanceToObject(startValue[sensor], currentValue[sensor]);
+					} else {
+						returnPoint.y -= calculateDistanceToObject(startValue[sensor], currentValue[sensor]);
+					}
+				}
+				else {
+					if(sensor == right) {
+						returnPoint.y += calculateDistanceToObject(startValue[sensor], currentValue[sensor]);
+					} else {
+						returnPoint.y -= calculateDistanceToObject(startValue[sensor], currentValue[sensor]);
+					}
+				}
+				
+			} else if(Math.abs(dy) > WIDTH_THRESHOLD) {
+				returnPoint.y = end.y - dy/2;
+				returnPoint.x = end.x;
+				
+				if(Math.sin(end.x) > 0) {
+					if(sensor == left) {
+						returnPoint.x -= calculateDistanceToObject(startValue[sensor], currentValue[sensor]);
+					} else {
+						returnPoint.x += calculateDistanceToObject(startValue[sensor], currentValue[sensor]);
+					}
+				}
+				else {
+					if(sensor == right) {
+						returnPoint.x -= calculateDistanceToObject(startValue[sensor], currentValue[sensor]);
+					} else {
+						returnPoint.x += calculateDistanceToObject(startValue[sensor], currentValue[sensor]);
+					}
+				}
+				
+			}
+			
+			return true;
+		} else {
+			return false;
+		}
+		
 		
+		
+	}
+	
+	private int calculateDistanceToObject(int start, int end) {
+		if(start == end) {
+			return start;
+		} else if( start > end ) {
+			return end;
+		} else {
+			return start;
+		}
+	}
+	
+	private boolean start(int sensor) {
+		if((currentValue[sensor] - previousValue[sensor] < -THRESHOLD) && !startSet[sensor]) {
+			//store the starting point
+			start[sensor] = manager.sm.odo.getPosition();
+			startSet[sensor] = true;
+			startValue[sensor] = currentValue[sensor];
+			return true;
+		} else {
+			return false;
+		}
+		
+	}
+	
+	private boolean end(int sensor) {
+		if((previousValue[sensor] - currentValue[sensor] < -15 || (previousValue[sensor] == 255 && currentValue[sensor] != 255)) && startSet[sensor]) {
+			startSet[sensor] = false;
+			return true;
+		} else {
+			return false;
+		}
 	}
+	
+	
 }
diff --git a/src/services/Navigation.java b/src/services/Navigation.java
index ff4ebe1..7b71896 100644
--- a/src/services/Navigation.java
+++ b/src/services/Navigation.java
@@ -95,16 +95,13 @@ public class Navigation implements TimerListener {
 						 * sensor. Therefore 5 seconds should be long enough
 						 * (until we can test otherwise).
 						 */
-						
-						int lowest = manager.hm.ultrasonicPoller.getLowestReading();
-						try {
-							Thread.sleep(1000);
-						} catch (InterruptedException e) {
-							e.printStackTrace();
+						manager.hm.ultrasonicPoller.resetUSP();
+						while(!manager.hm.ultrasonicPoller.isSetup()) {
+							manager.um.nap(200);
 						}
-						sleep(UltrasonicMotor.setDefaultPosition());
-						
-						
+						int lowest = manager.hm.ultrasonicPoller.getLowestReading();
+						manager.sm.lcdInfo.debugValue = lowest;
+												
 						if (lowest < 20) {
 							RConsole.println("Read less than 20");
 //							Sound.beepSequenceUp();
@@ -116,10 +113,16 @@ public class Navigation implements TimerListener {
 						else if (lowest < 50) {
 							RConsole.println("Read less than 30");
 							RConsole.println("Pushing the following to the stack" + manager.sm.odo.getPosition().addDistanceToPosition(lowest - 5));
-							route.push(manager.sm.odo.getPosition().addDistanceToPosition(lowest - Settings.clawToUSDistance));
+							//route.push(manager.sm.odo.getPosition().addDistanceToPosition(lowest - Settings.clawToUSDistance));
+							sleep(UltrasonicMotor.setDefaultPosition());
 							manager.cm.setState(State.SEARCH);
 							Sound.beepSequence();
 						} else {
+							sleep(UltrasonicMotor.setDefaultPosition());
+							manager.hm.ultrasonicPoller.resetUSP();
+							while(!manager.hm.ultrasonicPoller.isSetup()) {
+								manager.um.nap(200);
+							}
 							manager.cm.setState(State.SEARCH);
 							Sound.beep();
 							// do no processing, just continue along doing nothing. 

commit 7b581fb58fd778e22fd01b54420293ae82fd6b71
Author: Nicole <witternicole@gmail.com>
Date:   Thu Nov 21 17:55:13 2013 -0500

    Updated Localization for different corners

diff --git a/src/services/Localization.java b/src/services/Localization.java
index 495df11..90066ed 100644
--- a/src/services/Localization.java
+++ b/src/services/Localization.java
@@ -105,15 +105,16 @@ public class Localization implements TimerListener {
 			//move to correct orientation for line localization
 			if(!lineLocalization) {
 				prepareLineLocalization();
-			} else {
+			}else{
 				lineLocalization();
-			}
+				}
 		} 
 		//localization complete, update position
 		else {
 			stop();
 			updatePosition();
-			manager.cm.setState(State.SEARCH);
+			adjustForStartingCorner();
+			manager.cm.setState(State.TESTING);
 		}
 	}
 	
@@ -172,17 +173,6 @@ public class Localization implements TimerListener {
 			}
 		}
 		
-		/*
-		 * Adjust for the starting corner
-		 */
-		if(Settings.startingCorner == StartingCorner.BOTTOM_RIGHT) {
-			deltaTheta -= Math.PI/2;
-		} else if (Settings.startingCorner == StartingCorner.TOP_RIGHT) {
-			deltaTheta -= Math.PI;
-		} else if (Settings.startingCorner == StartingCorner.TOP_LEFT) {
-			deltaTheta += Math.PI/2;
-		}
-		
 		//update the odometer
 		manager.sm.odo.adjustPosition(0, 0, deltaTheta);
 		
@@ -224,31 +214,44 @@ public class Localization implements TimerListener {
 	}
 	
 	public void prepareLineLocalization() {
-		if(manager.sm.odo.getTheta() > lineLocalizationStartingOrientation() + 0.2 ) {
+		if(manager.sm.odo.getTheta() > (Math.PI/4 + 0.2)) {
 			manager.hm.drive.setSpeeds(0, ROTATION_SPEED);
-		} else if(manager.sm.odo.getTheta() < lineLocalizationStartingOrientation() - 0.2 ) {
+		} else if(manager.sm.odo.getTheta() < (Math.PI/4  - 0.2)) {
 			manager.hm.drive.setSpeeds(0, -ROTATION_SPEED);
 		} else {
+			Sound.buzz();
 			manager.hm.drive.setSpeeds(0, ROTATION_SPEED);
 			lineLocalization = true;
 			rightLineCount = 0;
 			leftLineCount = 4;					
 		}
+	
 	}
 	
+	
+	
 	/**
 	 * returns the desired starting angle for line localization
 	 */
-	public double lineLocalizationStartingOrientation() {
+	public void adjustForStartingCorner() {
+		double x1 = manager.sm.odo.getX();
+		double y1 = manager.sm.odo.getY();
+		double deltaTheta = manager.sm.odo.getTheta();
+		
 		if(Settings.startingCorner == StartingCorner.BOTTOM_RIGHT) {
-			return 3.0 * Math.PI / 4.0;
+			deltaTheta += Math.PI/2;
+			manager.sm.odo.setPosition(new Position(-y1, x1, deltaTheta));
+			//return 3.0 * Math.PI / 4.0;
+			
 		} else if (Settings.startingCorner == StartingCorner.TOP_RIGHT) {
-			return 5.0 * Math.PI / 4.0;
+			deltaTheta += Math.PI;
+			manager.sm.odo.setPosition(new Position(-x1, -y1, deltaTheta));
+			//return 5.0 * Math.PI / 4.0;
 		} else if (Settings.startingCorner == StartingCorner.TOP_LEFT) {
-			return 7.0 * Math.PI / 4.0;
-		} else {
-			return Math.PI / 4.0;
-		}
+			deltaTheta -= Math.PI/2;
+			manager.sm.odo.setPosition(new Position(y1, -x1, deltaTheta));
+			//return 7.0 * Math.PI / 4.0;
+		} 
 	}
 
 	
@@ -263,11 +266,13 @@ public class Localization implements TimerListener {
 	public void checkLineSensor(boolean rightSensor) {
 		if(manager.hm.linePoller.enteringLine((rightSensor) ? 1 : 0)) {
 			if(rightSensor && rightLineCount < 4) {
+				Sound.beep();
 				lineDetectedHeadings[rightLineCount] = manager.sm.odo.getTheta();
 				rightLineCount++;
 			} else if (leftLineCount < 8) {
 				lineDetectedHeadings[leftLineCount] = manager.sm.odo.getTheta();
 				leftLineCount++;
+				Sound.beep();
 			}
 		}
 	}	

commit bf304c3d58ccecc9d58d04a79e26386d0abf468c
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Wed Nov 20 16:05:04 2013 -0500

    Finished testing the collect sequence. There is a concurrency error in
    the forklift motors for the moment. Code will be written to stop this.

diff --git a/src/controllers/Recognize.java b/src/controllers/Recognize.java
index ad7e249..0681916 100644
--- a/src/controllers/Recognize.java
+++ b/src/controllers/Recognize.java
@@ -17,20 +17,9 @@ import manager.Manager;
 public class Recognize extends Controller {
 
 private Manager manager;
-private boolean isSetup;
-private Stack<Point> prevRoute;
-private int lowValue;
-private int highValue;
-private final int middle = 1;
-private boolean inPosition;
 
-	
 	public Recognize(Manager manager) {
 		this.manager = manager;
-		this.isSetup = false;
-		this.lowValue = -1; // reading when the forklift is down
-		this.highValue = -1; // reading when the forklift is up.
-		this.inPosition = false;
 	}
 	
 	public void run() {
diff --git a/src/hardwareAbstraction/Forklift.java b/src/hardwareAbstraction/Forklift.java
index aec34ce..ae43765 100644
--- a/src/hardwareAbstraction/Forklift.java
+++ b/src/hardwareAbstraction/Forklift.java
@@ -11,7 +11,7 @@ public class Forklift {
 	static int scanHeight = 10; // 10 cm upwards. Needs to be tested. 
 	static int scanHeightLow = 7; // 7 cm upwards. Needs to be tested. 
 	private static double radius = 1; //radius of "spool". Must be tested. 
-	public static ForkliftState state = ForkliftState.SCAN_HEIGHT_LOW; //sensor starts on the ground.
+	public static ForkliftState state = ForkliftState.GROUND; //sensor starts on the ground.
 //	/**
 //	 * This method lifts an object. Returns nothing.
 //	 * @bug the execution of external motors causes exceptions. Try-catch block was put for now. Must be fixed. 
@@ -72,10 +72,11 @@ public class Forklift {
 //		changeHeight(scanHeight);
 //	}
 	
-	public static int setHeight(ForkliftState s) {
+	public static synchronized int setHeight(ForkliftState s) {
 		int height;
 		int oldHeight;
 		
+//		Thread thread = new Thread();
 		if(state == ForkliftState.GROUND)
 			oldHeight = 0;
 		else if(state == ForkliftState.LIFT_HEIGHT)
diff --git a/src/launcher/Launcher.java b/src/launcher/Launcher.java
index d19f4f5..a2a20be 100644
--- a/src/launcher/Launcher.java
+++ b/src/launcher/Launcher.java
@@ -43,6 +43,8 @@ public class Launcher {
 			manager.um.nap(150);
 		}*/
 		
+		sleep(Forklift.setHeight(ForkliftState.SCAN_HEIGHT_LOW));
+		
 //		manager.sm.odoCorrection.start();
 		manager.hm.ultrasonicPoller.start();
 		manager.sm.nav.start();
@@ -72,5 +74,12 @@ public class Launcher {
 		Button.waitForPress();
 	
 	}
+	
+	private static void sleep(int time){
+		try {
+		Thread.sleep(time);
+		} catch (InterruptedException e) {
+		}
+	}
 
 }
diff --git a/src/services/Navigation.java b/src/services/Navigation.java
index 9785e1c..ff4ebe1 100644
--- a/src/services/Navigation.java
+++ b/src/services/Navigation.java
@@ -113,10 +113,10 @@ public class Navigation implements TimerListener {
 							Sound.twoBeeps();
 							
 						}
-						else if (lowest < 30) {
+						else if (lowest < 50) {
 							RConsole.println("Read less than 30");
 							RConsole.println("Pushing the following to the stack" + manager.sm.odo.getPosition().addDistanceToPosition(lowest - 5));
-							route.push(manager.sm.odo.getPosition().addDistanceToPosition(lowest - 5));
+							route.push(manager.sm.odo.getPosition().addDistanceToPosition(lowest - Settings.clawToUSDistance));
 							manager.cm.setState(State.SEARCH);
 							Sound.beepSequence();
 						} else {
@@ -134,7 +134,8 @@ public class Navigation implements TimerListener {
 					// destination.
 					manager.hm.drive.stop();
 					scannedAhead = false;
-					route.pop();
+					if(!route.empty())
+						route.pop();
 				}
 
 			}

commit e732830bec5fdfaf1e39c3fcd89dce1aa705e49a
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Wed Nov 20 03:22:22 2013 -0500

    Small change to UltrasonicMotor that was not done earlier. This should
    avoid thrown exceptions.

diff --git a/src/hardwareAbstraction/UltrasonicMotor.java b/src/hardwareAbstraction/UltrasonicMotor.java
index 37f0761..31e3359 100644
--- a/src/hardwareAbstraction/UltrasonicMotor.java
+++ b/src/hardwareAbstraction/UltrasonicMotor.java
@@ -31,7 +31,7 @@ public class UltrasonicMotor {
 		try {
 			Settings.ultrasonicMotor.setAcceleration(200);
 			Settings.ultrasonicMotor.setSpeed(200);
-			Settings.ultrasonicMotor.rotate(-45);
+			Settings.ultrasonicMotor.rotateTo(-45, true);
 		} catch (ArrayIndexOutOfBoundsException e) {
 		} 
 		return 2000;

commit 66ff60a38bd2f6c5abba56b4f2a3072123d3e3ca
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Wed Nov 20 03:19:44 2013 -0500

    Cleaned up and fixed potential bugs in Recognize and Collect classes.
    Added constant value to Settings

diff --git a/src/controllers/Collect.java b/src/controllers/Collect.java
index 407e741..e1032db 100644
--- a/src/controllers/Collect.java
+++ b/src/controllers/Collect.java
@@ -1,5 +1,9 @@
 package controllers;
 
+import java.util.Stack;
+
+import utilities.Point;
+import utilities.Position;
 import utilities.Settings;
 import hardwareAbstraction.Claw;
 import hardwareAbstraction.Forklift;
@@ -10,6 +14,8 @@ import manager.Manager;
 public class Collect extends Controller {
 
 private Manager manager;
+private Stack<Point> oldRoute;
+private static boolean setup = false;
 	
 	public Collect(Manager manager) {
 		this.manager = manager;
@@ -20,20 +26,48 @@ private Manager manager;
 	 * Maintains the singleton design of this system. 
 	 */
 	public void run() {
-		//pause the re-execution
-		manager.cm.setState(State.PAUSE);
-		
-		//grab and lift
-		sleep(Claw.grabObject());
-		sleep(Forklift.setHeight(ForkliftState.LIFT_HEIGHT));
+		/*
+		 * Setup will stop the robot, add a new destination closer to the object to pick it up
+		 */
+		if (!setup) {
+			setup = true;
+
+			// stop navigation for the moment.
+			oldRoute = manager.sm.nav.getRoute();
+			manager.sm.nav.setRoute(new Stack<Point>());
+			manager.hm.drive.stop();
+
+			// setup claw and navigate towards the block
+			sleep(Claw.releaseObject());
+			Position currentPos = manager.sm.odo.getPosition();
+			
+			//navigate towards block
+			final int clawOffset = Settings.clawToUSDistance;
+			int distance = manager.hm.ultrasonicPoller.getUSReading(1) - clawOffset < 0 ? 0 : manager.hm.ultrasonicPoller.getUSReading(1) - clawOffset;
+			manager.sm.nav.addToRoute(currentPos.addDistanceToPosition(distance));
+		}
+		/*
+		 * Once the robot is in position to pickup the object, it will then grab the object and lift it. 
+		 * It will then pass on control to DropOff.java or Search.java depending on if the block "hopper" is full. 
+		 */
+		if (manager.sm.nav.getRoute().empty()) {
+			// grab and lift
+			sleep(Claw.grabObject());
+			sleep(Forklift.setHeight(ForkliftState.LIFT_HEIGHT));
 
-		//update storage count and go to the required next step (searching or dropping off).
-		RConsole.println("storage");
-		manager.cm.setStored(manager.cm.getStored() + 1);
-		if(manager.cm.getStored() >= Settings.maxBlockCapacity)
-			manager.cm.setState(State.DROP_OFF);
-		else
-			manager.cm.setState(State.SEARCH);
+			// update storage count and go to the required next step (searching
+			// or dropping off).
+			manager.cm.setStored(manager.cm.getStored() + 1);
+			// reset old route and add next destination to it
+			manager.sm.nav.setRoute(oldRoute);
+			if (manager.cm.getStored() >= Settings.maxBlockCapacity)
+				manager.cm.setState(State.DROP_OFF);
+			else
+				manager.cm.setState(State.SEARCH);
+			
+			//clean up method.
+			setup = false;
+		}
 	}
 	
 	public static void sleep(int num) {
diff --git a/src/controllers/Recognize.java b/src/controllers/Recognize.java
index 73ebfe9..ad7e249 100644
--- a/src/controllers/Recognize.java
+++ b/src/controllers/Recognize.java
@@ -34,144 +34,57 @@ private boolean inPosition;
 	}
 	
 	public void run() {
-		//setup the recognize parameters at the start, only does this once. 
-		if (!isSetup) {
-			//ensure the robot only sets up once and does nothing else until its done setting up.
-			this.isSetup = true;
-			this.inPosition = false;
-			manager.cm.setState(State.PAUSE);
-			
-			/*
-			 * Get readings necessary from the USP
-			 */
-			USPosition lowestSensor = manager.hm.ultrasonicPoller.getLowestSensor();
-			int lowestValue = manager.hm.ultrasonicPoller.getLowestReading();
-			
-			/*
-			 * Turn the robot to face the lowest sensor reading. The goal is
-			 * after this, the robot will face directly towards the robot.
-			 */
-			//10 centimeters separate the side sensors and the center sensor.
-//			final int sensorOffset = 10; 
-//			double angle = Math.tan( sensorOffset / lowestValue);
-			
-			//TODO this is bugged. TurnToComplete does not work. 
-//			if(lowestSensor == USPosition.LEFT)
-//				manager.sm.nav.turnToComplete(manager.sm.odo.getTheta() - angle);
-//			if(lowestSensor == USPosition.RIGHT)
-//				manager.sm.nav.turnToComplete(manager.sm.odo.getTheta() + angle);
-//			
-			
-			RConsole.println("Setting up");
-			
-			
-			//set navigation to do nothing for the moment. 
-//			this.prevRoute = manager.sm.nav.getRoute();
-//			manager.sm.nav.setRoute(new Stack<Point>());
-			
-			// Sample object
-			sleep(Forklift.setHeight(ForkliftState.GROUND));
-			sleep(Claw.grabObject());
-			
-			// start the colorSensor to determine what hte block is. 
-			manager.hm.colorPoller.start();
-			try {
-				Thread.sleep(5000);
-			} catch (InterruptedException e) {
-			}
-			manager.cm.setState(State.RECOGNIZE);
-			inPosition = true;
-			
-//			// reset ultrasonic sensor
-//			manager.hm.ultrasonicPoller.resetUSP();
-//			
-//			//now return to previous state.
-//			manager.cm.setState(State.RECOGNIZE);
-//
-//			// if not at scan height, set it to that
-//			if(Forklift.state == Forklift.ForkliftState.LIFT_HEIGHT) {
-//				manager.cm.setState(State.PAUSE);
-//				Forklift.setHeight(ForkliftState.GROUND);
-//				manager.cm.setState(State.RECOGNIZE);
-//			}
-//			if (Forklift.state != Forklift.ForkliftState.SCAN_HEIGHT) {
-//				manager.cm.setState(State.PAUSE);
-//				Forklift.setHeight(ForkliftState.SCAN_HEIGHT);
-//				manager.cm.setState(State.RECOGNIZE);
-//			}
-			//TODO figure out if we still need the colorPoller or not. 
-			// start the color poller 
-			
-		}
-		//if the color poller has finally collected enough values. 
-		if(manager.hm.colorPoller.isSetup() && inPosition) {
-			sleep(5000);
-			Sound.beepSequence();
-			inPosition = false;
-			sleep(Claw.releaseObject());
-			ObjectDetected object = manager.hm.colorPoller.getObjectReading();
-			if(object == ObjectDetected.BLUE_BLOCK) {
-				Sound.beepSequence();
-				Position currentPos = manager.sm.odo.getPosition();
-				manager.sm.nav.addToRoute(currentPos.addDistanceToPosition(20)); 
-				manager.cm.setState(State.COLLECT);
-			}
-			else
-				Sound.beepSequenceUp();
-				manager.cm.setState(State.SEARCH); //TODO change to wall follower. 
-			
-		}
+		//do nothing else, don't call recognize again. 
+		manager.cm.setState(State.PAUSE);
 		
-//		if (!this.isInPosition) {
-//				RConsole.println("See if the robot needs to correct its navigation");
-//				int midReading = manager.hm.ultrasonicPoller
-//						.getUSReading(middle);
-//
-//				// check if the robot must move to 20 cm from the object, but only when the first reading is taken.
-//				if (midReading != -1) {
-//					// if not 20 cm from the object, then correct the robot to
-//					// be 20 from object
-//					if (midReading < 19 || midReading > 21) {
-//						RConsole.println("The robot is trying to get to the object");
-//						Position currentPos = manager.sm.odo.getPosition();
-//						manager.sm.nav.addToRoute(currentPos
-//								.addDistanceToPosition(20 - midReading)); //TODO debug this method. 
-//					}
-//					this.isInPosition = true;
-//				}
-//				
-//			}
+		//stop any navigation occuring. 
+		manager.hm.drive.stop();
+		Stack<Point> oldRoute = manager.sm.nav.getRoute();
+		manager.sm.nav.setRoute(new Stack<Point>());
 		
-		//once in position, route is empty. 
-//		if(manager.sm.nav.getRoute().empty()) {	
-//			//once the us is setup, get the low and high values. 
-//			if(manager.hm.ultrasonicPoller.isSetup()) {
-//				RConsole.print("Ultrasonic is setup, ");
-//				if (lowValue == -1) {
-//					// set low value. Reset the USP and raise the forklift. 
-//					RConsole.println("Setting lowValue");
-//					this.lowValue = manager.hm.ultrasonicPoller.computeAverage(middle);
-//					manager.hm.ultrasonicPoller.resetUSP();
-//					Forklift.setHeight(ForkliftState.SCAN_HEIGHT);
-//				} else {
-//					RConsole.println("Setting highValue");
-//					this.highValue = manager.hm.ultrasonicPoller.computeAverage(middle);
-//					
-//					//if an obstacle, the difference of the low and high values will be low. Otherwise it will be huge. 
-//					if(this.highValue - this.lowValue > 50) { //if a styrofoam block
-//						RConsole.println("Collection executed now.");
-//						manager.cm.setState(State.COLLECT);
-//					}
-//					else {
-//						RConsole.println("Wall Follower now");
-//						manager.cm.setState(State.WALL_FOLLOWER);
-//					}
-//					//restore previous state before this execution 
-//					manager.sm.nav.setRoute(this.prevRoute);
-//					this.isSetup = false;
-//				}
-//			}
-//		}
+
+		/*
+		 * Get readings necessary from the USP
+		 */
+		// USPosition lowestSensor =
+		// manager.hm.ultrasonicPoller.getLowestSensor();
+		// int lowestValue = manager.hm.ultrasonicPoller.getLowestReading();
+
+		/*
+		 * Turn the robot to face the lowest sensor reading. The goal is after
+		 * this, the robot will face directly towards the robot.
+		 */
+		// 10 centimeters separate the side sensors and the center sensor.
+		// final int sensorOffset = 10;
+		// double angle = Math.tan( sensorOffset / lowestValue);
+
+		// TODO this is bugged. TurnToComplete does not work.
+		// if(lowestSensor == USPosition.LEFT)
+		// manager.sm.nav.turnToComplete(manager.sm.odo.getTheta() - angle);
+		// if(lowestSensor == USPosition.RIGHT)
+		// manager.sm.nav.turnToComplete(manager.sm.odo.getTheta() + angle);
+		//
+
+		// Setup forklift to sample objects. 
+		sleep(Forklift.setHeight(ForkliftState.GROUND));
+		sleep(Claw.grabObject());
+
+		// sample the object ahead of it
+		manager.hm.colorPoller.start();
+		sleep(5000);
+
+		//
+
+		ObjectDetected object = manager.hm.colorPoller.getObjectReading();
+		if (object == ObjectDetected.BLUE_BLOCK) {
+			manager.sm.nav.setRoute(oldRoute);
+			manager.cm.setState(State.COLLECT);
+		} else {
+			//reset old route
+			manager.sm.nav.setRoute(oldRoute);
+			manager.cm.setState(State.SEARCH); // TODO change to wall follower.
+		}
+
 	}
 	
 	public static void sleep(int num) {
diff --git a/src/utilities/Settings.java b/src/utilities/Settings.java
index 228efe2..3105a3f 100644
--- a/src/utilities/Settings.java
+++ b/src/utilities/Settings.java
@@ -39,4 +39,6 @@ public class Settings {
 	public static final double TILE_SIZE = 30.48;
 	public static final int maxBlockCapacity = 1;
 	
+	public static final int clawToUSDistance = 7; //TODO measure this. 
+	
 }

commit d81a7742e464bc4a921441aba65d0a2656faefed
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Wed Nov 20 03:18:50 2013 -0500

    Corrected small annotation in position.

diff --git a/src/utilities/Position.java b/src/utilities/Position.java
index a970a2d..9f5c422 100644
--- a/src/utilities/Position.java
+++ b/src/utilities/Position.java
@@ -21,8 +21,8 @@ public class Position extends Point {
 	}
 
 	/**
-	 * This method assumes the robot is at this position. It adds a distance to
-	 * the position, generating a new position. Useful when the robot needs to
+	 * This method assumes the robot is at this position presently. It adds a distance to
+	 * the position, generating a new {@link Point} object. This is useful when the robot needs to
 	 * travel somewhere in a straight line ahead of it. Formula used for newX
 	 * position is x + deltaX where deltaX is distance * cos(theta). Theta is
 	 * discarded due to logical reasons (the angle the robot ends up at its

commit d1c84822e8eb0fc9c6794f1d2a683fd3e8a7f5b0
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Wed Nov 20 02:31:11 2013 -0500

    Created a prototype for the Search, Recognize and Collect sequence.
    Needs heavy debugging.

diff --git a/src/controllers/Collect.java b/src/controllers/Collect.java
index f4a9012..407e741 100644
--- a/src/controllers/Collect.java
+++ b/src/controllers/Collect.java
@@ -24,15 +24,9 @@ private Manager manager;
 		manager.cm.setState(State.PAUSE);
 		
 		//grab and lift
-		Claw.grabObject();
-		int sleep = Forklift.setHeight(ForkliftState.LIFT_HEIGHT);
-		
-		try {
-			Thread.sleep(sleep);
-		} catch (InterruptedException e) {
-			e.printStackTrace();
-		}
-		
+		sleep(Claw.grabObject());
+		sleep(Forklift.setHeight(ForkliftState.LIFT_HEIGHT));
+
 		//update storage count and go to the required next step (searching or dropping off).
 		RConsole.println("storage");
 		manager.cm.setStored(manager.cm.getStored() + 1);
@@ -42,4 +36,10 @@ private Manager manager;
 			manager.cm.setState(State.SEARCH);
 	}
 	
+	public static void sleep(int num) {
+		try {
+		Thread.sleep(num);
+		} catch(InterruptedException e) {}
+	}
+	
 }
diff --git a/src/controllers/Recognize.java b/src/controllers/Recognize.java
index f71e489..73ebfe9 100644
--- a/src/controllers/Recognize.java
+++ b/src/controllers/Recognize.java
@@ -10,6 +10,7 @@ import hardwareAbstraction.ColorPoller.ObjectDetected;
 import hardwareAbstraction.Forklift;
 import hardwareAbstraction.Forklift.ForkliftState;
 import hardwareAbstraction.UltrasonicPoller.USPosition;
+import lejos.nxt.Sound;
 import lejos.nxt.comm.RConsole;
 import manager.Manager;
 
@@ -21,14 +22,15 @@ private Stack<Point> prevRoute;
 private int lowValue;
 private int highValue;
 private final int middle = 1;
-private boolean isInPosition;
+private boolean inPosition;
+
 	
 	public Recognize(Manager manager) {
 		this.manager = manager;
 		this.isSetup = false;
 		this.lowValue = -1; // reading when the forklift is down
 		this.highValue = -1; // reading when the forklift is up.
-		this.isInPosition = false;
+		this.inPosition = false;
 	}
 	
 	public void run() {
@@ -36,7 +38,7 @@ private boolean isInPosition;
 		if (!isSetup) {
 			//ensure the robot only sets up once and does nothing else until its done setting up.
 			this.isSetup = true;
-			this.isInPosition = false;
+			this.inPosition = false;
 			manager.cm.setState(State.PAUSE);
 			
 			/*
@@ -50,28 +52,35 @@ private boolean isInPosition;
 			 * after this, the robot will face directly towards the robot.
 			 */
 			//10 centimeters separate the side sensors and the center sensor.
-			final int sensorOffset = 10; 
-			double angle = Math.tan( sensorOffset / lowestValue);
-			if(lowestSensor == USPosition.LEFT)
-				manager.sm.nav.turnToComplete(manager.sm.odo.getTheta() - angle);
-			if(lowestSensor == USPosition.RIGHT)
-				manager.sm.nav.turnToComplete(manager.sm.odo.getTheta() + angle);
+//			final int sensorOffset = 10; 
+//			double angle = Math.tan( sensorOffset / lowestValue);
 			
+			//TODO this is bugged. TurnToComplete does not work. 
+//			if(lowestSensor == USPosition.LEFT)
+//				manager.sm.nav.turnToComplete(manager.sm.odo.getTheta() - angle);
+//			if(lowestSensor == USPosition.RIGHT)
+//				manager.sm.nav.turnToComplete(manager.sm.odo.getTheta() + angle);
+//			
 			
 			RConsole.println("Setting up");
 			
 			
 			//set navigation to do nothing for the moment. 
-			this.prevRoute = manager.sm.nav.getRoute();
-			manager.sm.nav.setRoute(new Stack<Point>());
+//			this.prevRoute = manager.sm.nav.getRoute();
+//			manager.sm.nav.setRoute(new Stack<Point>());
 			
 			// Sample object
-			Forklift.setHeight(ForkliftState.GROUND);
-			Claw.grabObject();
+			sleep(Forklift.setHeight(ForkliftState.GROUND));
+			sleep(Claw.grabObject());
 			
 			// start the colorSensor to determine what hte block is. 
 			manager.hm.colorPoller.start();
+			try {
+				Thread.sleep(5000);
+			} catch (InterruptedException e) {
+			}
 			manager.cm.setState(State.RECOGNIZE);
+			inPosition = true;
 			
 //			// reset ultrasonic sensor
 //			manager.hm.ultrasonicPoller.resetUSP();
@@ -95,12 +104,22 @@ private boolean isInPosition;
 			
 		}
 		//if the color poller has finally collected enough values. 
-		if(manager.hm.colorPoller.isSetup()) {
+		if(manager.hm.colorPoller.isSetup() && inPosition) {
+			sleep(5000);
+			Sound.beepSequence();
+			inPosition = false;
+			sleep(Claw.releaseObject());
 			ObjectDetected object = manager.hm.colorPoller.getObjectReading();
-			if(object == ObjectDetected.BLUE_BLOCK)
+			if(object == ObjectDetected.BLUE_BLOCK) {
+				Sound.beepSequence();
+				Position currentPos = manager.sm.odo.getPosition();
+				manager.sm.nav.addToRoute(currentPos.addDistanceToPosition(20)); 
 				manager.cm.setState(State.COLLECT);
+			}
 			else
+				Sound.beepSequenceUp();
 				manager.cm.setState(State.SEARCH); //TODO change to wall follower. 
+			
 		}
 		
 //		if (!this.isInPosition) {
@@ -154,4 +173,10 @@ private boolean isInPosition;
 //			}
 //		}
 	}
+	
+	public static void sleep(int num) {
+		try {
+		Thread.sleep(num);
+		} catch(InterruptedException e) {}
+	}
 }
diff --git a/src/controllers/Search.java b/src/controllers/Search.java
index 42f94df..dbcfed6 100644
--- a/src/controllers/Search.java
+++ b/src/controllers/Search.java
@@ -16,8 +16,6 @@ public class Search extends Controller  {
 	
 	public void run() {
 		defaultRouter();
-		int reading = manager.hm.ultrasonicPoller.getUSReading(middle);
-		
 	}
 	/**
 	 * This method will check the route in navigation and add a coordinate in the route. Allows the Navigation to always have "something to do" when nothing interesting is found
@@ -25,7 +23,7 @@ public class Search extends Controller  {
 	private void defaultRouter() {
 		if(manager.sm.nav.getRoute().empty()) {
 			switch(this.defaultPath) {
-			case 0 : manager.sm.nav.addToRoute(new Point(180,0));
+			case 0 : manager.sm.nav.addToRoute(new Point(60,60));
 			break;
 			case 1 : manager.sm.nav.addToRoute(new Point(180,60));
 			break;
diff --git a/src/hardwareAbstraction/Forklift.java b/src/hardwareAbstraction/Forklift.java
index b0d188e..aec34ce 100644
--- a/src/hardwareAbstraction/Forklift.java
+++ b/src/hardwareAbstraction/Forklift.java
@@ -11,7 +11,7 @@ public class Forklift {
 	static int scanHeight = 10; // 10 cm upwards. Needs to be tested. 
 	static int scanHeightLow = 7; // 7 cm upwards. Needs to be tested. 
 	private static double radius = 1; //radius of "spool". Must be tested. 
-	public static ForkliftState state = ForkliftState.GROUND; //sensor starts on the ground.
+	public static ForkliftState state = ForkliftState.SCAN_HEIGHT_LOW; //sensor starts on the ground.
 //	/**
 //	 * This method lifts an object. Returns nothing.
 //	 * @bug the execution of external motors causes exceptions. Try-catch block was put for now. Must be fixed. 
diff --git a/src/launcher/Launcher.java b/src/launcher/Launcher.java
index fb2dbf7..d19f4f5 100644
--- a/src/launcher/Launcher.java
+++ b/src/launcher/Launcher.java
@@ -3,10 +3,15 @@
  */
 package launcher;
 
+import hardwareAbstraction.Claw;
+import hardwareAbstraction.Forklift;
+import hardwareAbstraction.Forklift.ForkliftState;
+import hardwareAbstraction.UltrasonicMotor;
 import hardwareAbstraction.UltrasonicPoller;
 import utilities.Point;
 import controllers.State;
 import lejos.nxt.Button;
+import lejos.nxt.Sound;
 import lejos.nxt.comm.RConsole;
 import manager.Manager;
 
@@ -27,7 +32,7 @@ public class Launcher {
 	 * @param args
 	 */
 	public static void main(String[] args) {
-		RConsole.openUSB(20000);
+//		RConsole.openBluetooth(20000);
 		
 		
 		Manager manager = new Manager();
@@ -40,10 +45,13 @@ public class Launcher {
 		
 //		manager.sm.odoCorrection.start();
 		manager.hm.ultrasonicPoller.start();
+		manager.sm.nav.start();
+//		manager.sm.nav.turnToComplete(Math.PI);
+		
 		
 		manager.cm.setState(State.SEARCH);
 		
-		manager.sm.nav.addToRoute(new Point(15,15));
+//		manager.sm.nav.addToRoute(new Point(15,15));
 //		manager.sm.nav.addToRoute(new Point(45,15));
 //		manager.sm.nav.addToRoute(new Point(45,165));
 //		manager.sm.nav.addToRoute(new Point(15,165));
@@ -54,7 +62,7 @@ public class Launcher {
 		
 		//manager.cm.setState(State.SEARCH);
 		
-//		manager.sm.nav.start();
+		
 //		manager.cm.setState(State.RECOGNIZE);
 //		manager.sm.nav.addToRoute(new Point(60,0));
 //		manager.sm.nav.turnToComplete(0);
diff --git a/src/services/Navigation.java b/src/services/Navigation.java
index 86f7d13..9785e1c 100644
--- a/src/services/Navigation.java
+++ b/src/services/Navigation.java
@@ -81,11 +81,13 @@ public class Navigation implements TimerListener {
 					// TODO comment back this code. Problematic code for the
 					// moment.
 					if (!scannedAhead) {
+						manager.cm.setState(State.PAUSE);
+						Sound.beep();
 						RConsole.println("Scanning Ahead");
 						scannedAhead = true;
+						
 						manager.hm.drive.stop();
-						this.pause();
-						UltrasonicMotor.setForwardPosition();
+						sleep(UltrasonicMotor.setForwardPosition());
 						/*
 						 * TODO this must be calibrated to the delay experienced
 						 * on the ultrasonic sensor. I want to make sure that 5
@@ -93,29 +95,33 @@ public class Navigation implements TimerListener {
 						 * sensor. Therefore 5 seconds should be long enough
 						 * (until we can test otherwise).
 						 */
-						try {
-							Thread.sleep(5000);
-						} catch (InterruptedException e) {
-						}
+						
 						int lowest = manager.hm.ultrasonicPoller.getLowestReading();
 						try {
 							Thread.sleep(1000);
 						} catch (InterruptedException e) {
 							e.printStackTrace();
 						}
-						UltrasonicMotor.setDefaultPosition();
-						this.start();
+						sleep(UltrasonicMotor.setDefaultPosition());
+						
+						
 						if (lowest < 20) {
 							RConsole.println("Read less than 20");
-							Sound.beepSequenceUp();
+//							Sound.beepSequenceUp();
 							//TODO comment this back in when recognize works. 
-//							manager.cm.setState(State.RECOGNIZE);
+							manager.cm.setState(State.RECOGNIZE);
+							Sound.twoBeeps();
+							
 						}
 						else if (lowest < 30) {
 							RConsole.println("Read less than 30");
 							RConsole.println("Pushing the following to the stack" + manager.sm.odo.getPosition().addDistanceToPosition(lowest - 5));
 							route.push(manager.sm.odo.getPosition().addDistanceToPosition(lowest - 5));
+							manager.cm.setState(State.SEARCH);
+							Sound.beepSequence();
 						} else {
+							manager.cm.setState(State.SEARCH);
+							Sound.beep();
 							// do no processing, just continue along doing nothing. 
 						}
 					} else {
@@ -283,4 +289,11 @@ public class Navigation implements TimerListener {
 		this.scannedAhead = false;
 		this.route.push(xy);
 	}
+	
+	private void sleep(int time){
+		try {
+			Thread.sleep(time);
+		} catch (InterruptedException e) {
+		}
+	}
 }

commit e331ce0e6c8e695217f7f676e3df24fbe10fe2d5
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Tue Nov 19 22:16:02 2013 -0500

    Debugged the claw and ultrasonic motors. They should work relatively ok
    now. The code should be changed to reflect the new mechanism.

diff --git a/src/hardwareAbstraction/Claw.java b/src/hardwareAbstraction/Claw.java
index 030d2d0..36cae96 100644
--- a/src/hardwareAbstraction/Claw.java
+++ b/src/hardwareAbstraction/Claw.java
@@ -12,27 +12,31 @@ public class Claw {
 	 * This method grabs an object. Returns nothing
 	 * @bug the execution of external motors causes exceptions. Try-catch block was put for now. Must be fixed. 
 	 */
-	public static void grabObject() {
+	public static int grabObject() {
 		RConsole.println("grabbing object");
 		try {
+			claw.setAcceleration(200);
 			claw.setSpeed(150);
-			claw.rotate(value);
+			claw.rotateTo(0, true);
 		} catch (ArrayIndexOutOfBoundsException e){
 			
 		}
+		return 2000;
 	}
 	
 	/**
 	 * This method releases an object. Returns nothing
 	 * @bug the execution of external motors causes exceptions. Try-catch block was put for now. Must be fixed. 
 	 */
-	public static void releaseObject() {
+	public static int releaseObject() {
 		RConsole.println("releasing object");
 		try {
+			claw.setAcceleration(200);
 			claw.setSpeed(150);
-			claw.rotate(-value);
+			claw.rotateTo(-value, true);
 		} catch (ArrayIndexOutOfBoundsException e){
 			
 		}
+		return 2000;
 	}
 }
diff --git a/src/hardwareAbstraction/UltrasonicMotor.java b/src/hardwareAbstraction/UltrasonicMotor.java
index d1cf82a..37f0761 100644
--- a/src/hardwareAbstraction/UltrasonicMotor.java
+++ b/src/hardwareAbstraction/UltrasonicMotor.java
@@ -10,13 +10,15 @@ public class UltrasonicMotor {
 	 * pointing away from the center of the robot. Therefore, it will be at an
 	 * angle when viewed from the front of the robot.
 	 */
-	public static void setDefaultPosition() {
+	public static int setDefaultPosition() {
 		isForward = false;
 		try {
+			Settings.ultrasonicMotor.setAcceleration(200);
 			Settings.ultrasonicMotor.setSpeed(200);
-			Settings.ultrasonicMotor.rotate(45);
+			Settings.ultrasonicMotor.rotateTo(45, true);
 		} catch (ArrayIndexOutOfBoundsException e) {
-		}
+		} 
+		return 2000;
 	}
 	
 	/**
@@ -24,13 +26,15 @@ public class UltrasonicMotor {
 	 * pointing directly ahead, in line with the centre ultrasonic sensor. Therefore, it will be at an
 	 * angle when viewed from the front of the robot.
 	 */
-	public static void setForwardPosition() {
+	public static int setForwardPosition() {
 		isForward = true;
 		try {
+			Settings.ultrasonicMotor.setAcceleration(200);
 			Settings.ultrasonicMotor.setSpeed(200);
 			Settings.ultrasonicMotor.rotate(-45);
 		} catch (ArrayIndexOutOfBoundsException e) {
-		}
+		} 
+		return 2000;
 	}
 
 }

commit 6600b413afc80236c687f045e18557726b8c964e
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Tue Nov 19 22:02:01 2013 -0500

    Forklift debugged, now it should work consistently and rotate to the
    right height.

diff --git a/src/hardwareAbstraction/Forklift.java b/src/hardwareAbstraction/Forklift.java
index c3e4224..b0d188e 100644
--- a/src/hardwareAbstraction/Forklift.java
+++ b/src/hardwareAbstraction/Forklift.java
@@ -12,68 +12,78 @@ public class Forklift {
 	static int scanHeightLow = 7; // 7 cm upwards. Needs to be tested. 
 	private static double radius = 1; //radius of "spool". Must be tested. 
 	public static ForkliftState state = ForkliftState.GROUND; //sensor starts on the ground.
-	/**
-	 * This method lifts an object. Returns nothing.
-	 * @bug the execution of external motors causes exceptions. Try-catch block was put for now. Must be fixed. 
-	 */
-	public static void liftObject() {
-		RConsole.println("lifting object");
-		// reset the forklift to ground state.
-		if (state == ForkliftState.SCAN_HEIGHT) {
-			resetScanHeight();
-		}
-		if (state == ForkliftState.LIFT_HEIGHT) {
-			lowerObject();
-		}
-		state = ForkliftState.LIFT_HEIGHT;
-		changeHeight(scanHeight);
-	}
+//	/**
+//	 * This method lifts an object. Returns nothing.
+//	 * @bug the execution of external motors causes exceptions. Try-catch block was put for now. Must be fixed. 
+//	 */
+//	public static void liftObject() {
+//		RConsole.println("lifting object");
+//		// reset the forklift to ground state.
+//		if (state == ForkliftState.SCAN_HEIGHT) {
+//			resetScanHeight();
+//		}
+//		if (state == ForkliftState.LIFT_HEIGHT) {
+//			lowerObject();
+//		}
+//		state = ForkliftState.LIFT_HEIGHT;
+//		changeHeight(scanHeight);
+//	}
+//	
+//	/**
+//	 * This method lowers an object. Returns nothing.
+//	 * @bug the execution of external motors causes exceptions. Try-catch block was put for now. Must be fixed. 
+//	 */
+//	public static void lowerObject() {
+//		RConsole.println("lowering to default position");
+//		if (state == ForkliftState.SCAN_HEIGHT)
+//			resetScanHeight();
+//		if (state == ForkliftState.GROUND)
+//			return;
+//		state = ForkliftState.GROUND;
+//		changeHeight(liftHeight);
+//	}
 	
-	/**
-	 * This method lowers an object. Returns nothing.
-	 * @bug the execution of external motors causes exceptions. Try-catch block was put for now. Must be fixed. 
-	 */
-	public static void lowerObject() {
-		RConsole.println("lowering to default position");
-		if (state == ForkliftState.SCAN_HEIGHT)
-			resetScanHeight();
-		if (state == ForkliftState.GROUND)
-			return;
-		state = ForkliftState.GROUND;
-		changeHeight(liftHeight);
-	}
+//	/**
+//	 * This method will raise the forklift to allow the color sensor to identify the block. 
+//	 * @bug the execution of external motors causes exceptions. Try-catch block was put for now. Must be fixed.
+//	 */
+//	public static int setScanHeight() {
+//		RConsole.println("lifting to scan height");
+//		if (state == ForkliftState.LIFT_HEIGHT)
+//			lowerObject();
+//		if (state == ForkliftState.SCAN_HEIGHT)
+//			return 0;
+//		state = ForkliftState.SCAN_HEIGHT;
+//		
+//		return changeHeight(scanHeight);
+//	}
 	
-	/**
-	 * This method will raise the forklift to allow the color sensor to identify the block. 
-	 * @bug the execution of external motors causes exceptions. Try-catch block was put for now. Must be fixed.
-	 */
-	public static int setScanHeight() {
-		RConsole.println("lifting to scan height");
-		if (state == ForkliftState.LIFT_HEIGHT)
-			lowerObject();
-		if (state == ForkliftState.SCAN_HEIGHT)
-			return 0;
-		state = ForkliftState.SCAN_HEIGHT;
-		
-		return changeHeight(scanHeight);
-	}
-	
-	/**
-	 * This method will lower the forklift after identifying the block. 
-	 * @bug the execution of external motors causes exceptions. Try-catch block was put for now. Must be fixed.
-	 */
-	public static void resetScanHeight() {
-		RConsole.println("lowering to default height");
-		if (state == ForkliftState.LIFT_HEIGHT)
-			lowerObject();
-		if (state == ForkliftState.GROUND)
-			return;
-		state = ForkliftState.GROUND;
-		changeHeight(scanHeight);
-	}
+//	/**
+//	 * This method will lower the forklift after identifying the block. 
+//	 * @bug the execution of external motors causes exceptions. Try-catch block was put for now. Must be fixed.
+//	 */
+//	public static void resetScanHeight() {
+//		RConsole.println("lowering to default height");
+//		if (state == ForkliftState.LIFT_HEIGHT)
+//			lowerObject();
+//		if (state == ForkliftState.GROUND)
+//			return;
+//		state = ForkliftState.GROUND;
+//		changeHeight(scanHeight);
+//	}
 	
 	public static int setHeight(ForkliftState s) {
 		int height;
+		int oldHeight;
+		
+		if(state == ForkliftState.GROUND)
+			oldHeight = 0;
+		else if(state == ForkliftState.LIFT_HEIGHT)
+			oldHeight = liftHeight;
+		else if(state == ForkliftState.SCAN_HEIGHT)
+			oldHeight = scanHeight;
+		else
+			oldHeight = scanHeightLow;
 		
 		if (s == ForkliftState.LIFT_HEIGHT) {
 			height = liftHeight;
@@ -86,7 +96,7 @@ public class Forklift {
 		}
 		
 		state = s;
-		return changeHeight(height);
+		return changeHeight(height, oldHeight);
 	}
 	
 	/**
@@ -94,13 +104,14 @@ public class Forklift {
 	 * Won't return until the height is reached
 	 * @param newHeight
 	 */
-	private static int changeHeight(int newHeight) {
+	private static int changeHeight(int newHeight, int oldHeight) {
 		int rotation = convertDistanceToAngle(newHeight);
-		int naptime = rotation*11;
+		int naptime = Math.abs(newHeight - oldHeight) * 400;
 		
 		try {
-			lift.setSpeed(100);
-			lift.rotateTo(-rotation);
+			lift.setAcceleration(1000);
+			lift.setSpeed(200);
+			lift.rotateTo(-rotation, true);
 		} catch (ArrayIndexOutOfBoundsException e){
 		
 		}

commit 84ffe627c9cf4f1e46c94829356d7bedb76b647f
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Tue Nov 19 19:56:54 2013 -0500

    Added a useful method in colorPoller to allow Recognize.java to work.
    Also added a supporting enum.

diff --git a/src/hardwareAbstraction/ColorPoller.java b/src/hardwareAbstraction/ColorPoller.java
index 7d8fe03..9961f18 100644
--- a/src/hardwareAbstraction/ColorPoller.java
+++ b/src/hardwareAbstraction/ColorPoller.java
@@ -77,6 +77,14 @@ public class ColorPoller implements TimerListener {
 			return false;
 		else
 			return true;
-
+	}
+	
+	public ObjectDetected getObjectReading() {
+		double average = ( readings[4] + readings[3] + readings[2] + readings[1] + readings[0] ) / 5;
+		return average <= 0.9  ? ObjectDetected.OBSTACLE : ObjectDetected.BLUE_BLOCK;
+	}
+	
+	public enum ObjectDetected {
+		OBSTACLE, BLUE_BLOCK
 	}
 }
\ No newline at end of file

commit 41dd7c90103f2cecdcbe9902d5915f48a48aeb56
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Tue Nov 19 19:56:21 2013 -0500

    Changed the Recognize.java to work with the newly mounted colorsensor.
    Removed the ultrasonic logic which was overly complicated for the
    moment.

diff --git a/src/controllers/Recognize.java b/src/controllers/Recognize.java
index 1a6d902..f71e489 100644
--- a/src/controllers/Recognize.java
+++ b/src/controllers/Recognize.java
@@ -2,10 +2,14 @@ package controllers;
 
 import java.util.Stack;
 
+import services.Navigation;
 import utilities.Point;
 import utilities.Position;
+import hardwareAbstraction.Claw;
+import hardwareAbstraction.ColorPoller.ObjectDetected;
 import hardwareAbstraction.Forklift;
 import hardwareAbstraction.Forklift.ForkliftState;
+import hardwareAbstraction.UltrasonicPoller.USPosition;
 import lejos.nxt.comm.RConsole;
 import manager.Manager;
 
@@ -30,95 +34,124 @@ private boolean isInPosition;
 	public void run() {
 		//setup the recognize parameters at the start, only does this once. 
 		if (!isSetup) {
+			//ensure the robot only sets up once and does nothing else until its done setting up.
+			this.isSetup = true;
+			this.isInPosition = false;
 			manager.cm.setState(State.PAUSE);
 			
+			/*
+			 * Get readings necessary from the USP
+			 */
+			USPosition lowestSensor = manager.hm.ultrasonicPoller.getLowestSensor();
+			int lowestValue = manager.hm.ultrasonicPoller.getLowestReading();
+			
+			/*
+			 * Turn the robot to face the lowest sensor reading. The goal is
+			 * after this, the robot will face directly towards the robot.
+			 */
+			//10 centimeters separate the side sensors and the center sensor.
+			final int sensorOffset = 10; 
+			double angle = Math.tan( sensorOffset / lowestValue);
+			if(lowestSensor == USPosition.LEFT)
+				manager.sm.nav.turnToComplete(manager.sm.odo.getTheta() - angle);
+			if(lowestSensor == USPosition.RIGHT)
+				manager.sm.nav.turnToComplete(manager.sm.odo.getTheta() + angle);
+			
+			
 			RConsole.println("Setting up");
-			this.isSetup = true;
-			this.isInPosition = false;
+			
 			
 			//set navigation to do nothing for the moment. 
 			this.prevRoute = manager.sm.nav.getRoute();
 			manager.sm.nav.setRoute(new Stack<Point>());
 			
-			// lower forklift if raised
-			
+			// Sample object
 			Forklift.setHeight(ForkliftState.GROUND);
+			Claw.grabObject();
 			
-			// reset ultrasonic sensor
-			manager.hm.ultrasonicPoller.resetUSP();
-			
-			//now return to previous state.
+			// start the colorSensor to determine what hte block is. 
+			manager.hm.colorPoller.start();
 			manager.cm.setState(State.RECOGNIZE);
-
-			// if not at scan height, set it to that
-			if(Forklift.state == Forklift.ForkliftState.LIFT_HEIGHT) {
-				manager.cm.setState(State.PAUSE);
-				Forklift.setHeight(ForkliftState.GROUND);
-				manager.cm.setState(State.RECOGNIZE);
-			}
-			if (Forklift.state != Forklift.ForkliftState.SCAN_HEIGHT) {
-				manager.cm.setState(State.PAUSE);
-				Forklift.setHeight(ForkliftState.SCAN_HEIGHT);
-				manager.cm.setState(State.RECOGNIZE);
-			}
+			
+//			// reset ultrasonic sensor
+//			manager.hm.ultrasonicPoller.resetUSP();
+//			
+//			//now return to previous state.
+//			manager.cm.setState(State.RECOGNIZE);
+//
+//			// if not at scan height, set it to that
+//			if(Forklift.state == Forklift.ForkliftState.LIFT_HEIGHT) {
+//				manager.cm.setState(State.PAUSE);
+//				Forklift.setHeight(ForkliftState.GROUND);
+//				manager.cm.setState(State.RECOGNIZE);
+//			}
+//			if (Forklift.state != Forklift.ForkliftState.SCAN_HEIGHT) {
+//				manager.cm.setState(State.PAUSE);
+//				Forklift.setHeight(ForkliftState.SCAN_HEIGHT);
+//				manager.cm.setState(State.RECOGNIZE);
+//			}
 			//TODO figure out if we still need the colorPoller or not. 
 			// start the color poller 
-			manager.hm.colorPoller.start();
+			
 		}
 		//if the color poller has finally collected enough values. 
 		if(manager.hm.colorPoller.isSetup()) {
-			// TODO we might not even need this code anymore!!!!!!!
+			ObjectDetected object = manager.hm.colorPoller.getObjectReading();
+			if(object == ObjectDetected.BLUE_BLOCK)
+				manager.cm.setState(State.COLLECT);
+			else
+				manager.cm.setState(State.SEARCH); //TODO change to wall follower. 
 		}
 		
-		if (!this.isInPosition) {
-				RConsole.println("See if the robot needs to correct its navigation");
-				int midReading = manager.hm.ultrasonicPoller
-						.getUSReading(middle);
-
-				// check if the robot must move to 20 cm from the object, but only when the first reading is taken.
-				if (midReading != -1) {
-					// if not 20 cm from the object, then correct the robot to
-					// be 20 from object
-					if (midReading < 19 || midReading > 21) {
-						RConsole.println("The robot is trying to get to the object");
-						Position currentPos = manager.sm.odo.getPosition();
-						manager.sm.nav.addToRoute(currentPos
-								.addDistanceToPosition(20 - midReading)); //TODO debug this method. 
-					}
-					this.isInPosition = true;
-				}
-				
-			}
+//		if (!this.isInPosition) {
+//				RConsole.println("See if the robot needs to correct its navigation");
+//				int midReading = manager.hm.ultrasonicPoller
+//						.getUSReading(middle);
+//
+//				// check if the robot must move to 20 cm from the object, but only when the first reading is taken.
+//				if (midReading != -1) {
+//					// if not 20 cm from the object, then correct the robot to
+//					// be 20 from object
+//					if (midReading < 19 || midReading > 21) {
+//						RConsole.println("The robot is trying to get to the object");
+//						Position currentPos = manager.sm.odo.getPosition();
+//						manager.sm.nav.addToRoute(currentPos
+//								.addDistanceToPosition(20 - midReading)); //TODO debug this method. 
+//					}
+//					this.isInPosition = true;
+//				}
+//				
+//			}
 		
 		//once in position, route is empty. 
-		if(manager.sm.nav.getRoute().empty()) {	
-			//once the us is setup, get the low and high values. 
-			if(manager.hm.ultrasonicPoller.isSetup()) {
-				RConsole.print("Ultrasonic is setup, ");
-				if (lowValue == -1) {
-					// set low value. Reset the USP and raise the forklift. 
-					RConsole.println("Setting lowValue");
-					this.lowValue = manager.hm.ultrasonicPoller.computeAverage(middle);
-					manager.hm.ultrasonicPoller.resetUSP();
-					Forklift.setHeight(ForkliftState.SCAN_HEIGHT);
-				} else {
-					RConsole.println("Setting highValue");
-					this.highValue = manager.hm.ultrasonicPoller.computeAverage(middle);
-					
-					//if an obstacle, the difference of the low and high values will be low. Otherwise it will be huge. 
-					if(this.highValue - this.lowValue > 50) { //if a styrofoam block
-						RConsole.println("Collection executed now.");
-						manager.cm.setState(State.COLLECT);
-					}
-					else {
-						RConsole.println("Wall Follower now");
-						manager.cm.setState(State.WALL_FOLLOWER);
-					}
-					//restore previous state before this execution 
-					manager.sm.nav.setRoute(this.prevRoute);
-					this.isSetup = false;
-				}
-			}
-		}
+//		if(manager.sm.nav.getRoute().empty()) {	
+//			//once the us is setup, get the low and high values. 
+//			if(manager.hm.ultrasonicPoller.isSetup()) {
+//				RConsole.print("Ultrasonic is setup, ");
+//				if (lowValue == -1) {
+//					// set low value. Reset the USP and raise the forklift. 
+//					RConsole.println("Setting lowValue");
+//					this.lowValue = manager.hm.ultrasonicPoller.computeAverage(middle);
+//					manager.hm.ultrasonicPoller.resetUSP();
+//					Forklift.setHeight(ForkliftState.SCAN_HEIGHT);
+//				} else {
+//					RConsole.println("Setting highValue");
+//					this.highValue = manager.hm.ultrasonicPoller.computeAverage(middle);
+//					
+//					//if an obstacle, the difference of the low and high values will be low. Otherwise it will be huge. 
+//					if(this.highValue - this.lowValue > 50) { //if a styrofoam block
+//						RConsole.println("Collection executed now.");
+//						manager.cm.setState(State.COLLECT);
+//					}
+//					else {
+//						RConsole.println("Wall Follower now");
+//						manager.cm.setState(State.WALL_FOLLOWER);
+//					}
+//					//restore previous state before this execution 
+//					manager.sm.nav.setRoute(this.prevRoute);
+//					this.isSetup = false;
+//				}
+//			}
+//		}
 	}
 }

commit f5f119211e64ffc4479c35f35bd69d3b653ffdac
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Tue Nov 19 19:52:50 2013 -0500

    The Launcher is modified to test the scanning function in navigation.

diff --git a/src/launcher/Launcher.java b/src/launcher/Launcher.java
index 362951b..fb2dbf7 100644
--- a/src/launcher/Launcher.java
+++ b/src/launcher/Launcher.java
@@ -27,7 +27,7 @@ public class Launcher {
 	 * @param args
 	 */
 	public static void main(String[] args) {
-//		RConsole.openUSB(20000);
+		RConsole.openUSB(20000);
 		
 		
 		Manager manager = new Manager();

commit 645b97a6d276cd718aa5ce2155f8e35d303a5b15
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Tue Nov 19 19:52:17 2013 -0500

    Worked on fixing the object detection and scan ahead algorithm. Should
    scan ahead. May not work however. Needs to be tested.

diff --git a/src/services/Navigation.java b/src/services/Navigation.java
index 1fc95a9..86f7d13 100644
--- a/src/services/Navigation.java
+++ b/src/services/Navigation.java
@@ -81,35 +81,49 @@ public class Navigation implements TimerListener {
 					// TODO comment back this code. Problematic code for the
 					// moment.
 					if (!scannedAhead) {
+						RConsole.println("Scanning Ahead");
+						scannedAhead = true;
 						manager.hm.drive.stop();
 						this.pause();
-//						UltrasonicMotor.setForwardPosition();
+						UltrasonicMotor.setForwardPosition();
+						/*
+						 * TODO this must be calibrated to the delay experienced
+						 * on the ultrasonic sensor. I want to make sure that 5
+						 * readings have been picked up by the ultrasonic
+						 * sensor. Therefore 5 seconds should be long enough
+						 * (until we can test otherwise).
+						 */
 						try {
-							Thread.sleep(manager.hm.ultrasonicPoller.pollRate * 6);
+							Thread.sleep(5000);
 						} catch (InterruptedException e) {
 						}
-
-						Sound.beep();
-						int lowest = manager.hm.ultrasonicPoller
-								.getLowestReading();
-						Sound.beep();
+						int lowest = manager.hm.ultrasonicPoller.getLowestReading();
 						try {
 							Thread.sleep(1000);
 						} catch (InterruptedException e) {
 							e.printStackTrace();
 						}
-
-//						UltrasonicMotor.setDefaultPosition();
+						UltrasonicMotor.setDefaultPosition();
 						this.start();
-						Sound.twoBeeps();
-						if (lowest < 20) {}
+						if (lowest < 20) {
+							RConsole.println("Read less than 20");
+							Sound.beepSequenceUp();
+							//TODO comment this back in when recognize works. 
 //							manager.cm.setState(State.RECOGNIZE);
-						else if (lowest < 30)
-							route.push(manager.sm.odo.getPosition()
-									.addDistanceToPosition(lowest - 5));
-						scannedAhead = true;
+						}
+						else if (lowest < 30) {
+							RConsole.println("Read less than 30");
+							RConsole.println("Pushing the following to the stack" + manager.sm.odo.getPosition().addDistanceToPosition(lowest - 5));
+							route.push(manager.sm.odo.getPosition().addDistanceToPosition(lowest - 5));
+						} else {
+							// do no processing, just continue along doing nothing. 
+						}
+					} else {
+						travelTo();
+						RConsole.println("Not scanning ahead");
 					}
 				} else {
+					
 					// stop the motors, reset scanning state and get next
 					// destination.
 					manager.hm.drive.stop();

commit bf2777f732923f5b2b055b979a062a0f67106bb8
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Tue Nov 19 19:15:13 2013 -0500

    Created a useful method in ultrasonic poller to determine which
    ultrasonic  poller is the lowest value. Will be used to orient robot
    towards that.

diff --git a/src/hardwareAbstraction/UltrasonicPoller.java b/src/hardwareAbstraction/UltrasonicPoller.java
index e549c05..4a713bf 100644
--- a/src/hardwareAbstraction/UltrasonicPoller.java
+++ b/src/hardwareAbstraction/UltrasonicPoller.java
@@ -224,7 +224,42 @@ public class UltrasonicPoller implements TimerListener {
 		if (takingReadings)
 			start();
 		return minValue;
+	}
+	
+	/**
+	 * This method gets the number representation of the US with the lowest value out of all the ultrasonic sensor. 
+	 * So if the center has the lowest reading, 
+	 */
+	public USPosition getLowestSensor() {
+		boolean takingReadings = false;
+		if (this.poller != null) {
+			stop();
+			takingReadings = true;
+		}
+
+		// calculate median value by sorting the readings
+		int minValue = readings[0][0]; // get a value to start
+		int sensor = 0;
+		int smallestSensor = 0;
+		for (int usReadings[] : readings) {
+			for (int reading : usReadings) {
+				if (minValue > reading) {
+					minValue = reading;
+					smallestSensor = sensor;
+				}
+			}
+			sensor++;
+		}
 
+		// start the readings again if the robot was taking readings before.
+		if (takingReadings)
+			start();
+		if(smallestSensor == left)
+			return USPosition.LEFT;
+		else if(smallestSensor == center)
+			return USPosition.CENTER;
+		else
+			return USPosition.RIGHT;
 	}
 
 	/**
@@ -292,4 +327,8 @@ public class UltrasonicPoller implements TimerListener {
 			pingUS(center);
 		}
 	}
+	
+	public enum USPosition {
+		LEFT, CENTER, RIGHT
+	}
 }

commit f3bec86902bd8479f1caa3375e9f5be65715600e
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Tue Nov 19 18:25:57 2013 -0500

    Few bug fixes for navigation.

diff --git a/src/services/Navigation.java b/src/services/Navigation.java
index 840ddb5..1fc95a9 100644
--- a/src/services/Navigation.java
+++ b/src/services/Navigation.java
@@ -14,8 +14,8 @@ import manager.*;
 
 /**
  * 
- * Navigates the robot along a route, which is contained in this class
- * the route is set by the search and drop off controllers.
+ * Navigates the robot along a route, which is contained in this class the route
+ * is set by the search and drop off controllers.
  * 
  * Further work required with scanAhead()
  * 
@@ -57,7 +57,7 @@ public class Navigation implements TimerListener {
 				|| manager.cm.getState() == State.DROP_OFF
 				|| manager.cm.getState() == State.RECOGNIZE
 				|| manager.cm.getState() == State.TESTING) {
-
+			
 			if (route.empty()) {
 				// nothing is done
 			} else {
@@ -83,50 +83,55 @@ public class Navigation implements TimerListener {
 					if (!scannedAhead) {
 						manager.hm.drive.stop();
 						this.pause();
-						UltrasonicMotor.setForwardPosition();
+//						UltrasonicMotor.setForwardPosition();
 						try {
 							Thread.sleep(manager.hm.ultrasonicPoller.pollRate * 6);
 						} catch (InterruptedException e) {
 						}
-						UltrasonicMotor.setDefaultPosition();
+
 						Sound.beep();
-						try {
-							Thread.sleep(100);
-						} catch (InterruptedException e) {
-						}
 						int lowest = manager.hm.ultrasonicPoller
 								.getLowestReading();
 						Sound.beep();
-						if (lowest < 20)
-							manager.cm.setState(State.RECOGNIZE);
-						else if (lowest < 30)
-							route.push(manager.sm.odo.getPosition().addDistanceToPosition(lowest - 5));
-						Sound.beep();
+						try {
+							Thread.sleep(1000);
+						} catch (InterruptedException e) {
+							e.printStackTrace();
+						}
+
+//						UltrasonicMotor.setDefaultPosition();
 						this.start();
-						Sound.beep();
+						Sound.twoBeeps();
+						if (lowest < 20) {}
+//							manager.cm.setState(State.RECOGNIZE);
+						else if (lowest < 30)
+							route.push(manager.sm.odo.getPosition()
+									.addDistanceToPosition(lowest - 5));
 						scannedAhead = true;
-						travelTo();
-					} else {
-						// stop the motors, reset scanning state and get next
-						// destination.
-						manager.hm.drive.stop();
-						scannedAhead = false;
-						route.pop();
 					}
+				} else {
+					// stop the motors, reset scanning state and get next
+					// destination.
+					manager.hm.drive.stop();
+					scannedAhead = false;
+					route.pop();
 				}
+
 			}
 		}
 	}
-	
+
 	public void pause() {
 		this.time.stop();
+		this.time = null;
 	}
-	
+
 	public void start() {
 		RConsole.println("Navigation started");
+		this.time = new Timer(UPDATE_PERIOD, this);
 		this.time.start();
 	}
-	
+
 	private void setupDeltaPositonAndHeading() {
 		currentPos = manager.sm.odo.getPosition();
 
@@ -136,11 +141,12 @@ public class Navigation implements TimerListener {
 
 		// the required theta to travel to our destination
 		double theta = Math.atan2(dY, dX);
-		
+
 		// adjust to [0, 2PI]
 		theta = Angle.principleAngle(theta);
-		
-		// set dH to the difference of theta and currentTheta adjust to [-PI, PI]
+
+		// set dH to the difference of theta and currentTheta adjust to [-PI,
+		// PI]
 		dH = Angle.minimumAngle(currentPos.theta, theta);
 	}
 
@@ -152,7 +158,7 @@ public class Navigation implements TimerListener {
 
 		// Distance to destination
 		double distanceToTravel = (dX * Math.cos(currentPos.theta))
-								+ (dY * Math.sin(currentPos.theta));
+				+ (dY * Math.sin(currentPos.theta));
 		// high speed
 		if (distanceToTravel > 3) {
 			manager.hm.drive.setSpeeds(MAX_FORWARD_SPEED, dL);
@@ -174,65 +180,71 @@ public class Navigation implements TimerListener {
 			manager.hm.drive.stop();
 		}
 	}
-	
-	
+
 	public void turnToComplete(double angle) {
-		
+
 		angle = Angle.principleAngle(angle);
-		// set dH to the difference of theta and currentTheta adjust to [-PI, PI]
+		// set dH to the difference of theta and currentTheta adjust to [-PI,
+		// PI]
 		double dH = Angle.minimumAngle(currentPos.theta, angle);
-		
-		while(Math.abs(dH) > 0.01) {
+
+		while (Math.abs(dH) > 0.01) {
 			dH = Angle.minimumAngle(currentPos.theta, angle);
 			turnTo(dH);
 			manager.um.nap(70);
 		}
-		
+
 		manager.hm.drive.stop();
-		
+
 	}
-	
+
 	public int calculateRotationSpeed(double dH) {
 		if (Math.abs(dH) > 0.01) {
 			// if error positive and greater than 0.2 rad -> max speed CCW
 			if (dH > 0.3) {
 				return -MAX_ROTATE_SPEED;
 			}
-			// positive error, between .05 and .15 , so turn slow CCW to prevent overshoot
+			// positive error, between .05 and .15 , so turn slow CCW to prevent
+			// overshoot
 			else if (dH > .15) {
 				return -MAX_ROTATE_SPEED / 2;
 			}
-			// positive error, between .05 and .15 , so turn slow CCW to prevent overshoot
+			// positive error, between .05 and .15 , so turn slow CCW to prevent
+			// overshoot
 			else if (dH > .05) {
 				return -MAX_ROTATE_SPEED / 6;
 			}
-			// positive error, but close to 0, so turn slow CCW to prevent overshoot
+			// positive error, but close to 0, so turn slow CCW to prevent
+			// overshoot
 			else if (dH > 0.01) {
 				return -MAX_ROTATE_SPEED / 16;
 			}
-			
+
 			// if error negative and greater than 0.2 rad -> max speed CW
 			if (dH < -0.3) {
 				return MAX_ROTATE_SPEED;
 			}
-			// negative error, between .05 and .15 , so turn slow CW to prevent overshoot
+			// negative error, between .05 and .15 , so turn slow CW to prevent
+			// overshoot
 			else if (dH < -.15) {
 				return MAX_ROTATE_SPEED / 2;
 			}
-			// negative error, between .05 and .15 , so turn slow CW to prevent overshoot
+			// negative error, between .05 and .15 , so turn slow CW to prevent
+			// overshoot
 			else if (dH < -.05) {
 				return MAX_ROTATE_SPEED / 6;
 			}
-			// negative error, but close to 0, so turn slow CW to prevent overshoot
+			// negative error, but close to 0, so turn slow CW to prevent
+			// overshoot
 			else if (dH < -0.01) {
 				return MAX_ROTATE_SPEED / 16;
 			}
 		}
-		//if this point is reached, dH is basically zero (<0.6deg)
+		// if this point is reached, dH is basically zero (<0.6deg)
 		return 0;
 	}
 
-	//accessors and mutators
+	// accessors and mutators
 	public Stack<Point> getRoute() {
 		return route;
 	}
@@ -240,10 +252,11 @@ public class Navigation implements TimerListener {
 	public void setRoute(Stack<Point> route) {
 		this.route = route;
 	}
-	
-	
+
 	/**
-	 * This method will export the route currently programmed and resets it to an empty route. 
+	 * This method will export the route currently programmed and resets it to
+	 * an empty route.
+	 * 
 	 * @return
 	 */
 	public Stack<Point> exportAndResetRoute() {
@@ -251,7 +264,7 @@ public class Navigation implements TimerListener {
 		this.route = new Stack<Point>();
 		return export;
 	}
-	
+
 	public void addToRoute(Point xy) {
 		this.scannedAhead = false;
 		this.route.push(xy);

commit 29197f9ea4d2a27043f069b9f042dc92ad8204ee
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Tue Nov 19 15:35:41 2013 -0500

    Fixed an issue with the external motors timing out. The robot now grabs
    an object and lifts it. However, no intelligence has been provided to
    find when it must lift.

diff --git a/src/hardwareAbstraction/UltrasonicMotor.java b/src/hardwareAbstraction/UltrasonicMotor.java
index 3560fc6..d1cf82a 100644
--- a/src/hardwareAbstraction/UltrasonicMotor.java
+++ b/src/hardwareAbstraction/UltrasonicMotor.java
@@ -12,8 +12,11 @@ public class UltrasonicMotor {
 	 */
 	public static void setDefaultPosition() {
 		isForward = false;
-		Settings.ultrasonicMotor.setSpeed(200);
-		Settings.ultrasonicMotor.rotate(45);
+		try {
+			Settings.ultrasonicMotor.setSpeed(200);
+			Settings.ultrasonicMotor.rotate(45);
+		} catch (ArrayIndexOutOfBoundsException e) {
+		}
 	}
 	
 	/**
@@ -23,8 +26,11 @@ public class UltrasonicMotor {
 	 */
 	public static void setForwardPosition() {
 		isForward = true;
-		Settings.ultrasonicMotor.setSpeed(200);
-		Settings.ultrasonicMotor.rotate(-45);
+		try {
+			Settings.ultrasonicMotor.setSpeed(200);
+			Settings.ultrasonicMotor.rotate(-45);
+		} catch (ArrayIndexOutOfBoundsException e) {
+		}
 	}
 
 }
diff --git a/src/launcher/Launcher.java b/src/launcher/Launcher.java
index a5fb529..362951b 100644
--- a/src/launcher/Launcher.java
+++ b/src/launcher/Launcher.java
@@ -27,7 +27,7 @@ public class Launcher {
 	 * @param args
 	 */
 	public static void main(String[] args) {
-		RConsole.openBluetooth(20000);
+//		RConsole.openUSB(20000);
 		
 		
 		Manager manager = new Manager();
@@ -38,16 +38,16 @@ public class Launcher {
 			manager.um.nap(150);
 		}*/
 		
-		manager.sm.odoCorrection.start();
-		manager.hm.ultrasonicPoller.stop();
+//		manager.sm.odoCorrection.start();
+		manager.hm.ultrasonicPoller.start();
 		
-		manager.cm.setState(State.TESTING);
+		manager.cm.setState(State.SEARCH);
 		
 		manager.sm.nav.addToRoute(new Point(15,15));
-		manager.sm.nav.addToRoute(new Point(45,15));
-		manager.sm.nav.addToRoute(new Point(45,165));
-		manager.sm.nav.addToRoute(new Point(15,165));
-		manager.sm.nav.addToRoute(new Point(15,15));
+//		manager.sm.nav.addToRoute(new Point(45,15));
+//		manager.sm.nav.addToRoute(new Point(45,165));
+//		manager.sm.nav.addToRoute(new Point(15,165));
+//		manager.sm.nav.addToRoute(new Point(15,15));
 		
 		
 		//manager.sm.nav.addToRoute(new Point(60,0));
diff --git a/src/services/Navigation.java b/src/services/Navigation.java
index a190409..840ddb5 100644
--- a/src/services/Navigation.java
+++ b/src/services/Navigation.java
@@ -1,9 +1,12 @@
 package services;
 
+import hardwareAbstraction.UltrasonicMotor;
+
 import java.util.Stack;
 
 import utilities.*;
 import controllers.State;
+import lejos.nxt.Sound;
 import lejos.nxt.comm.RConsole;
 import lejos.util.Timer;
 import lejos.util.TimerListener;
@@ -50,17 +53,20 @@ public class Navigation implements TimerListener {
 
 	@Override
 	public void timedOut() {
-		if (manager.cm.getState() == State.SEARCH || manager.cm.getState() == State.DROP_OFF || manager.cm.getState() == State.RECOGNIZE || manager.cm.getState() == State.TESTING) {
-			
+		if (manager.cm.getState() == State.SEARCH
+				|| manager.cm.getState() == State.DROP_OFF
+				|| manager.cm.getState() == State.RECOGNIZE
+				|| manager.cm.getState() == State.TESTING) {
+
 			if (route.empty()) {
 				// nothing is done
 			} else {
 				nextDestination = route.peek();
 				// if navigation must be done
-			
+
 				// update the new headings to travel to
 				setupDeltaPositonAndHeading();
-				
+
 				// see if we need to make a big turn
 				if (Math.abs(dH) > 0.1) {
 					// if we need to turn more than 0.2 rads or 0.1 for
@@ -69,32 +75,44 @@ public class Navigation implements TimerListener {
 					// one wheel down slightly
 					turnTo(dH);
 				} else if (Math.abs(dX) > 1 || Math.abs(dY) > 1) {
-					//RConsole.println(""+Math.abs(dX)+" "+Math.abs(dY));
-					//scan ahead only once facing the correct orientation, then travelTo that destination.
-					//TODO comment back this code. Problematic code for the moment. 
-//				if (!scannedAhead) {
-//					manager.hm.drive.stop();
-//					this.pause();
-//					UltrasonicMotor.setForwardPosition();
-//					try {
-//						Thread.sleep(manager.hm.ultrasonicPoller.pollRate * 6);
-//					} catch (InterruptedException e) {
-//						e.printStackTrace();
-//					}
-//					int lowest = manager.hm.ultrasonicPoller.getLowestReading();
-//					if(lowest < 20)
-//						manager.cm.setState(State.RECOGNIZE);
-//					else if (lowest < 30)
-//						route.push(manager.sm.odo.getPosition().addDistanceToPosition(lowest - threshold));
-//					else
-//						manager.cm.setState(State.SEARCH);
-//					this.start();
-					travelTo();
-				} else {
-					//stop the motors, reset scanning state and get next destination. 
-					manager.hm.drive.stop();
-					scannedAhead = false;
-					route.pop();
+					// RConsole.println(""+Math.abs(dX)+" "+Math.abs(dY));
+					// scan ahead only once facing the correct orientation, then
+					// travelTo that destination.
+					// TODO comment back this code. Problematic code for the
+					// moment.
+					if (!scannedAhead) {
+						manager.hm.drive.stop();
+						this.pause();
+						UltrasonicMotor.setForwardPosition();
+						try {
+							Thread.sleep(manager.hm.ultrasonicPoller.pollRate * 6);
+						} catch (InterruptedException e) {
+						}
+						UltrasonicMotor.setDefaultPosition();
+						Sound.beep();
+						try {
+							Thread.sleep(100);
+						} catch (InterruptedException e) {
+						}
+						int lowest = manager.hm.ultrasonicPoller
+								.getLowestReading();
+						Sound.beep();
+						if (lowest < 20)
+							manager.cm.setState(State.RECOGNIZE);
+						else if (lowest < 30)
+							route.push(manager.sm.odo.getPosition().addDistanceToPosition(lowest - 5));
+						Sound.beep();
+						this.start();
+						Sound.beep();
+						scannedAhead = true;
+						travelTo();
+					} else {
+						// stop the motors, reset scanning state and get next
+						// destination.
+						manager.hm.drive.stop();
+						scannedAhead = false;
+						route.pop();
+					}
 				}
 			}
 		}

commit 1e699c0f83591abbce87aee184d949a66aa33402
Author: RileyvanRyswyk <rileyvan@gmail.com>
Date:   Tue Nov 19 12:07:15 2013 -0500

    Odo Correction Test

diff --git a/src/launcher/Launcher.java b/src/launcher/Launcher.java
index 8872ce7..a5fb529 100644
--- a/src/launcher/Launcher.java
+++ b/src/launcher/Launcher.java
@@ -27,19 +27,31 @@ public class Launcher {
 	 * @param args
 	 */
 	public static void main(String[] args) {
-		//RConsole.openUSB(20000);
+		RConsole.openBluetooth(20000);
 		
 		
 		Manager manager = new Manager();
 		Button.waitForPress();
-		manager.sm.localization.start();
+		/*manager.sm.localization.start();
 		
 		while(manager.cm.getState() == State.LOCALIZING) {
 			manager.um.nap(150);
-		}
+		}*/
+		
+		manager.sm.odoCorrection.start();
+		manager.hm.ultrasonicPoller.stop();
+		
+		manager.cm.setState(State.TESTING);
+		
+		manager.sm.nav.addToRoute(new Point(15,15));
+		manager.sm.nav.addToRoute(new Point(45,15));
+		manager.sm.nav.addToRoute(new Point(45,165));
+		manager.sm.nav.addToRoute(new Point(15,165));
+		manager.sm.nav.addToRoute(new Point(15,15));
+		
 		
 		//manager.sm.nav.addToRoute(new Point(60,0));
-		manager.sm.nav.turnToComplete(0);
+		
 		//manager.cm.setState(State.SEARCH);
 		
 //		manager.sm.nav.start();

commit ee59ffecf9ce7b473e330decb705ada07166d903
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Mon Nov 18 13:26:14 2013 -0500

    Made small change to Navigation, hopefully to implement scanAhead
    properly.

diff --git a/src/services/Navigation.java b/src/services/Navigation.java
index 8f3bbfa..a190409 100644
--- a/src/services/Navigation.java
+++ b/src/services/Navigation.java
@@ -72,12 +72,23 @@ public class Navigation implements TimerListener {
 					//RConsole.println(""+Math.abs(dX)+" "+Math.abs(dY));
 					//scan ahead only once facing the correct orientation, then travelTo that destination.
 					//TODO comment back this code. Problematic code for the moment. 
-//					if (!scannedAhead) {
-//						manager.hm.drive.stop();
-//						this.pause();
-//						manager.cm.setState(State.RECOGNIZE);
-//						this.start();
+//				if (!scannedAhead) {
+//					manager.hm.drive.stop();
+//					this.pause();
+//					UltrasonicMotor.setForwardPosition();
+//					try {
+//						Thread.sleep(manager.hm.ultrasonicPoller.pollRate * 6);
+//					} catch (InterruptedException e) {
+//						e.printStackTrace();
 //					}
+//					int lowest = manager.hm.ultrasonicPoller.getLowestReading();
+//					if(lowest < 20)
+//						manager.cm.setState(State.RECOGNIZE);
+//					else if (lowest < 30)
+//						route.push(manager.sm.odo.getPosition().addDistanceToPosition(lowest - threshold));
+//					else
+//						manager.cm.setState(State.SEARCH);
+//					this.start();
 					travelTo();
 				} else {
 					//stop the motors, reset scanning state and get next destination. 

commit 4e13809cb1812ca4cbb891d5b6342411102bb563
Author: RileyvanRyswyk <rileyvan@gmail.com>
Date:   Mon Nov 18 10:09:42 2013 -0500

    Odometry Correction Update
    
    Should fix the problem of not correcting after missing a line.

diff --git a/src/services/OdometryCorrection.java b/src/services/OdometryCorrection.java
index fdb4ad8..98b8a4c 100644
--- a/src/services/OdometryCorrection.java
+++ b/src/services/OdometryCorrection.java
@@ -57,8 +57,8 @@ public class OdometryCorrection implements TimerListener  {
 				lastPos = manager.sm.odo.getPosition();
 			} else {
 				lineDetected(manager.sm.odo.getPosition(), lastPos, right);
-				lastPos = null;
-				lastSensor = -1;
+				lastPos = manager.sm.odo.getPosition();
+				lastSensor = left;
 			}
 		}
 		
@@ -71,8 +71,8 @@ public class OdometryCorrection implements TimerListener  {
 				lastPos = manager.sm.odo.getPosition();
 			} else {
 				lineDetected(lastPos, manager.sm.odo.getPosition(), left);
-				lastPos = null;
-				lastSensor = -1;
+				lastPos = manager.sm.odo.getPosition();
+				lastSensor = right;
 			}
 		}
 		

commit facbcfce8a7921ceb53f0d77b9e936b6167aa9a7
Author: RileyvanRyswyk <rileyvan@gmail.com>
Date:   Sun Nov 17 17:05:30 2013 -0500

    Odometry Correction
    
    Ultrasonic Poller Stop fix.
    Removed beeping from line poller

diff --git a/src/hardwareAbstraction/LinePoller.java b/src/hardwareAbstraction/LinePoller.java
index 8967535..eafa347 100644
--- a/src/hardwareAbstraction/LinePoller.java
+++ b/src/hardwareAbstraction/LinePoller.java
@@ -86,7 +86,7 @@ public class LinePoller implements TimerListener {
 			sensorOnLine[sensor] = true;
 			sensorEnteringLine[sensor] = true;
 			//alert us with a beep that a line was detected
-			Sound.beep();
+			
 		}
 		//if we are on a line and filter result > 45 we have now left the line
 		else if(sensorOnLine[sensor] && result > THRESHOLD) {
diff --git a/src/hardwareAbstraction/UltrasonicPoller.java b/src/hardwareAbstraction/UltrasonicPoller.java
index 46befe2..e549c05 100644
--- a/src/hardwareAbstraction/UltrasonicPoller.java
+++ b/src/hardwareAbstraction/UltrasonicPoller.java
@@ -152,6 +152,7 @@ public class UltrasonicPoller implements TimerListener {
 	 * start reading again.
 	 */
 	public void stop() {
+		this.poller.stop();
 		this.poller = null;
 		running = false;
 	}
diff --git a/src/services/Navigation.java b/src/services/Navigation.java
index 0c49bc3..8f3bbfa 100644
--- a/src/services/Navigation.java
+++ b/src/services/Navigation.java
@@ -51,7 +51,7 @@ public class Navigation implements TimerListener {
 	@Override
 	public void timedOut() {
 		if (manager.cm.getState() == State.SEARCH || manager.cm.getState() == State.DROP_OFF || manager.cm.getState() == State.RECOGNIZE || manager.cm.getState() == State.TESTING) {
-			RConsole.println(""+manager.cm.getState().name());
+			
 			if (route.empty()) {
 				// nothing is done
 			} else {
@@ -60,6 +60,7 @@ public class Navigation implements TimerListener {
 			
 				// update the new headings to travel to
 				setupDeltaPositonAndHeading();
+				
 				// see if we need to make a big turn
 				if (Math.abs(dH) > 0.1) {
 					// if we need to turn more than 0.2 rads or 0.1 for
@@ -68,7 +69,7 @@ public class Navigation implements TimerListener {
 					// one wheel down slightly
 					turnTo(dH);
 				} else if (Math.abs(dX) > 1 || Math.abs(dY) > 1) {
-					RConsole.println(""+Math.abs(dX)+" "+Math.abs(dY));
+					//RConsole.println(""+Math.abs(dX)+" "+Math.abs(dY));
 					//scan ahead only once facing the correct orientation, then travelTo that destination.
 					//TODO comment back this code. Problematic code for the moment. 
 //					if (!scannedAhead) {
@@ -124,7 +125,7 @@ public class Navigation implements TimerListener {
 		double distanceToTravel = (dX * Math.cos(currentPos.theta))
 								+ (dY * Math.sin(currentPos.theta));
 		// high speed
-		if (distanceToTravel > 1) {
+		if (distanceToTravel > 3) {
 			manager.hm.drive.setSpeeds(MAX_FORWARD_SPEED, dL);
 		}
 		// close to target so go really slow, so that we don't overshoot
diff --git a/src/services/OdometryCorrection.java b/src/services/OdometryCorrection.java
index 96bf8b7..fdb4ad8 100644
--- a/src/services/OdometryCorrection.java
+++ b/src/services/OdometryCorrection.java
@@ -1,10 +1,218 @@
 package services;
 
+import utilities.Point;
+import utilities.Position;
+import utilities.Settings;
+import lejos.nxt.Sound;
+import lejos.nxt.comm.RConsole;
+import lejos.util.Timer;
+import lejos.util.TimerListener;
 import manager.*;
 
-public class OdometryCorrection {
+public class OdometryCorrection implements TimerListener  {
+	
+	public final int UPDATE_PERIOD = 15;
+	public final int MAX_CHANGE_DISTANCE = 8;
+	public final int MAX_CHANGE_ANGLE = 30;
+	
+	public Timer timer;
+	public Manager manager;
+	
+	private int left = 0;
+	private int right = 1;
+	
+	private Position lastPos;
+	private int lastSensor;
+	
+	//Sets (0,0) to center of the of the first grid intersection
+	private double xOffset = 0, yOffset = 0;
 	
 	public OdometryCorrection(Manager manager) {
+		this.timer = new Timer(UPDATE_PERIOD, this);
+		this.lastPos = null;
+		lastSensor = -1;
+		this.manager = manager;
+	}
+	
+	public void start() {
+		timer.start();
+	}
+	
+	public void stop() {
+		timer.stop();
+	}
+	
+	
+	/**
+	 * Based on the which sensor is entered a line and the state of the last detected one, 
+	 * the method will call the relevant lineDetected or setup lastPos
+	 */
+	public void timedOut() {
+		if(manager.hm.linePoller.enteringLine(left)) {
+			if(this.lastPos == null) {
+				this.lastPos = manager.sm.odo.getPosition();
+				lastSensor = left;
+			} else if(lastSensor == left) {
+				lineDetected(lastPos, left);
+				lastPos = manager.sm.odo.getPosition();
+			} else {
+				lineDetected(manager.sm.odo.getPosition(), lastPos, right);
+				lastPos = null;
+				lastSensor = -1;
+			}
+		}
+		
+		if(manager.hm.linePoller.enteringLine(right)) {
+			if(this.lastPos == null) {
+				this.lastPos = manager.sm.odo.getPosition();
+				lastSensor = right;
+			} else if(lastSensor == right) {
+				lineDetected(lastPos, right);
+				lastPos = manager.sm.odo.getPosition();
+			} else {
+				lineDetected(lastPos, manager.sm.odo.getPosition(), left);
+				lastPos = null;
+				lastSensor = -1;
+			}
+		}
+		
+		
+	}
+	
+	/**
+	 * When only one sensor detected a line
+	 * @param pos
+	 * @param sensor
+	 */
+	public void lineDetected(Position pos, int sensor) {
+		
+	}
+	
+	
+	/**
+	 * Two sensors detected a line
+	 * @param leftPos
+	 * @param rightPos
+	 */
+	public void lineDetected(Position leftPos, Position rightPos, int firstSensor) {
+		Sound.beep();
+		/*
+		 * Ensures that the point are reasonably close to each other
+		 */
+		if(leftPos.distanceToPoint(rightPos) > 5 && Math.abs(leftPos.theta-rightPos.theta) > 0.1 ) {
+			return;
+		}
+		
+		double x = (leftPos.x + rightPos.x) / 2.0;
+		double y = (leftPos.y + rightPos.y) / 2.0;
+		double theta = (leftPos.theta + rightPos.theta) / 2.0;
+		
+		double dx = 0;
+		double dy = 0;
+		
+		
+		/*
+		 * Update the Y position as we are going in the Y direction
+		 */
+		if(Math.abs(Math.sin(theta)) > 0.98) {
+			
+			/*
+			 * Check if we are on an x line
+			 */
+			double line = getClosestX(x, theta);
+			
+			//make sure the sensor is not close to a line parallel to direction of travel
+			if(Math.abs(x-line) > Settings.LS_WIDTH / 2 + 3) {
+				
+				/*
+				 * getClosestY returns the closest line plus the offset for the light Sensor	
+				 */
+				line = getClosestY(y, theta);
+				
+				//if we are within 10cm of the line, update our position
+				if(Math.abs(line - y) < MAX_CHANGE_DISTANCE) {
+					RConsole.println("dY: " + String.valueOf(line-y));
+					dy = line - y;
+					
+				}
+			}
+			
+		}
+		/*
+		 * Update the X position, going in X direction
+		 */
+		else if(Math.abs(Math.cos(theta)) > 0.98) {
+		
+			/*
+			 * Check if we are on an x line
+			 */
+			double line = getClosestY(y, theta);
+			
+			// make sure the sensor is not close to a line parallel with direction of travel
+			if(Math.abs(y-line) > Settings.LS_WIDTH / 2 + 3) {
+			
+				/*
+				 * We have already detected a x line, so get the closest line
+				 */
+				line = getClosestX(x, theta);
+				
+				//if we are within 10cm of the line, update our position
+				if(Math.abs(line - x) < MAX_CHANGE_DISTANCE) {
+					RConsole.println("dX: " + String.valueOf(line-x));
+					dx = line - x;
+					
+				}
+			}
+			
+		}
+		
+		
+		/* 
+		 * Angle Correction
+		 */
+		
+		double dTheta = Math.atan(leftPos.distanceToPoint(rightPos) / Settings.LS_WIDTH);
+		if(firstSensor == left) {
+			dTheta *= -1;
+		}
+		
+		//makes sure that its only a good angle correction
+		if(Math.abs(dTheta) < MAX_CHANGE_ANGLE && (Math.abs(dx) > 0.01 || Math.abs(dy) > 0.01)) {
+			RConsole.println("dTheta: " + String.valueOf(dTheta));
+			manager.sm.odo.adjustPosition(dx, dy, dTheta);
+		}
+		
+		RConsole.println("Odo: " + manager.sm.odo.getPosition().toString());
+		RConsole.println("right: " + rightPos.toString());
+		RConsole.println("left: " + leftPos.toString() + "\n");
 		
 	}
+	
+
+			
+		
+	/**
+	 * Returns the closest y line plus the offset for the light sensor
+	 * @param y
+	 * @param theta
+	 * @return
+	 */
+	public double getClosestY(double y, double theta) {
+		//adjust light sensor offset for direction of robot
+		double R = Math.sin(theta)*Settings.LS_LENGTH;
+		return (Math.round((y-R-yOffset)/Settings.TILE_SIZE)*Settings.TILE_SIZE + yOffset + R);
+	}
+	
+	/**
+	 * Returns the closest x line plus the offset for the light sensor
+	 * @param x
+	 * @param theta
+	 * @return
+	 */
+	public double getClosestX(double x, double theta) {
+		//adjust light sensor offset for direction of robot
+		double R = Math.cos(theta)*Settings.LS_LENGTH;
+		return (Math.round((x-R-xOffset)/Settings.TILE_SIZE)*Settings.TILE_SIZE + xOffset + R);
+	}
+	
 }
diff --git a/src/utilities/Point.java b/src/utilities/Point.java
index 72e25bf..1c2717d 100644
--- a/src/utilities/Point.java
+++ b/src/utilities/Point.java
@@ -23,6 +23,10 @@ public class Point  {
 		return "{x:" + x + ", y:" + y + "}";
 	}
 	
+	public double distanceToPoint(Point point) {
+		return Math.sqrt(Math.pow(x - point.x, 2) + Math.pow(y - point.y, 2));
+	}
+	
 	//return a point object identical to the current point. Not passed by reference. 
 	public Point getPoint() {
 		return new Point(this.x, this.y);
diff --git a/src/utilities/Settings.java b/src/utilities/Settings.java
index f6d1bb3..228efe2 100644
--- a/src/utilities/Settings.java
+++ b/src/utilities/Settings.java
@@ -34,6 +34,9 @@ public class Settings {
 	public static StartingCorner startingCorner = StartingCorner.BOTTOM_LEFT;
 	
 	public static final double LS_OFFSET = 15.0;
+	public static final double LS_WIDTH = 11.5;
+	public static final double LS_LENGTH = 13.5;
+	public static final double TILE_SIZE = 30.48;
 	public static final int maxBlockCapacity = 1;
 	
 }

commit 281e6b4abcacadfb12dcd4ef21d35e7f041db721
Author: RileyvanRyswyk <rileyvan@gmail.com>
Date:   Sun Nov 17 13:52:10 2013 -0500

    Line Localization now Works
    
    Ultrasonic Poller fixed for localization
    Adjusted Navigation speed

diff --git a/src/controllers/State.java b/src/controllers/State.java
index 1f0468c..d5688b7 100644
--- a/src/controllers/State.java
+++ b/src/controllers/State.java
@@ -6,5 +6,5 @@ package controllers;
  *
  */
 public enum State {
-	SEARCH, RECOGNIZE, COLLECT, DROP_OFF, WALL_FOLLOWER, LOCALIZING, PAUSE, TEMP
+	SEARCH, RECOGNIZE, COLLECT, DROP_OFF, WALL_FOLLOWER, LOCALIZING, PAUSE, TEMP, TESTING
 }
diff --git a/src/hardwareAbstraction/LinePoller.java b/src/hardwareAbstraction/LinePoller.java
index 156a0f1..8967535 100644
--- a/src/hardwareAbstraction/LinePoller.java
+++ b/src/hardwareAbstraction/LinePoller.java
@@ -17,7 +17,7 @@ import utilities.Settings;
 public class LinePoller implements TimerListener {
 
 	private final int UPDATE_PERIOD = 15;
-	private final int THRESHOLD = 40;
+	private final int THRESHOLD = 50;
 	private boolean[] sensorOnLine;
 	private boolean[] sensorEnteringLine;
 	private ColorSensor[] sensor = new ColorSensor[2];
@@ -35,6 +35,8 @@ public class LinePoller implements TimerListener {
 		timer = new Timer(UPDATE_PERIOD, this);
 		setFloodlight(left, 0);
 		setFloodlight(right, 0);
+		
+		start();
 	}
 	
 	/**
@@ -60,9 +62,6 @@ public class LinePoller implements TimerListener {
 		
 		detectLine(right);
 		detectLine(left);
-		
-		RConsole.println("Left " + String.valueOf(readings[left][0]));
-		RConsole.println("Right " + String.valueOf(readings[right][0]));
 	}
 	
 	private void addReading(int sensor, int reading) {
@@ -115,7 +114,6 @@ public class LinePoller implements TimerListener {
 	public void setFloodlight(int sensor, int color) {
 		this.sensor[sensor].setFloodlight(color);
 		do {
-			RConsole.println("Setting Flood light");
 			nap(75);
 		} while(this.sensor[sensor].getRawLightValue() == -1);
 	}
diff --git a/src/hardwareAbstraction/UltrasonicPoller.java b/src/hardwareAbstraction/UltrasonicPoller.java
index c068cb1..46befe2 100644
--- a/src/hardwareAbstraction/UltrasonicPoller.java
+++ b/src/hardwareAbstraction/UltrasonicPoller.java
@@ -1,11 +1,13 @@
 package hardwareAbstraction;
 
+import controllers.State;
 import utilities.Settings;
 import lejos.nxt.LCD;
 import lejos.nxt.UltrasonicSensor;
 import lejos.nxt.comm.RConsole;
 import lejos.util.Timer;
 import lejos.util.TimerListener;
+import manager.Manager;
 
 /**
  * This class serves as a higher level abstraction of a ultrasonic sensor. It is
@@ -30,9 +32,11 @@ public class UltrasonicPoller implements TimerListener {
 	private Thread leftUS;
 	private Thread centerUS;
 	private Thread rightUS;
+	
+	private Manager manager;
 
 	// TODO figure out what exactly this constructor should be.
-	public UltrasonicPoller() {
+	public UltrasonicPoller(Manager manager) {
 		us[left] = Settings.leftUltrasonic;
 		us[center] = Settings.centerUltrasonic;
 		us[right] = Settings.rightUltrasonic;
@@ -48,6 +52,8 @@ public class UltrasonicPoller implements TimerListener {
 		this.centerUS = new Thread(new CenterUS());
 		this.rightUS = new Thread(new RightUS());
 
+		this.manager = manager;
+		
 		this.start();
 	}
 
@@ -57,27 +63,36 @@ public class UltrasonicPoller implements TimerListener {
 	 */
 	@Override
 	public void timedOut() {
+		
 		/*
-		 * If the ultrasonics are facing forward, poll only one at a time.
-		 * Else poll them all simultaneously. 
+		 * Ensures minimal lag for ultrasonic localization 
 		 */
-		if(UltrasonicMotor.isForward) {
-			switch(counter) {
-			case 0 : leftUS.run();
-			break;
-			case 1 : centerUS.run();
-			break;
-			case 2 : rightUS.run();
-			break;
+		if(manager.cm.getState() != State.LOCALIZING) {
+		
+			/*
+			 * If the ultrasonics are facing forward, poll only one at a time.
+			 * Else poll them all simultaneously. 
+			 */
+			if(UltrasonicMotor.isForward) {
+				switch(counter) {
+				case 0 : leftUS.run();
+				break;
+				case 1 : centerUS.run();
+				break;
+				case 2 : rightUS.run();
+				break;
+				}
+				counter += 1;
+				counter = counter % 3;
 			}
-			counter += 1;
-			counter = counter % 3;
-		}
-		else {
-			leftUS.run();
+			else {
+				leftUS.run();
+				centerUS.run();
+				rightUS.run();
+				RConsole.println(toStringLastValues());
+			}
+		} else {
 			centerUS.run();
-			rightUS.run();
-			RConsole.println(toStringLastValues());
 		}
 	}
 
diff --git a/src/manager/ControllerManager.java b/src/manager/ControllerManager.java
index 78e141b..6f02cf1 100644
--- a/src/manager/ControllerManager.java
+++ b/src/manager/ControllerManager.java
@@ -39,7 +39,7 @@ public class ControllerManager implements TimerListener {
 	}
 	
 	public void timedOut() {
-		RConsole.println("" + getState().name());
+		
 		if(state == State.SEARCH) controllers[0].run();
 		else if(state == State.RECOGNIZE) controllers[1].run();
 		else if(state == State.COLLECT) controllers[2].run();
diff --git a/src/manager/HardwareManager.java b/src/manager/HardwareManager.java
index 2759aa8..731497c 100644
--- a/src/manager/HardwareManager.java
+++ b/src/manager/HardwareManager.java
@@ -21,6 +21,6 @@ public class HardwareManager {
 		this.ultrasonicMotor = new UltrasonicMotor();
 		this.colorPoller = new ColorPoller();
 		this.linePoller = new LinePoller();
-		this.ultrasonicPoller = new UltrasonicPoller();
+		this.ultrasonicPoller = new UltrasonicPoller(manager);
 	}
 }
diff --git a/src/manager/UtilityManager.java b/src/manager/UtilityManager.java
index e1fb374..59339bd 100644
--- a/src/manager/UtilityManager.java
+++ b/src/manager/UtilityManager.java
@@ -27,4 +27,18 @@ public class UtilityManager {
 			e.printStackTrace();
 		}
 	}
+	
+	/**
+	 * Converts an array to string
+	 * @param arr
+	 * @return
+	 */
+	public String arrayToString(double[] arr) {
+		String output = "[";
+		for (int i=0; i< arr.length; i++) {
+			output += String.valueOf(arr[i]) + ", ";
+		}
+		
+		return output + "]";
+	}
 }
diff --git a/src/services/Localization.java b/src/services/Localization.java
index 2c4f585..495df11 100644
--- a/src/services/Localization.java
+++ b/src/services/Localization.java
@@ -5,7 +5,6 @@ import controllers.State;
 import utilities.*;
 import lejos.nxt.LCD;
 import lejos.nxt.Sound;
-import lejos.nxt.comm.RConsole;
 import lejos.util.Timer;
 import lejos.util.TimerListener;
 import manager.*;
@@ -47,7 +46,7 @@ public class Localization implements TimerListener {
 	public void start() {
 		
 		//Ensure the Center ultrasonic is at a good height and wait till it is done
-		manager.um.nap(Forklift.setHeight(Forklift.ForkliftState.SCAN_HEIGHT_LOW));
+		//manager.um.nap(Forklift.setHeight(Forklift.ForkliftState.SCAN_HEIGHT_LOW));
 		
 		//Retrieves center Ultrasonic reading
 		int usReading = updateUltrasonic();
@@ -89,6 +88,7 @@ public class Localization implements TimerListener {
 	
 	public void stop() {	
 		timer.stop();
+		manager.hm.drive.stop();
 	}
 	
 	/**
@@ -101,28 +101,19 @@ public class Localization implements TimerListener {
 			ultrasonicLocalization();
 		} 
 //		//not finished line localization
-//		else if(Double.isNaN(lineDetectedHeadings[3])) {
-//			//move to correct orientation for line localization
-//			if(!lineLocalization) {
-//				prepareLineLocalization();
-//			} else {
-//				lineLocalization();
-//			}
-//		} 
-//		//localization complete, update position
-//		else {
-//			updatePosition();
-//			stop();
-//		}
-		//test stub :)
-		else {
-			if(Math.abs(manager.sm.odo.getTheta()) > 0.1 )
-				manager.hm.drive.setSpeeds(0, ROTATION_SPEED);
-			else {
-				manager.hm.drive.setSpeeds(0,0);
-				stop();
-				manager.cm.setState(State.SEARCH);
+		else if(leftLineCount < 4 || rightLineCount < 4) {
+			//move to correct orientation for line localization
+			if(!lineLocalization) {
+				prepareLineLocalization();
+			} else {
+				lineLocalization();
 			}
+		} 
+		//localization complete, update position
+		else {
+			stop();
+			updatePosition();
+			manager.cm.setState(State.SEARCH);
 		}
 	}
 	
@@ -192,18 +183,9 @@ public class Localization implements TimerListener {
 			deltaTheta += Math.PI/2;
 		}
 		
-		RConsole.println(""+manager.sm.odo.getTheta());
-		
 		//update the odometer
 		manager.sm.odo.adjustPosition(0, 0, deltaTheta);
 		
-		LCD.drawString("X: ", 0, 0);
-		LCD.drawString("Y: ", 0, 1);
-		LCD.drawString("H: ", 0, 2);
-		LCD.drawInt(0, 3, 0);
-		LCD.drawInt(0, 3, 1);
-		LCD.drawInt((int) manager.sm.odo.getTheta(), 3, 2);
-		
 	}
 	
 	/**
@@ -218,7 +200,9 @@ public class Localization implements TimerListener {
 	 * Updates the odometers position based on line localization results
 	 */
 	public void updatePosition() {
-		double thetaXminus = (lineDetectedHeadings[0] + lineDetectedHeadings[4]) / 2.0;
+		
+		double thetaXminus = (lineDetectedHeadings[0] + lineDetectedHeadings[4]) / 2.0
+							 + ( (lineDetectedHeadings[4] < Math.PI) ? Math.PI : 0 );  //Correction term
 		double thetaYminus = (lineDetectedHeadings[3] + lineDetectedHeadings[7]) / 2.0;
 		double thetaYplus = (lineDetectedHeadings[1] + lineDetectedHeadings[5]) / 2.0;
 		double thetaXplus = (lineDetectedHeadings[2] + lineDetectedHeadings[6]) / 2.0;
@@ -235,10 +219,8 @@ public class Localization implements TimerListener {
 		double dTheta = (dThetaX + dThetaY) / 2.0;
 		
 		manager.sm.odo.adjustPosition(x, y, dTheta);
-
-		Position pos = manager.sm.odo.getPosition();	
 		
-		manager.cm.setState(State.SEARCH);
+		
 	}
 	
 	public void prepareLineLocalization() {
@@ -288,6 +270,5 @@ public class Localization implements TimerListener {
 				leftLineCount++;
 			}
 		}
-	}
-	
+	}	
 }
diff --git a/src/services/Navigation.java b/src/services/Navigation.java
index 415c109..0c49bc3 100644
--- a/src/services/Navigation.java
+++ b/src/services/Navigation.java
@@ -25,7 +25,7 @@ public class Navigation implements TimerListener {
 	private Timer time;
 	private final int UPDATE_PERIOD = 100;
 	private final int MAX_FORWARD_SPEED = 8;
-	private final int MAX_ROTATE_SPEED = 45;
+	private final int MAX_ROTATE_SPEED = 35;
 
 	private Stack<Point> route;
 	private Position currentPos;
@@ -50,7 +50,7 @@ public class Navigation implements TimerListener {
 
 	@Override
 	public void timedOut() {
-		if (manager.cm.getState() == State.SEARCH || manager.cm.getState() == State.DROP_OFF || manager.cm.getState() == State.RECOGNIZE) {
+		if (manager.cm.getState() == State.SEARCH || manager.cm.getState() == State.DROP_OFF || manager.cm.getState() == State.RECOGNIZE || manager.cm.getState() == State.TESTING) {
 			RConsole.println(""+manager.cm.getState().name());
 			if (route.empty()) {
 				// nothing is done
@@ -155,7 +155,7 @@ public class Navigation implements TimerListener {
 		while(Math.abs(dH) > 0.01) {
 			dH = Angle.minimumAngle(currentPos.theta, angle);
 			turnTo(dH);
-			manager.um.nap(100);
+			manager.um.nap(70);
 		}
 		
 		manager.hm.drive.stop();

commit e0d057d387a2f43f053f47920476ab359346e2a0
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Sat Nov 16 13:38:57 2013 -0500

    Cleaned up some items on Search, collect, dropoff and recognize.
    Prepared for future changes.

diff --git a/src/controllers/Collect.java b/src/controllers/Collect.java
index 18f4653..f4a9012 100644
--- a/src/controllers/Collect.java
+++ b/src/controllers/Collect.java
@@ -3,6 +3,7 @@ package controllers;
 import utilities.Settings;
 import hardwareAbstraction.Claw;
 import hardwareAbstraction.Forklift;
+import hardwareAbstraction.Forklift.ForkliftState;
 import lejos.nxt.comm.RConsole;
 import manager.Manager;
 
@@ -24,7 +25,13 @@ private Manager manager;
 		
 		//grab and lift
 		Claw.grabObject();
-		Forklift.liftObject();
+		int sleep = Forklift.setHeight(ForkliftState.LIFT_HEIGHT);
+		
+		try {
+			Thread.sleep(sleep);
+		} catch (InterruptedException e) {
+			e.printStackTrace();
+		}
 		
 		//update storage count and go to the required next step (searching or dropping off).
 		RConsole.println("storage");
@@ -34,4 +41,5 @@ private Manager manager;
 		else
 			manager.cm.setState(State.SEARCH);
 	}
+	
 }
diff --git a/src/controllers/DropOff.java b/src/controllers/DropOff.java
index b38a0cb..1787435 100644
--- a/src/controllers/DropOff.java
+++ b/src/controllers/DropOff.java
@@ -2,6 +2,7 @@ package controllers;
 
 import hardwareAbstraction.Claw;
 import hardwareAbstraction.Forklift;
+import hardwareAbstraction.Forklift.ForkliftState;
 
 import java.util.Stack;
 
@@ -49,10 +50,11 @@ private Stack<Point> route;
 			// when the robot gets to the greenZone, 
 			if(manager.sm.nav.getRoute().empty()) {
 				//drop off the block
-				Forklift.lowerObject();
+				Forklift.setHeight(ForkliftState.GROUND);
 				Claw.releaseObject();
 				
 				//go back to previous state
+				this.initialized = false;
 				this.manager.sm.nav.setRoute(route);
 				this.manager.cm.setState(State.SEARCH);
 			}
diff --git a/src/controllers/Recognize.java b/src/controllers/Recognize.java
index 334fadc..1a6d902 100644
--- a/src/controllers/Recognize.java
+++ b/src/controllers/Recognize.java
@@ -5,6 +5,7 @@ import java.util.Stack;
 import utilities.Point;
 import utilities.Position;
 import hardwareAbstraction.Forklift;
+import hardwareAbstraction.Forklift.ForkliftState;
 import lejos.nxt.comm.RConsole;
 import manager.Manager;
 
@@ -29,7 +30,8 @@ private boolean isInPosition;
 	public void run() {
 		//setup the recognize parameters at the start, only does this once. 
 		if (!isSetup) {
-
+			manager.cm.setState(State.PAUSE);
+			
 			RConsole.println("Setting up");
 			this.isSetup = true;
 			this.isInPosition = false;
@@ -39,8 +41,8 @@ private boolean isInPosition;
 			manager.sm.nav.setRoute(new Stack<Point>());
 			
 			// lower forklift if raised
-			manager.cm.setState(State.PAUSE);
-			Forklift.lowerObject();
+			
+			Forklift.setHeight(ForkliftState.GROUND);
 			
 			// reset ultrasonic sensor
 			manager.hm.ultrasonicPoller.resetUSP();
@@ -49,14 +51,14 @@ private boolean isInPosition;
 			manager.cm.setState(State.RECOGNIZE);
 
 			// if not at scan height, set it to that
-			if(manager.hm.forklift.state == Forklift.ForkliftState.LIFT_HEIGHT) {
+			if(Forklift.state == Forklift.ForkliftState.LIFT_HEIGHT) {
 				manager.cm.setState(State.PAUSE);
-				Forklift.lowerObject();
+				Forklift.setHeight(ForkliftState.GROUND);
 				manager.cm.setState(State.RECOGNIZE);
 			}
-			if (manager.hm.forklift.state != Forklift.ForkliftState.SCAN_HEIGHT) {
+			if (Forklift.state != Forklift.ForkliftState.SCAN_HEIGHT) {
 				manager.cm.setState(State.PAUSE);
-				Forklift.setScanHeight();
+				Forklift.setHeight(ForkliftState.SCAN_HEIGHT);
 				manager.cm.setState(State.RECOGNIZE);
 			}
 			//TODO figure out if we still need the colorPoller or not. 
@@ -66,7 +68,6 @@ private boolean isInPosition;
 		//if the color poller has finally collected enough values. 
 		if(manager.hm.colorPoller.isSetup()) {
 			// TODO we might not even need this code anymore!!!!!!!
-
 		}
 		
 		if (!this.isInPosition) {
@@ -99,7 +100,7 @@ private boolean isInPosition;
 					RConsole.println("Setting lowValue");
 					this.lowValue = manager.hm.ultrasonicPoller.computeAverage(middle);
 					manager.hm.ultrasonicPoller.resetUSP();
-					Forklift.setScanHeight();
+					Forklift.setHeight(ForkliftState.SCAN_HEIGHT);
 				} else {
 					RConsole.println("Setting highValue");
 					this.highValue = manager.hm.ultrasonicPoller.computeAverage(middle);
@@ -116,7 +117,6 @@ private boolean isInPosition;
 					//restore previous state before this execution 
 					manager.sm.nav.setRoute(this.prevRoute);
 					this.isSetup = false;
-	
 				}
 			}
 		}
diff --git a/src/controllers/Search.java b/src/controllers/Search.java
index b53fc91..42f94df 100644
--- a/src/controllers/Search.java
+++ b/src/controllers/Search.java
@@ -7,6 +7,7 @@ public class Search extends Controller  {
 
 	private Manager manager;
 	private int defaultPath;
+	private final int middle = 1;
 	
 	public Search(Manager manager) {
 		this.defaultPath = 0;
@@ -14,8 +15,8 @@ public class Search extends Controller  {
 	}
 	
 	public void run() {
-		
 		defaultRouter();
+		int reading = manager.hm.ultrasonicPoller.getUSReading(middle);
 		
 	}
 	/**

commit d4829f57ed2627f89ca0c6be03bff2e2e26c5977
Author: RileyvanRyswyk <rileyvan@gmail.com>
Date:   Fri Nov 15 21:57:35 2013 -0500

    Localization Tweaks

diff --git a/src/services/Localization.java b/src/services/Localization.java
index 0b57a9f..2c4f585 100644
--- a/src/services/Localization.java
+++ b/src/services/Localization.java
@@ -177,7 +177,7 @@ public class Localization implements TimerListener {
 			if(angleA > angleB) {
 				deltaTheta +=  4.45 * Math.PI / 4.0;
 			} else {
-				deltaTheta +=  0.8 * Math.PI / 4.0;
+				deltaTheta +=  0.45 * Math.PI / 4.0;
 			}
 		}
 		
@@ -236,15 +236,7 @@ public class Localization implements TimerListener {
 		
 		manager.sm.odo.adjustPosition(x, y, dTheta);
 
-		Position pos = manager.sm.odo.getPosition();
-		
-		LCD.drawString("X: ", 0, 0);
-		LCD.drawString("Y: ", 0, 1);
-		LCD.drawString("H: ", 0, 2);
-		LCD.drawInt((int) pos.x, 3, 0);
-		LCD.drawInt((int) pos.y, 3, 1);
-		LCD.drawInt((int) pos.theta, 3, 2);
-		
+		Position pos = manager.sm.odo.getPosition();	
 		
 		manager.cm.setState(State.SEARCH);
 	}

commit 5325f7fdf52a6a69a7b5650b0e97c8e08249a72d
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Fri Nov 15 18:43:38 2013 -0500

    Cleaned up lingering commented-out code on UltrasonicPoller and
    UltrasonicMotor. Added functionality to poll only one us at a time if
    facing forward).

diff --git a/src/hardwareAbstraction/UltrasonicMotor.java b/src/hardwareAbstraction/UltrasonicMotor.java
index 37d5845..3560fc6 100644
--- a/src/hardwareAbstraction/UltrasonicMotor.java
+++ b/src/hardwareAbstraction/UltrasonicMotor.java
@@ -3,12 +3,15 @@ package hardwareAbstraction;
 import utilities.Settings;
 
 public class UltrasonicMotor {
+	public static boolean isForward = false;
+
 	/**
 	 * The default position is set to be with the two side ultrasonic sensors
 	 * pointing away from the center of the robot. Therefore, it will be at an
 	 * angle when viewed from the front of the robot.
 	 */
 	public static void setDefaultPosition() {
+		isForward = false;
 		Settings.ultrasonicMotor.setSpeed(200);
 		Settings.ultrasonicMotor.rotate(45);
 	}
@@ -19,6 +22,7 @@ public class UltrasonicMotor {
 	 * angle when viewed from the front of the robot.
 	 */
 	public static void setForwardPosition() {
+		isForward = true;
 		Settings.ultrasonicMotor.setSpeed(200);
 		Settings.ultrasonicMotor.rotate(-45);
 	}
diff --git a/src/hardwareAbstraction/UltrasonicPoller.java b/src/hardwareAbstraction/UltrasonicPoller.java
index a472fca..c068cb1 100644
--- a/src/hardwareAbstraction/UltrasonicPoller.java
+++ b/src/hardwareAbstraction/UltrasonicPoller.java
@@ -21,12 +21,11 @@ public class UltrasonicPoller implements TimerListener {
 	private Timer poller;
 	private int readings[][];
 	private boolean running = false;
+	
 	private int left = 0;
 	private int center = 1;
 	private int right = 2;
 	private int counter;
-	private long previousTime;
-	private long deltaTime;
 
 	private Thread leftUS;
 	private Thread centerUS;
@@ -34,20 +33,20 @@ public class UltrasonicPoller implements TimerListener {
 
 	// TODO figure out what exactly this constructor should be.
 	public UltrasonicPoller() {
-//		us[left] = Settings.leftUltrasonic;
+		us[left] = Settings.leftUltrasonic;
 		us[center] = Settings.centerUltrasonic;
-//		us[right] = Settings.rightUltrasonic;
+		us[right] = Settings.rightUltrasonic;
 
 		this.pollRate = 100;
 		this.readings = new int[3][5];
 
-//		us[left].off();
+		us[left].off();
 		us[center].off();
-//		us[right].off();
+		us[right].off();
 
-//		this.leftUS = new Thread(new LeftUS());
+		this.leftUS = new Thread(new LeftUS());
 		this.centerUS = new Thread(new CenterUS());
-//		this.rightUS = new Thread(new RightUS());
+		this.rightUS = new Thread(new RightUS());
 
 		this.start();
 	}
@@ -58,38 +57,36 @@ public class UltrasonicPoller implements TimerListener {
 	 */
 	@Override
 	public void timedOut() {
-//		leftUS.run();
-		centerUS.run();
-//		rightUS.run();
-		RConsole.println(toStringLastValues());
-		// counter++;
-
-		// if(counter == 5) {
-		// LCD.drawString("                          ", 0, 6);
-		// LCD.drawInt((int) getUSReading(center), 0, 6);
-		// deltaTime = 0;
-		// }
-
-		// keep the counter between 0 - 2
-		// counter = counter % 5;
-
 		/*
-		 * if(counter == left) { //pingUS(left); } else if(counter == center) {
-		 * pingUS(center); } else { //pingUS(right); }
-		 * 
-		 * counter++; //keep the counter between 0 - 2 counter = counter % 3;
+		 * If the ultrasonics are facing forward, poll only one at a time.
+		 * Else poll them all simultaneously. 
 		 */
-
-		// RConsole.println(String.valueOf(System.currentTimeMillis() -
-		// currentTime));
+		if(UltrasonicMotor.isForward) {
+			switch(counter) {
+			case 0 : leftUS.run();
+			break;
+			case 1 : centerUS.run();
+			break;
+			case 2 : rightUS.run();
+			break;
+			}
+			counter += 1;
+			counter = counter % 3;
+		}
+		else {
+			leftUS.run();
+			centerUS.run();
+			rightUS.run();
+			RConsole.println(toStringLastValues());
+		}
 	}
 
 	// For debugging purposes.
 	private String toStringLastValues() {
 		String out = "";
-//		out += " L: " + getUSReading(left);
+		out += " L: " + getUSReading(left);
 		out += " C: " + getUSReading(center);
-//		out += " R: " + getUSReading(right);
+		out += " R: " + getUSReading(right);
 		return out;
 	}
 

commit bb8646bdb8da84edf39a25b538daf0d7ca77bc34
Author: RileyvanRyswyk <rileyvan@gmail.com>
Date:   Fri Nov 15 12:19:58 2013 -0500

    Navigation fixed
    
    Should remove or sufficiently eliminate oscillation.

diff --git a/src/services/Navigation.java b/src/services/Navigation.java
index b34d4a2..415c109 100644
--- a/src/services/Navigation.java
+++ b/src/services/Navigation.java
@@ -165,10 +165,14 @@ public class Navigation implements TimerListener {
 	public int calculateRotationSpeed(double dH) {
 		if (Math.abs(dH) > 0.01) {
 			// if error positive and greater than 0.2 rad -> max speed CCW
-			if (dH > 0.15) {
+			if (dH > 0.3) {
 				return -MAX_ROTATE_SPEED;
 			}
 			// positive error, between .05 and .15 , so turn slow CCW to prevent overshoot
+			else if (dH > .15) {
+				return -MAX_ROTATE_SPEED / 2;
+			}
+			// positive error, between .05 and .15 , so turn slow CCW to prevent overshoot
 			else if (dH > .05) {
 				return -MAX_ROTATE_SPEED / 6;
 			}
@@ -178,11 +182,15 @@ public class Navigation implements TimerListener {
 			}
 			
 			// if error negative and greater than 0.2 rad -> max speed CW
-			if (dH < 0.15) {
+			if (dH < -0.3) {
 				return MAX_ROTATE_SPEED;
 			}
 			// negative error, between .05 and .15 , so turn slow CW to prevent overshoot
-			else if (dH < .05) {
+			else if (dH < -.15) {
+				return MAX_ROTATE_SPEED / 2;
+			}
+			// negative error, between .05 and .15 , so turn slow CW to prevent overshoot
+			else if (dH < -.05) {
 				return MAX_ROTATE_SPEED / 6;
 			}
 			// negative error, but close to 0, so turn slow CW to prevent overshoot

commit 528141f0fb1bfff8d078bc835168dde5b81d23e8
Author: RileyvanRyswyk <rileyvan@gmail.com>
Date:   Fri Nov 15 12:02:47 2013 -0500

    LCD Info Fixes, Angle helper updated and localization tweaked

diff --git a/src/services/LCDInfo.java b/src/services/LCDInfo.java
index 51f7194..e89282d 100644
--- a/src/services/LCDInfo.java
+++ b/src/services/LCDInfo.java
@@ -1,5 +1,6 @@
 package services;
 
+import utilities.Angle;
 import utilities.Position;
 import lejos.nxt.LCD;
 import lejos.util.Timer;
@@ -33,7 +34,7 @@ public class LCDInfo implements TimerListener{
 		LCD.drawString("H: ", 0, 2);
 		LCD.drawInt((int)(pos.x * 10), 3, 0);
 		LCD.drawInt((int)(pos.y * 10), 3, 1);
-		LCD.drawInt((int)pos.theta, 3, 2);
+		LCD.drawInt(Angle.radToDeg(pos.theta), 3, 2);
 	}
 
 }
diff --git a/src/services/Localization.java b/src/services/Localization.java
index 322c6b8..0b57a9f 100644
--- a/src/services/Localization.java
+++ b/src/services/Localization.java
@@ -175,7 +175,7 @@ public class Localization implements TimerListener {
 		} else {
 			//Depending on what angle is bigger, offset deltaTheta to the correct amount
 			if(angleA > angleB) {
-				deltaTheta +=  4.0 * Math.PI / 4.0;
+				deltaTheta +=  4.45 * Math.PI / 4.0;
 			} else {
 				deltaTheta +=  0.8 * Math.PI / 4.0;
 			}
diff --git a/src/utilities/Angle.java b/src/utilities/Angle.java
index 6f88d25..f0c03b4 100644
--- a/src/utilities/Angle.java
+++ b/src/utilities/Angle.java
@@ -36,4 +36,8 @@ public class Angle {
 		else
 			return d - 2*Math.PI;
 	}
+	
+	public static int radToDeg(double rad) {
+		return (int) (rad * 180 / Math.PI);
+	}
 }

commit 4cf9c0c588bc4e8b2051134d63d1a41c8cb4796e
Author: RileyvanRyswyk <rileyvan@gmail.com>
Date:   Fri Nov 15 11:54:04 2013 -0500

    LCD Info for odometer information

diff --git a/src/manager/ServiceManager.java b/src/manager/ServiceManager.java
index d432f5a..4495b7c 100644
--- a/src/manager/ServiceManager.java
+++ b/src/manager/ServiceManager.java
@@ -12,6 +12,7 @@ public class ServiceManager {
 	public Mapper mapper;
 	public Localization localization;
 	public HardwareViewer hwView;
+	public LCDInfo lcdInfo;
 	
 	public ServiceManager(Manager manager) {
 		this.manager = manager;
@@ -21,6 +22,7 @@ public class ServiceManager {
 		this.obstacleAvoidance = new ObstacleAvoidance(manager);
 		this.mapper = new Mapper(manager);
 		this.localization = new Localization(manager);
+		this.lcdInfo = new LCDInfo(manager);
 		//this.hwView = new HardwareViewer(manager);
 	}
 	
diff --git a/src/services/LCDInfo.java b/src/services/LCDInfo.java
new file mode 100644
index 0000000..51f7194
--- /dev/null
+++ b/src/services/LCDInfo.java
@@ -0,0 +1,39 @@
+package services;
+
+import utilities.Position;
+import lejos.nxt.LCD;
+import lejos.util.Timer;
+import lejos.util.TimerListener;
+import manager.Manager;
+
+public class LCDInfo implements TimerListener{
+	public static final int LCD_REFRESH = 100;
+	private Manager manager;
+	private Timer lcdTimer;
+	
+	/**
+	 * LCDInfo constructor
+	 * @param odo
+	 */
+	public LCDInfo(Manager manager) {
+		this.manager = manager;
+		this.lcdTimer = new Timer(LCD_REFRESH, this);
+		// start the timer
+		lcdTimer.start();
+	}
+	
+	/**
+	 * main update loop
+	 */
+	public void timedOut() { 
+		Position pos = manager.sm.odo.getPosition();
+		LCD.clear();
+		LCD.drawString("X: ", 0, 0);
+		LCD.drawString("Y: ", 0, 1);
+		LCD.drawString("H: ", 0, 2);
+		LCD.drawInt((int)(pos.x * 10), 3, 0);
+		LCD.drawInt((int)(pos.y * 10), 3, 1);
+		LCD.drawInt((int)pos.theta, 3, 2);
+	}
+
+}

commit fc10fb18f8c7e39c04aa5f71afd20053903653ce
Author: RileyvanRyswyk <rileyvan@gmail.com>
Date:   Fri Nov 15 11:47:29 2013 -0500

    Localization Fixs

diff --git a/src/launcher/Launcher.java b/src/launcher/Launcher.java
index 4fcacf1..8872ce7 100644
--- a/src/launcher/Launcher.java
+++ b/src/launcher/Launcher.java
@@ -38,9 +38,9 @@ public class Launcher {
 			manager.um.nap(150);
 		}
 		
-		manager.sm.nav.addToRoute(new Point(60,0));
+		//manager.sm.nav.addToRoute(new Point(60,0));
 		manager.sm.nav.turnToComplete(0);
-		manager.cm.setState(State.SEARCH);
+		//manager.cm.setState(State.SEARCH);
 		
 //		manager.sm.nav.start();
 //		manager.cm.setState(State.RECOGNIZE);
diff --git a/src/services/Localization.java b/src/services/Localization.java
index 090c725..322c6b8 100644
--- a/src/services/Localization.java
+++ b/src/services/Localization.java
@@ -175,7 +175,7 @@ public class Localization implements TimerListener {
 		} else {
 			//Depending on what angle is bigger, offset deltaTheta to the correct amount
 			if(angleA > angleB) {
-				deltaTheta +=  4.8 * Math.PI / 4.0;
+				deltaTheta +=  4.0 * Math.PI / 4.0;
 			} else {
 				deltaTheta +=  0.8 * Math.PI / 4.0;
 			}
diff --git a/src/services/Navigation.java b/src/services/Navigation.java
index 29ce54c..b34d4a2 100644
--- a/src/services/Navigation.java
+++ b/src/services/Navigation.java
@@ -158,6 +158,8 @@ public class Navigation implements TimerListener {
 			manager.um.nap(100);
 		}
 		
+		manager.hm.drive.stop();
+		
 	}
 	
 	public int calculateRotationSpeed(double dH) {

commit 918cb39cd9474f1ae268e15203838ce2de8d7531
Author: RileyvanRyswyk <rileyvan@gmail.com>
Date:   Fri Nov 15 11:38:28 2013 -0500

    Forklift Simplications (incl delay) and other tweaks

diff --git a/src/controllers/Recognize.java b/src/controllers/Recognize.java
index ac802b6..334fadc 100644
--- a/src/controllers/Recognize.java
+++ b/src/controllers/Recognize.java
@@ -29,7 +29,7 @@ private boolean isInPosition;
 	public void run() {
 		//setup the recognize parameters at the start, only does this once. 
 		if (!isSetup) {
-<<<<<<< HEAD
+
 			RConsole.println("Setting up");
 			this.isSetup = true;
 			this.isInPosition = false;
@@ -47,7 +47,7 @@ private boolean isInPosition;
 			
 			//now return to previous state.
 			manager.cm.setState(State.RECOGNIZE);
-=======
+
 			// if not at scan height, set it to that
 			if(manager.hm.forklift.state == Forklift.ForkliftState.LIFT_HEIGHT) {
 				manager.cm.setState(State.PAUSE);
@@ -66,7 +66,7 @@ private boolean isInPosition;
 		//if the color poller has finally collected enough values. 
 		if(manager.hm.colorPoller.isSetup()) {
 			// TODO we might not even need this code anymore!!!!!!!
->>>>>>> Fixed bluetooth and Got it working
+
 		}
 		
 		if (!this.isInPosition) {
diff --git a/src/hardwareAbstraction/Forklift.java b/src/hardwareAbstraction/Forklift.java
index 87b75ae..c3e4224 100644
--- a/src/hardwareAbstraction/Forklift.java
+++ b/src/hardwareAbstraction/Forklift.java
@@ -1,13 +1,15 @@
 package hardwareAbstraction;
 
+import lejos.nxt.LCD;
 import lejos.nxt.comm.RConsole;
 import lejos.nxt.remote.RemoteMotor;
 import utilities.Settings;
 
 public class Forklift {
 	static RemoteMotor lift = Settings.forkliftMotor;
-	static int liftHeight = -15; // 15 cm upwards. Should be ok
-	static int scanHeight = -10; // 10 cm upwards. Needs to be tested. 
+	static int liftHeight = 15; // 15 cm upwards. Should be ok
+	static int scanHeight = 10; // 10 cm upwards. Needs to be tested. 
+	static int scanHeightLow = 7; // 7 cm upwards. Needs to be tested. 
 	private static double radius = 1; //radius of "spool". Must be tested. 
 	public static ForkliftState state = ForkliftState.GROUND; //sensor starts on the ground.
 	/**
@@ -24,12 +26,7 @@ public class Forklift {
 			lowerObject();
 		}
 		state = ForkliftState.LIFT_HEIGHT;
-		try {
-			lift.setSpeed(100);
-			lift.rotate(convertDistanceToAngle(liftHeight));
-		} catch (ArrayIndexOutOfBoundsException e) {
-
-		}
+		changeHeight(scanHeight);
 	}
 	
 	/**
@@ -43,29 +40,22 @@ public class Forklift {
 		if (state == ForkliftState.GROUND)
 			return;
 		state = ForkliftState.GROUND;
-		try {
-			lift.setSpeed(100);
-			lift.rotate(-convertDistanceToAngle(liftHeight));
-		} catch (ArrayIndexOutOfBoundsException e){ }
+		changeHeight(liftHeight);
 	}
 	
 	/**
 	 * This method will raise the forklift to allow the color sensor to identify the block. 
 	 * @bug the execution of external motors causes exceptions. Try-catch block was put for now. Must be fixed.
 	 */
-	public static void setScanHeight() {
+	public static int setScanHeight() {
 		RConsole.println("lifting to scan height");
 		if (state == ForkliftState.LIFT_HEIGHT)
 			lowerObject();
 		if (state == ForkliftState.SCAN_HEIGHT)
-			return;
+			return 0;
 		state = ForkliftState.SCAN_HEIGHT;
-		try {
-			lift.setSpeed(100);
-			lift.rotate(convertDistanceToAngle(scanHeight));
-		} catch (ArrayIndexOutOfBoundsException e){
 		
-		}
+		return changeHeight(scanHeight);
 	}
 	
 	/**
@@ -79,12 +69,43 @@ public class Forklift {
 		if (state == ForkliftState.GROUND)
 			return;
 		state = ForkliftState.GROUND;
+		changeHeight(scanHeight);
+	}
+	
+	public static int setHeight(ForkliftState s) {
+		int height;
+		
+		if (s == ForkliftState.LIFT_HEIGHT) {
+			height = liftHeight;
+		} else if(s == ForkliftState.SCAN_HEIGHT ) {
+			height = scanHeight;
+		} else if(s == ForkliftState.SCAN_HEIGHT_LOW ) {
+			height = scanHeightLow;
+		} else {
+			height = 0;
+		}
+		
+		state = s;
+		return changeHeight(height);
+	}
+	
+	/**
+	 * Changes the height of the forklift
+	 * Won't return until the height is reached
+	 * @param newHeight
+	 */
+	private static int changeHeight(int newHeight) {
+		int rotation = convertDistanceToAngle(newHeight);
+		int naptime = rotation*11;
+		
 		try {
 			lift.setSpeed(100);
-			lift.rotate(-convertDistanceToAngle(scanHeight));
+			lift.rotateTo(-rotation);
 		} catch (ArrayIndexOutOfBoundsException e){
 		
 		}
+		
+		return naptime;
 	}
 
 	/**
@@ -95,10 +116,10 @@ public class Forklift {
 	 * @return
 	 */
 	private static int convertDistanceToAngle(int distance) {
-		return (int)( (distance * 360) / (2 * Math.PI * radius) );
+		return (int)( (distance * 180) / (Math.PI * radius) );
 	}
 	
 	public enum ForkliftState {
-		GROUND, SCAN_HEIGHT, LIFT_HEIGHT;
+		GROUND, SCAN_HEIGHT, LIFT_HEIGHT, SCAN_HEIGHT_LOW;
 	}
 }
diff --git a/src/launcher/Launcher.java b/src/launcher/Launcher.java
index 5ab9581..4fcacf1 100644
--- a/src/launcher/Launcher.java
+++ b/src/launcher/Launcher.java
@@ -27,20 +27,23 @@ public class Launcher {
 	 * @param args
 	 */
 	public static void main(String[] args) {
-		RConsole.openUSB(20000);
-		Button.waitForPress();
+		//RConsole.openUSB(20000);
+		
 		
 		Manager manager = new Manager();
-//		manager.sm.localization.start();
-//		
-//		while(manager.cm.getState() == State.LOCALIZING) {
-//			manager.um.nap(150);
-//		}
-//		
-//		manager.cm.setState(State.SEARCH);
+		Button.waitForPress();
+		manager.sm.localization.start();
+		
+		while(manager.cm.getState() == State.LOCALIZING) {
+			manager.um.nap(150);
+		}
+		
+		manager.sm.nav.addToRoute(new Point(60,0));
+		manager.sm.nav.turnToComplete(0);
+		manager.cm.setState(State.SEARCH);
 		
-		manager.sm.nav.start();
-		manager.cm.setState(State.RECOGNIZE);
+//		manager.sm.nav.start();
+//		manager.cm.setState(State.RECOGNIZE);
 //		manager.sm.nav.addToRoute(new Point(60,0));
 //		manager.sm.nav.turnToComplete(0);
 		
diff --git a/src/manager/UtilityManager.java b/src/manager/UtilityManager.java
index 0891f66..e1fb374 100644
--- a/src/manager/UtilityManager.java
+++ b/src/manager/UtilityManager.java
@@ -12,7 +12,7 @@ public class UtilityManager {
 	public UtilityManager(Manager manager) {
 		this.manager = manager;
 		
-		BluetoothTransmission.getBluetoothData();
+		//BluetoothTransmission.getBluetoothData();
 		this.comLink = new Communicator(Settings.NXTSlaveName);
 		this.map = new Map();
 	}
diff --git a/src/services/Localization.java b/src/services/Localization.java
index bb4ef96..090c725 100644
--- a/src/services/Localization.java
+++ b/src/services/Localization.java
@@ -1,5 +1,6 @@
 package services;
 
+import hardwareAbstraction.Forklift;
 import controllers.State;
 import utilities.*;
 import lejos.nxt.LCD;
@@ -45,6 +46,9 @@ public class Localization implements TimerListener {
 	 */
 	public void start() {
 		
+		//Ensure the Center ultrasonic is at a good height and wait till it is done
+		manager.um.nap(Forklift.setHeight(Forklift.ForkliftState.SCAN_HEIGHT_LOW));
+		
 		//Retrieves center Ultrasonic reading
 		int usReading = updateUltrasonic();
 		
@@ -171,9 +175,9 @@ public class Localization implements TimerListener {
 		} else {
 			//Depending on what angle is bigger, offset deltaTheta to the correct amount
 			if(angleA > angleB) {
-				deltaTheta +=  5.0 * Math.PI / 4.0;
+				deltaTheta +=  4.8 * Math.PI / 4.0;
 			} else {
-				deltaTheta +=  Math.PI / 4.0;
+				deltaTheta +=  0.8 * Math.PI / 4.0;
 			}
 		}
 		
diff --git a/src/services/Navigation.java b/src/services/Navigation.java
index fd78524..29ce54c 100644
--- a/src/services/Navigation.java
+++ b/src/services/Navigation.java
@@ -168,11 +168,11 @@ public class Navigation implements TimerListener {
 			}
 			// positive error, between .05 and .15 , so turn slow CCW to prevent overshoot
 			else if (dH > .05) {
-				return -MAX_ROTATE_SPEED / 4;
+				return -MAX_ROTATE_SPEED / 6;
 			}
 			// positive error, but close to 0, so turn slow CCW to prevent overshoot
-			else if (dH > 0) {
-				return -MAX_ROTATE_SPEED / 8;
+			else if (dH > 0.01) {
+				return -MAX_ROTATE_SPEED / 16;
 			}
 			
 			// if error negative and greater than 0.2 rad -> max speed CW
@@ -181,11 +181,11 @@ public class Navigation implements TimerListener {
 			}
 			// negative error, between .05 and .15 , so turn slow CW to prevent overshoot
 			else if (dH < .05) {
-				return MAX_ROTATE_SPEED / 4;
+				return MAX_ROTATE_SPEED / 6;
 			}
 			// negative error, but close to 0, so turn slow CW to prevent overshoot
-			else if (dH < 0) {
-				return MAX_ROTATE_SPEED / 8;
+			else if (dH < -0.01) {
+				return MAX_ROTATE_SPEED / 16;
 			}
 		}
 		//if this point is reached, dH is basically zero (<0.6deg)
diff --git a/src/utilities/BluetoothTransmission.java b/src/utilities/BluetoothTransmission.java
index 5601a27..4f89f56 100644
--- a/src/utilities/BluetoothTransmission.java
+++ b/src/utilities/BluetoothTransmission.java
@@ -25,6 +25,7 @@ public class BluetoothTransmission {
 		Settings.redZoneCoords = new Point[2];
 		stream = getConnection();
 		getInformation();
+		close();
 	}
 	
 	private static DataInputStream getConnection() {
@@ -35,6 +36,13 @@ public class BluetoothTransmission {
 		return conn.openDataInputStream();
 	}
 	
+	private static void close() {
+		try {
+			stream.close();
+		} catch (IOException e) {
+		}
+	}
+	
 	private static void getInformation() {
 		//TODO verify the input of the coordinates with the server. I am assuming the coordinates are sent as a series of 8 integers. The order is unknown. 
 		try {
diff --git a/src/utilities/Settings.java b/src/utilities/Settings.java
index ecd89ec..f6d1bb3 100644
--- a/src/utilities/Settings.java
+++ b/src/utilities/Settings.java
@@ -30,7 +30,7 @@ public class Settings {
 	
 	public static int role;
 	public static Point[] redZoneCoords;
-	public static Point[] greenZoneCoords; //TODO remove once BT is working.
+	public static Point[] greenZoneCoords = new Point[2]; //TODO remove once BT is working.
 	public static StartingCorner startingCorner = StartingCorner.BOTTOM_LEFT;
 	
 	public static final double LS_OFFSET = 15.0;

commit 25f77012c64038cda152ca7bd4f435088c831fb8
Author: RileyvanRyswyk <rileyvan@gmail.com>
Date:   Fri Nov 15 10:18:00 2013 -0500

    Updated Bluetooth (Attempt 3)

diff --git a/src/controllers/Recognize.java b/src/controllers/Recognize.java
index b46518a..ac802b6 100644
--- a/src/controllers/Recognize.java
+++ b/src/controllers/Recognize.java
@@ -29,6 +29,7 @@ private boolean isInPosition;
 	public void run() {
 		//setup the recognize parameters at the start, only does this once. 
 		if (!isSetup) {
+<<<<<<< HEAD
 			RConsole.println("Setting up");
 			this.isSetup = true;
 			this.isInPosition = false;
@@ -46,6 +47,26 @@ private boolean isInPosition;
 			
 			//now return to previous state.
 			manager.cm.setState(State.RECOGNIZE);
+=======
+			// if not at scan height, set it to that
+			if(manager.hm.forklift.state == Forklift.ForkliftState.LIFT_HEIGHT) {
+				manager.cm.setState(State.PAUSE);
+				Forklift.lowerObject();
+				manager.cm.setState(State.RECOGNIZE);
+			}
+			if (manager.hm.forklift.state != Forklift.ForkliftState.SCAN_HEIGHT) {
+				manager.cm.setState(State.PAUSE);
+				Forklift.setScanHeight();
+				manager.cm.setState(State.RECOGNIZE);
+			}
+			//TODO figure out if we still need the colorPoller or not. 
+			// start the color poller 
+			manager.hm.colorPoller.start();
+		}
+		//if the color poller has finally collected enough values. 
+		if(manager.hm.colorPoller.isSetup()) {
+			// TODO we might not even need this code anymore!!!!!!!
+>>>>>>> Fixed bluetooth and Got it working
 		}
 		
 		if (!this.isInPosition) {
diff --git a/src/hardwareAbstraction/Forklift.java b/src/hardwareAbstraction/Forklift.java
index 1be62ea..87b75ae 100644
--- a/src/hardwareAbstraction/Forklift.java
+++ b/src/hardwareAbstraction/Forklift.java
@@ -9,7 +9,7 @@ public class Forklift {
 	static int liftHeight = -15; // 15 cm upwards. Should be ok
 	static int scanHeight = -10; // 10 cm upwards. Needs to be tested. 
 	private static double radius = 1; //radius of "spool". Must be tested. 
-	private static ForkliftState state = ForkliftState.GROUND; //sensor starts on the ground.
+	public static ForkliftState state = ForkliftState.GROUND; //sensor starts on the ground.
 	/**
 	 * This method lifts an object. Returns nothing.
 	 * @bug the execution of external motors causes exceptions. Try-catch block was put for now. Must be fixed. 
diff --git a/src/manager/UtilityManager.java b/src/manager/UtilityManager.java
index bd08521..0891f66 100644
--- a/src/manager/UtilityManager.java
+++ b/src/manager/UtilityManager.java
@@ -5,14 +5,14 @@ import utilities.*;
 public class UtilityManager {
 	
 	public Manager manager;
-	public BluetoothTransmission bt;
 	public Communicator comLink; 
 	public Map map;
 	
 	
 	public UtilityManager(Manager manager) {
 		this.manager = manager;
-		this.bt = new BluetoothTransmission();
+		
+		BluetoothTransmission.getBluetoothData();
 		this.comLink = new Communicator(Settings.NXTSlaveName);
 		this.map = new Map();
 	}
diff --git a/src/utilities/BluetoothTransmission.java b/src/utilities/BluetoothTransmission.java
index 7adb519..5601a27 100644
--- a/src/utilities/BluetoothTransmission.java
+++ b/src/utilities/BluetoothTransmission.java
@@ -10,31 +10,36 @@ import lejos.nxt.LCD;
 import lejos.nxt.comm.BTConnection;
 import lejos.nxt.comm.Bluetooth;
 import lejos.nxt.comm.NXTConnection;
+import lejos.nxt.comm.RConsole;
 
 /**
  * This class will open a new 
- * @author Riley
+ * @author Danielle
  *
  */
 public class BluetoothTransmission {
 	static DataInputStream stream; 
 	
 	public static void getBluetoothData() {
-		Settings.greenZoneCoords = new Point[4];
-		Settings.redZoneCoords = new Point[4];
-		stream = new DataInputStream(getConnection());
+		Settings.greenZoneCoords = new Point[2];
+		Settings.redZoneCoords = new Point[2];
+		stream = getConnection();
 		getInformation();
 	}
 	
 	private static DataInputStream getConnection() {
-		BTConnection btc = Bluetooth.waitForConnection(0, NXTConnection.LCP);
-		return btc.openDataInputStream();
+		LCD.clear();
+		LCD.drawString("Starting BT connection", 0, 0);
+		NXTConnection conn = Bluetooth.waitForConnection();
+		LCD.drawString("BT Connected", 0, 1);
+		return conn.openDataInputStream();
 	}
 	
 	private static void getInformation() {
 		//TODO verify the input of the coordinates with the server. I am assuming the coordinates are sent as a series of 8 integers. The order is unknown. 
 		try {
 			Settings.role = stream.readInt();
+			
 			char useless = stream.readChar();
 			int startingCorner = stream.readInt();
 			//TODO figure out which numbers correspond to which corners. And their values. 
@@ -48,6 +53,7 @@ public class BluetoothTransmission {
 			case 4 : Settings.startingCorner = StartingCorner.TOP_RIGHT; 
 			break;
 			}
+			
 			for(int i = 0; i < Settings.greenZoneCoords.length; i++) {
 				useless = stream.readChar();
 				int x = stream.readInt();
@@ -55,6 +61,7 @@ public class BluetoothTransmission {
 				int y = stream.readInt();
 				Settings.greenZoneCoords[i] = new Point(x,y);
 			}
+			
 			for(int i = 0; i < Settings.redZoneCoords.length; i++) {
 				useless = stream.readChar();
 				int x = stream.readInt();
diff --git a/src/utilities/Settings.java b/src/utilities/Settings.java
index 81f56ee..ecd89ec 100644
--- a/src/utilities/Settings.java
+++ b/src/utilities/Settings.java
@@ -30,7 +30,7 @@ public class Settings {
 	
 	public static int role;
 	public static Point[] redZoneCoords;
-	public static Point[] greenZoneCoords = {new Point(60, 60), null, null, null}; //TODO remove once BT is working.
+	public static Point[] greenZoneCoords; //TODO remove once BT is working.
 	public static StartingCorner startingCorner = StartingCorner.BOTTOM_LEFT;
 	
 	public static final double LS_OFFSET = 15.0;

commit a6c76c1b3e08cb4e9cc190029b33b162f679ad5d
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Fri Nov 15 02:13:32 2013 -0500

    Added some comments for Recognize.java. Should be more readable now.
    Also removed useless logic where appropriate.

diff --git a/src/controllers/Recognize.java b/src/controllers/Recognize.java
index 6976cca..b46518a 100644
--- a/src/controllers/Recognize.java
+++ b/src/controllers/Recognize.java
@@ -16,27 +16,29 @@ private Stack<Point> prevRoute;
 private int lowValue;
 private int highValue;
 private final int middle = 1;
-private boolean navigating;;
+private boolean isInPosition;
 	
 	public Recognize(Manager manager) {
 		this.manager = manager;
 		this.isSetup = false;
-		this.lowValue = -1;
-		this.highValue = -1;
-		this.navigating = false;
+		this.lowValue = -1; // reading when the forklift is down
+		this.highValue = -1; // reading when the forklift is up.
+		this.isInPosition = false;
 	}
 	
 	public void run() {
+		//setup the recognize parameters at the start, only does this once. 
 		if (!isSetup) {
 			RConsole.println("Setting up");
 			this.isSetup = true;
+			this.isInPosition = false;
+			
 			//set navigation to do nothing for the moment. 
 			this.prevRoute = manager.sm.nav.getRoute();
 			manager.sm.nav.setRoute(new Stack<Point>());
 			
-			// reset forklift
+			// lower forklift if raised
 			manager.cm.setState(State.PAUSE);
-			RConsole.println("Lowering Forklift");
 			Forklift.lowerObject();
 			
 			// reset ultrasonic sensor
@@ -44,39 +46,44 @@ private boolean navigating;;
 			
 			//now return to previous state.
 			manager.cm.setState(State.RECOGNIZE);
-
 		}
-		//if not navigating
-		if(manager.sm.nav.getRoute().empty()) {
-			this.navigating = false;
-			RConsole.println("Route is empty, see if the robot needs to correct its navigation");
-			int midReading = manager.hm.ultrasonicPoller.getUSReading(middle);
-			
-			//check if the robot must be corrected (if the midreading is not initialized and the low value has not been taken), do that if so.
-			if(midReading != -1 && lowValue == -1) {
-				//correct to about 20 cm.
-				if(midReading < 19 || midReading > 21 && !this.navigating) {
-					RConsole.println("The robot is trying to get to the object");
-					Position currentPos = manager.sm.odo.getPosition();
-					manager.sm.nav.addToRoute(currentPos.addDistanceToPosition(20 - midReading));
-					//end this if statement now, don't execute next if statement.
+		
+		if (!this.isInPosition) {
+				RConsole.println("See if the robot needs to correct its navigation");
+				int midReading = manager.hm.ultrasonicPoller
+						.getUSReading(middle);
+
+				// check if the robot must move to 20 cm from the object, but only when the first reading is taken.
+				if (midReading != -1) {
+					// if not 20 cm from the object, then correct the robot to
+					// be 20 from object
+					if (midReading < 19 || midReading > 21) {
+						RConsole.println("The robot is trying to get to the object");
+						Position currentPos = manager.sm.odo.getPosition();
+						manager.sm.nav.addToRoute(currentPos
+								.addDistanceToPosition(20 - midReading)); //TODO debug this method. 
+					}
+					this.isInPosition = true;
 				}
+				
 			}
-		}
 		
+		//once in position, route is empty. 
 		if(manager.sm.nav.getRoute().empty()) {	
 			//once the us is setup, get the low and high values. 
 			if(manager.hm.ultrasonicPoller.isSetup()) {
 				RConsole.print("Ultrasonic is setup, ");
 				if (lowValue == -1) {
+					// set low value. Reset the USP and raise the forklift. 
 					RConsole.println("Setting lowValue");
 					this.lowValue = manager.hm.ultrasonicPoller.computeAverage(middle);
+					manager.hm.ultrasonicPoller.resetUSP();
 					Forklift.setScanHeight();
 				} else {
 					RConsole.println("Setting highValue");
 					this.highValue = manager.hm.ultrasonicPoller.computeAverage(middle);
 					
-					//if a block, the difference of the low and high values will be low. Otherwise it will be huge. 
+					//if an obstacle, the difference of the low and high values will be low. Otherwise it will be huge. 
 					if(this.highValue - this.lowValue > 50) { //if a styrofoam block
 						RConsole.println("Collection executed now.");
 						manager.cm.setState(State.COLLECT);
@@ -85,19 +92,12 @@ private boolean navigating;;
 						RConsole.println("Wall Follower now");
 						manager.cm.setState(State.WALL_FOLLOWER);
 					}
+					//restore previous state before this execution 
+					manager.sm.nav.setRoute(this.prevRoute);
+					this.isSetup = false;
+	
 				}
 			}
 		}
-		
-		//TODO figure out if we still need the colorPoller or not. 
-		// start the color poller 
-//		manager.hm.colorPoller.start();
-		//if the color poller has finally collected enough values. 
-//		if(manager.hm.colorPoller.isSetup()) {
-//			// TODO we might not even need this code anymore!!!!!!!
-//		}
-		
-		
-		
 	}
 }

commit 07aa23c6bccf13a12fafe392f1f95ee7ce3b129f
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Thu Nov 14 23:51:20 2013 -0500

    The recognize function was worked on however it does not work at this
    moment. Ultrasonic poller was cut down to one sensor for the moment.
    Small changes in navigatio and controllerManager. Launcher was changed
    to match the test.

diff --git a/src/controllers/Recognize.java b/src/controllers/Recognize.java
index b46c118..6976cca 100644
--- a/src/controllers/Recognize.java
+++ b/src/controllers/Recognize.java
@@ -1,39 +1,102 @@
 package controllers;
 
+import java.util.Stack;
+
+import utilities.Point;
+import utilities.Position;
 import hardwareAbstraction.Forklift;
+import lejos.nxt.comm.RConsole;
 import manager.Manager;
 
 public class Recognize extends Controller {
 
 private Manager manager;
 private boolean isSetup;
+private Stack<Point> prevRoute;
+private int lowValue;
+private int highValue;
+private final int middle = 1;
+private boolean navigating;;
 	
 	public Recognize(Manager manager) {
 		this.manager = manager;
 		this.isSetup = false;
+		this.lowValue = -1;
+		this.highValue = -1;
+		this.navigating = false;
 	}
 	
 	public void run() {
 		if (!isSetup) {
-			// if not at scan height, set it to that
-			if(Forklift.atLiftHeight) {
-				manager.cm.setState(State.PAUSE);
-				Forklift.lowerObject();
-				manager.cm.setState(State.RECOGNIZE);
+			RConsole.println("Setting up");
+			this.isSetup = true;
+			//set navigation to do nothing for the moment. 
+			this.prevRoute = manager.sm.nav.getRoute();
+			manager.sm.nav.setRoute(new Stack<Point>());
+			
+			// reset forklift
+			manager.cm.setState(State.PAUSE);
+			RConsole.println("Lowering Forklift");
+			Forklift.lowerObject();
+			
+			// reset ultrasonic sensor
+			manager.hm.ultrasonicPoller.resetUSP();
+			
+			//now return to previous state.
+			manager.cm.setState(State.RECOGNIZE);
+
+		}
+		//if not navigating
+		if(manager.sm.nav.getRoute().empty()) {
+			this.navigating = false;
+			RConsole.println("Route is empty, see if the robot needs to correct its navigation");
+			int midReading = manager.hm.ultrasonicPoller.getUSReading(middle);
+			
+			//check if the robot must be corrected (if the midreading is not initialized and the low value has not been taken), do that if so.
+			if(midReading != -1 && lowValue == -1) {
+				//correct to about 20 cm.
+				if(midReading < 19 || midReading > 21 && !this.navigating) {
+					RConsole.println("The robot is trying to get to the object");
+					Position currentPos = manager.sm.odo.getPosition();
+					manager.sm.nav.addToRoute(currentPos.addDistanceToPosition(20 - midReading));
+					//end this if statement now, don't execute next if statement.
+				}
 			}
-			if (!Forklift.atScanHeight) {
-				manager.cm.setState(State.PAUSE);
-				Forklift.setScanHeight();
-				manager.cm.setState(State.RECOGNIZE);
+		}
+		
+		if(manager.sm.nav.getRoute().empty()) {	
+			//once the us is setup, get the low and high values. 
+			if(manager.hm.ultrasonicPoller.isSetup()) {
+				RConsole.print("Ultrasonic is setup, ");
+				if (lowValue == -1) {
+					RConsole.println("Setting lowValue");
+					this.lowValue = manager.hm.ultrasonicPoller.computeAverage(middle);
+					Forklift.setScanHeight();
+				} else {
+					RConsole.println("Setting highValue");
+					this.highValue = manager.hm.ultrasonicPoller.computeAverage(middle);
+					
+					//if a block, the difference of the low and high values will be low. Otherwise it will be huge. 
+					if(this.highValue - this.lowValue > 50) { //if a styrofoam block
+						RConsole.println("Collection executed now.");
+						manager.cm.setState(State.COLLECT);
+					}
+					else {
+						RConsole.println("Wall Follower now");
+						manager.cm.setState(State.WALL_FOLLOWER);
+					}
+				}
 			}
-			//TODO figure out if we still need the colorPoller or not. 
-			// start the color poller 
-			manager.hm.colorPoller.start();
 		}
+		
+		//TODO figure out if we still need the colorPoller or not. 
+		// start the color poller 
+//		manager.hm.colorPoller.start();
 		//if the color poller has finally collected enough values. 
-		if(manager.hm.colorPoller.isSetup()) {
-			// TODO we might not even need this code anymore!!!!!!!
-		}
+//		if(manager.hm.colorPoller.isSetup()) {
+//			// TODO we might not even need this code anymore!!!!!!!
+//		}
+		
 		
 		
 	}
diff --git a/src/controllers/State.java b/src/controllers/State.java
index 669624c..1f0468c 100644
--- a/src/controllers/State.java
+++ b/src/controllers/State.java
@@ -6,5 +6,5 @@ package controllers;
  *
  */
 public enum State {
-	SEARCH, RECOGNIZE, COLLECT, DROP_OFF, WALL_FOLLOWER, LOCALIZING, PAUSE
+	SEARCH, RECOGNIZE, COLLECT, DROP_OFF, WALL_FOLLOWER, LOCALIZING, PAUSE, TEMP
 }
diff --git a/src/hardwareAbstraction/UltrasonicPoller.java b/src/hardwareAbstraction/UltrasonicPoller.java
index 5f0fd50..a472fca 100644
--- a/src/hardwareAbstraction/UltrasonicPoller.java
+++ b/src/hardwareAbstraction/UltrasonicPoller.java
@@ -34,20 +34,20 @@ public class UltrasonicPoller implements TimerListener {
 
 	// TODO figure out what exactly this constructor should be.
 	public UltrasonicPoller() {
-		us[left] = Settings.leftUltrasonic;
+//		us[left] = Settings.leftUltrasonic;
 		us[center] = Settings.centerUltrasonic;
-		us[right] = Settings.rightUltrasonic;
+//		us[right] = Settings.rightUltrasonic;
 
-		this.pollRate = 10;
+		this.pollRate = 100;
 		this.readings = new int[3][5];
 
-		us[left].off();
+//		us[left].off();
 		us[center].off();
-		us[right].off();
+//		us[right].off();
 
-		this.leftUS = new Thread(new LeftUS());
+//		this.leftUS = new Thread(new LeftUS());
 		this.centerUS = new Thread(new CenterUS());
-		this.rightUS = new Thread(new RightUS());
+//		this.rightUS = new Thread(new RightUS());
 
 		this.start();
 	}
@@ -58,9 +58,9 @@ public class UltrasonicPoller implements TimerListener {
 	 */
 	@Override
 	public void timedOut() {
-		leftUS.run();
+//		leftUS.run();
 		centerUS.run();
-		rightUS.run();
+//		rightUS.run();
 		RConsole.println(toStringLastValues());
 		// counter++;
 
@@ -87,9 +87,9 @@ public class UltrasonicPoller implements TimerListener {
 	// For debugging purposes.
 	private String toStringLastValues() {
 		String out = "";
-		out += " L: " + getUSReading(left);
+//		out += " L: " + getUSReading(left);
 		out += " C: " + getUSReading(center);
-		out += " R: " + getUSReading(right);
+//		out += " R: " + getUSReading(right);
 		return out;
 	}
 
@@ -101,11 +101,9 @@ public class UltrasonicPoller implements TimerListener {
 		counter = 0;
 
 		// for filtering purposes
-		this.resetUSP();
 		this.poller = new Timer(pollRate, this);
 		this.poller.start();
 		running = true;
-		this.previousTime = System.currentTimeMillis();
 	}
 
 	/**
@@ -113,19 +111,17 @@ public class UltrasonicPoller implements TimerListener {
 	 * ultrasonic sensor will never return negative values during normal
 	 * operation. Stops the polling during this operation to avoid overwriting
 	 * good data.
+	 * @bug throws null pointer exception. Has potentially been fixed. Needs to be tested.
 	 */
 	public void resetUSP() {
-		poller.stop();
-		int i = 0;
-		for (int[] sensor : readings) {
-			int j = 0;
-			for (int reading : sensor) {
+		this.stop();
+		for (int i = 0; i < readings.length; ++i) {
+			for (int j = 0; j < readings[1].length; ++j) {
+				RConsole.println("" + i + "," + j);
 				readings[i][j] = -1;
-				++j;
 			}
-			++i;
 		}
-		poller.start();
+		this.start();
 	}
 
 	/**
@@ -247,6 +243,18 @@ public class UltrasonicPoller implements TimerListener {
 		readings[sensor][1] = readings[sensor][0];
 		readings[sensor][0] = reading;
 	}
+	
+	/**
+	 * Computes the average values read by a sensor
+	 * @param sensor	The integer value corresponding to the ultrasonic sensor
+	 * @return The average integer value, in integer value.
+	 */
+	public int computeAverage(int sensor) {
+		int sum = 0;
+		for(int i = 0; i < readings[sensor].length; i++)
+			sum += readings[sensor][i];
+		return (sum / readings[sensor].length);
+	}
 
 	public class LeftUS implements Runnable {
 
diff --git a/src/launcher/Launcher.java b/src/launcher/Launcher.java
index 7781352..5ab9581 100644
--- a/src/launcher/Launcher.java
+++ b/src/launcher/Launcher.java
@@ -38,11 +38,12 @@ public class Launcher {
 //		}
 //		
 //		manager.cm.setState(State.SEARCH);
-//		
-//		manager.sm.nav.start();
+		
+		manager.sm.nav.start();
+		manager.cm.setState(State.RECOGNIZE);
 //		manager.sm.nav.addToRoute(new Point(60,0));
 //		manager.sm.nav.turnToComplete(0);
-//		
+		
 //		manager.cm.setState(State.COLLECT);
 		
 		Button.waitForPress();
diff --git a/src/manager/ControllerManager.java b/src/manager/ControllerManager.java
index f342aed..78e141b 100644
--- a/src/manager/ControllerManager.java
+++ b/src/manager/ControllerManager.java
@@ -1,5 +1,6 @@
 package manager;
 
+import lejos.nxt.comm.RConsole;
 import lejos.util.Timer;
 import lejos.util.TimerListener;
 import controllers.*;
@@ -38,7 +39,7 @@ public class ControllerManager implements TimerListener {
 	}
 	
 	public void timedOut() {
-		
+		RConsole.println("" + getState().name());
 		if(state == State.SEARCH) controllers[0].run();
 		else if(state == State.RECOGNIZE) controllers[1].run();
 		else if(state == State.COLLECT) controllers[2].run();
diff --git a/src/services/Navigation.java b/src/services/Navigation.java
index 05da355..fd78524 100644
--- a/src/services/Navigation.java
+++ b/src/services/Navigation.java
@@ -50,8 +50,8 @@ public class Navigation implements TimerListener {
 
 	@Override
 	public void timedOut() {
-		if (manager.cm.getState() == State.SEARCH || manager.cm.getState() == State.DROP_OFF) {
-		
+		if (manager.cm.getState() == State.SEARCH || manager.cm.getState() == State.DROP_OFF || manager.cm.getState() == State.RECOGNIZE) {
+			RConsole.println(""+manager.cm.getState().name());
 			if (route.empty()) {
 				// nothing is done
 			} else {
@@ -71,12 +71,12 @@ public class Navigation implements TimerListener {
 					RConsole.println(""+Math.abs(dX)+" "+Math.abs(dY));
 					//scan ahead only once facing the correct orientation, then travelTo that destination.
 					//TODO comment back this code. Problematic code for the moment. 
-					if (!scannedAhead) {
-						manager.hm.drive.stop();
-						this.pause();
-						manager.cm.setState(State.RECOGNIZE);
-						this.start();
-					}
+//					if (!scannedAhead) {
+//						manager.hm.drive.stop();
+//						this.pause();
+//						manager.cm.setState(State.RECOGNIZE);
+//						this.start();
+//					}
 					travelTo();
 				} else {
 					//stop the motors, reset scanning state and get next destination. 

commit 3dd19573f6289fc505b5880a01c2d0d9e7a8f1f7
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Thu Nov 14 21:26:33 2013 -0500

    Modified the code so we can conduct the Size View US Test

diff --git a/src/hardwareAbstraction/UltrasonicPoller.java b/src/hardwareAbstraction/UltrasonicPoller.java
index 3ae38de..5f0fd50 100644
--- a/src/hardwareAbstraction/UltrasonicPoller.java
+++ b/src/hardwareAbstraction/UltrasonicPoller.java
@@ -61,6 +61,7 @@ public class UltrasonicPoller implements TimerListener {
 		leftUS.run();
 		centerUS.run();
 		rightUS.run();
+		RConsole.println(toStringLastValues());
 		// counter++;
 
 		// if(counter == 5) {
@@ -110,9 +111,11 @@ public class UltrasonicPoller implements TimerListener {
 	/**
 	 * Resets the ultrasonic sensor values to the default -1 values. The
 	 * ultrasonic sensor will never return negative values during normal
-	 * operation.
+	 * operation. Stops the polling during this operation to avoid overwriting
+	 * good data.
 	 */
 	public void resetUSP() {
+		poller.stop();
 		int i = 0;
 		for (int[] sensor : readings) {
 			int j = 0;
@@ -122,6 +125,7 @@ public class UltrasonicPoller implements TimerListener {
 			}
 			++i;
 		}
+		poller.start();
 	}
 
 	/**
@@ -129,13 +133,10 @@ public class UltrasonicPoller implements TimerListener {
 	 * this by checking for any negative numbers in the readings.
 	 */
 	public boolean isSetup() {
-		for (int[] sensor : readings) {
-			for (int reading : sensor) {
-				if (reading < 0)
-					return false;
-			}
-		}
-		return true;
+		if (readings[2][4] == -1)
+			return false;
+		else
+			return true;
 	}
 
 	/**
diff --git a/src/launcher/Launcher.java b/src/launcher/Launcher.java
index 7ff120f..7781352 100644
--- a/src/launcher/Launcher.java
+++ b/src/launcher/Launcher.java
@@ -36,14 +36,14 @@ public class Launcher {
 //		while(manager.cm.getState() == State.LOCALIZING) {
 //			manager.um.nap(150);
 //		}
-		
-		manager.cm.setState(State.SEARCH);
-		
-		manager.sm.nav.start();
-		manager.sm.nav.addToRoute(new Point(60,0));
-		manager.sm.nav.turnToComplete(0);
-		
-		manager.cm.setState(State.COLLECT);
+//		
+//		manager.cm.setState(State.SEARCH);
+//		
+//		manager.sm.nav.start();
+//		manager.sm.nav.addToRoute(new Point(60,0));
+//		manager.sm.nav.turnToComplete(0);
+//		
+//		manager.cm.setState(State.COLLECT);
 		
 		Button.waitForPress();
 	

commit f61a524503fb37f3f723c6d2ca1fe4f3edd5a658
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Thu Nov 14 21:06:03 2013 -0500

    Formatted USP class.

diff --git a/src/hardwareAbstraction/UltrasonicPoller.java b/src/hardwareAbstraction/UltrasonicPoller.java
index 10d2e79..3ae38de 100644
--- a/src/hardwareAbstraction/UltrasonicPoller.java
+++ b/src/hardwareAbstraction/UltrasonicPoller.java
@@ -7,14 +7,16 @@ import lejos.nxt.comm.RConsole;
 import lejos.util.Timer;
 import lejos.util.TimerListener;
 
-/**This class serves as a higher level abstraction of a ultrasonic sensor. It is
+/**
+ * This class serves as a higher level abstraction of a ultrasonic sensor. It is
  * wrapped in a poller class which will now handle the returned values and the
  * polling of that sensor
  * <p>
+ * 
  * @author danielle, Riley
  */
 public class UltrasonicPoller implements TimerListener {
-	private UltrasonicSensor[] us =  new UltrasonicSensor[3];
+	private UltrasonicSensor[] us = new UltrasonicSensor[3];
 	public int pollRate;
 	private Timer poller;
 	private int readings[][];
@@ -25,11 +27,11 @@ public class UltrasonicPoller implements TimerListener {
 	private int counter;
 	private long previousTime;
 	private long deltaTime;
-	
+
 	private Thread leftUS;
 	private Thread centerUS;
 	private Thread rightUS;
-	
+
 	// TODO figure out what exactly this constructor should be.
 	public UltrasonicPoller() {
 		us[left] = Settings.leftUltrasonic;
@@ -38,54 +40,50 @@ public class UltrasonicPoller implements TimerListener {
 
 		this.pollRate = 10;
 		this.readings = new int[3][5];
-		
+
 		us[left].off();
 		us[center].off();
 		us[right].off();
-		
+
 		this.leftUS = new Thread(new LeftUS());
 		this.centerUS = new Thread(new CenterUS());
 		this.rightUS = new Thread(new RightUS());
-		
+
 		this.start();
 	}
 
 	/**
-	 * Pings all three ultrasonic sensors and gets their values. Puts them into the readings array
+	 * Pings all three ultrasonic sensors and gets their values. Puts them into
+	 * the readings array
 	 */
 	@Override
 	public void timedOut() {
 		leftUS.run();
 		centerUS.run();
 		rightUS.run();
-//		counter++;
-		
-//		if(counter == 5) {
-//			LCD.drawString("                          ", 0, 6);
-//			LCD.drawInt((int) getUSReading(center), 0, 6);
-//			deltaTime = 0;
-//		}
-		
-		//keep the counter between 0 - 2
-//		counter = counter % 5;
-		
-		
-		/*if(counter == left) {
-			//pingUS(left);
-		} else if(counter == center) {
-			pingUS(center);
-		} else {
-			//pingUS(right);
-		}
-		
-		counter++;
-		//keep the counter between 0 - 2
-		counter = counter % 3;*/
+		// counter++;
+
+		// if(counter == 5) {
+		// LCD.drawString("                          ", 0, 6);
+		// LCD.drawInt((int) getUSReading(center), 0, 6);
+		// deltaTime = 0;
+		// }
 
-		//RConsole.println(String.valueOf(System.currentTimeMillis() - currentTime));
+		// keep the counter between 0 - 2
+		// counter = counter % 5;
+
+		/*
+		 * if(counter == left) { //pingUS(left); } else if(counter == center) {
+		 * pingUS(center); } else { //pingUS(right); }
+		 * 
+		 * counter++; //keep the counter between 0 - 2 counter = counter % 3;
+		 */
+
+		// RConsole.println(String.valueOf(System.currentTimeMillis() -
+		// currentTime));
 	}
-	
-	//For debugging purposes. 
+
+	// For debugging purposes.
 	private String toStringLastValues() {
 		String out = "";
 		out += " L: " + getUSReading(left);
@@ -100,37 +98,41 @@ public class UltrasonicPoller implements TimerListener {
 	 */
 	public void start() {
 		counter = 0;
-		
-		//for filtering purposes
+
+		// for filtering purposes
 		this.resetUSP();
 		this.poller = new Timer(pollRate, this);
 		this.poller.start();
 		running = true;
 		this.previousTime = System.currentTimeMillis();
 	}
-	
+
 	/**
-	 * Resets the ultrasonic sensor values to the default -1 values. The ultrasonic sensor will never return negative values during normal operation.
+	 * Resets the ultrasonic sensor values to the default -1 values. The
+	 * ultrasonic sensor will never return negative values during normal
+	 * operation.
 	 */
 	public void resetUSP() {
 		int i = 0;
-		for(int[] sensor : readings) {
+		for (int[] sensor : readings) {
 			int j = 0;
-			for(int reading : sensor) {
+			for (int reading : sensor) {
 				readings[i][j] = -1;
 				++j;
 			}
 			++i;
-		}		
+		}
 	}
-	
+
 	/**
-	 * Checks if the ultrasonic sensor has collected atleast 5 values. It does this by checking for any negative numbers in the readings. 
+	 * Checks if the ultrasonic sensor has collected atleast 5 values. It does
+	 * this by checking for any negative numbers in the readings.
 	 */
 	public boolean isSetup() {
-		for(int[] sensor : readings) {
-			for(int reading : sensor) {
-				if(reading < 0) return false;
+		for (int[] sensor : readings) {
+			for (int reading : sensor) {
+				if (reading < 0)
+					return false;
 			}
 		}
 		return true;
@@ -144,46 +146,49 @@ public class UltrasonicPoller implements TimerListener {
 		this.poller = null;
 		running = false;
 	}
-	
+
 	/**
 	 * Returns the filtered data for the sensor (median filtering)
+	 * 
 	 * @param sensor
 	 * @return
 	 */
 	public int getUSReading(int sensor) {
-		
-		// makes sure readings array is full of values so we have enough to filter with
-		if(readings[2][4] > -1) {
-			
-			//initialize vars
+
+		// makes sure readings array is full of values so we have enough to
+		// filter with
+		if (readings[2][4] > -1) {
+
+			// initialize vars
 			int size = 5;
 			int[] usReadingsSorted = new int[5];
-			//Copy array
+			// Copy array
 			System.arraycopy(readings[sensor], 0, usReadingsSorted, 0, 5);
 
-			//sort the values: lowest to highest
-			for(int i=0; i<size; i++) {
-				for(int j=i+1; j<size;j++) {
-					if(usReadingsSorted[i] > usReadingsSorted[j]) {
+			// sort the values: lowest to highest
+			for (int i = 0; i < size; i++) {
+				for (int j = i + 1; j < size; j++) {
+					if (usReadingsSorted[i] > usReadingsSorted[j]) {
 						int temp = usReadingsSorted[i];
 						usReadingsSorted[i] = usReadingsSorted[j];
-						usReadingsSorted[j] = temp;					
+						usReadingsSorted[j] = temp;
 					}
 				}
 			}
-			
-			//return the median
-			return usReadingsSorted[2];			
-			
+
+			// return the median
+			return usReadingsSorted[2];
+
 		} else {
 			return readings[sensor][0];
 		}
 	}
-	
+
 	/**
 	 * gets the lowest reading in the ultrasonicPoller at that time. Readings
 	 * are not taken temporarily as they are not needed;
 	 * <p>
+	 * 
 	 * @return The smallest reading of the last 5 polls.
 	 */
 	public int getLowestReading() {
@@ -195,14 +200,14 @@ public class UltrasonicPoller implements TimerListener {
 		}
 
 		// calculate median value by sorting the readings
-		int minValue = readings[0][0]; //get a value to start
+		int minValue = readings[0][0]; // get a value to start
 		for (int usReadings[] : readings) {
 			int i = 0;
-			for(int reading : usReadings) {
-				if(minValue > reading)
+			for (int reading : usReadings) {
+				if (minValue > reading)
 					minValue = reading;
 				++i;
-				}
+			}
 		}
 
 		// start the readings again if the robot was taking readings before.
@@ -211,26 +216,29 @@ public class UltrasonicPoller implements TimerListener {
 		return minValue;
 
 	}
-	
+
 	/**
 	 * Pings ultrasonic sensor and records the result in readings
 	 */
 	private void pingUS(int sensor) {
 		int distance;
-		
+
 		// do a ping
 		us[sensor].ping();
-		
+
 		// wait for the ping to complete
-		try { Thread.sleep(20); } catch (InterruptedException e) {}
-		
+		try {
+			Thread.sleep(20);
+		} catch (InterruptedException e) {
+		}
+
 		// there will be a delay here
 		distance = us[sensor].getDistance();
-		
+
 		addReading(sensor, distance);
 	}
 
-	//helper method. 
+	// helper method.
 	private void addReading(int sensor, int reading) {
 		readings[sensor][4] = readings[sensor][3];
 		readings[sensor][3] = readings[sensor][2];
@@ -238,28 +246,28 @@ public class UltrasonicPoller implements TimerListener {
 		readings[sensor][1] = readings[sensor][0];
 		readings[sensor][0] = reading;
 	}
-	
+
 	public class LeftUS implements Runnable {
 
 		@Override
 		public void run() {
-			pingUS(left);			
+			pingUS(left);
 		}
 	}
-	
+
 	public class RightUS implements Runnable {
 
 		@Override
 		public void run() {
-			pingUS(right);	
+			pingUS(right);
 		}
 	}
-	
+
 	public class CenterUS implements Runnable {
 
 		@Override
 		public void run() {
-			pingUS(center);	
+			pingUS(center);
 		}
 	}
 }

commit 3e5922239188f0046bb685a946620088408bdf61
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Thu Nov 14 21:05:38 2013 -0500

    Wrote useful method in ultrasonicPoller that will reset and check the
    status of the USP.

diff --git a/src/hardwareAbstraction/UltrasonicPoller.java b/src/hardwareAbstraction/UltrasonicPoller.java
index 26cd0a0..10d2e79 100644
--- a/src/hardwareAbstraction/UltrasonicPoller.java
+++ b/src/hardwareAbstraction/UltrasonicPoller.java
@@ -109,6 +109,9 @@ public class UltrasonicPoller implements TimerListener {
 		this.previousTime = System.currentTimeMillis();
 	}
 	
+	/**
+	 * Resets the ultrasonic sensor values to the default -1 values. The ultrasonic sensor will never return negative values during normal operation.
+	 */
 	public void resetUSP() {
 		int i = 0;
 		for(int[] sensor : readings) {
@@ -118,8 +121,19 @@ public class UltrasonicPoller implements TimerListener {
 				++j;
 			}
 			++i;
+		}		
+	}
+	
+	/**
+	 * Checks if the ultrasonic sensor has collected atleast 5 values. It does this by checking for any negative numbers in the readings. 
+	 */
+	public boolean isSetup() {
+		for(int[] sensor : readings) {
+			for(int reading : sensor) {
+				if(reading < 0) return false;
+			}
 		}
-			
+		return true;
 	}
 
 	/**

commit 01fdd0dedc223159c29896fa39f7a397bc867fb5
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Thu Nov 14 21:00:06 2013 -0500

    Modified forklift so the commands issued by other classes will always
    work, regardless of the state of the forklift. Avoids errors later on.

diff --git a/src/hardwareAbstraction/Forklift.java b/src/hardwareAbstraction/Forklift.java
index 3e6383e..1be62ea 100644
--- a/src/hardwareAbstraction/Forklift.java
+++ b/src/hardwareAbstraction/Forklift.java
@@ -9,21 +9,26 @@ public class Forklift {
 	static int liftHeight = -15; // 15 cm upwards. Should be ok
 	static int scanHeight = -10; // 10 cm upwards. Needs to be tested. 
 	private static double radius = 1; //radius of "spool". Must be tested. 
-	public static boolean atScanHeight = false;
-	public static boolean atLiftHeight = false;
-	
+	private static ForkliftState state = ForkliftState.GROUND; //sensor starts on the ground.
 	/**
 	 * This method lifts an object. Returns nothing.
 	 * @bug the execution of external motors causes exceptions. Try-catch block was put for now. Must be fixed. 
 	 */
 	public static void liftObject() {
 		RConsole.println("lifting object");
-		atLiftHeight = true;
+		// reset the forklift to ground state.
+		if (state == ForkliftState.SCAN_HEIGHT) {
+			resetScanHeight();
+		}
+		if (state == ForkliftState.LIFT_HEIGHT) {
+			lowerObject();
+		}
+		state = ForkliftState.LIFT_HEIGHT;
 		try {
 			lift.setSpeed(100);
 			lift.rotate(convertDistanceToAngle(liftHeight));
-		} catch (ArrayIndexOutOfBoundsException e){
-		
+		} catch (ArrayIndexOutOfBoundsException e) {
+
 		}
 	}
 	
@@ -32,14 +37,16 @@ public class Forklift {
 	 * @bug the execution of external motors causes exceptions. Try-catch block was put for now. Must be fixed. 
 	 */
 	public static void lowerObject() {
-		RConsole.println("lowering object");
-		atLiftHeight = false;
+		RConsole.println("lowering to default position");
+		if (state == ForkliftState.SCAN_HEIGHT)
+			resetScanHeight();
+		if (state == ForkliftState.GROUND)
+			return;
+		state = ForkliftState.GROUND;
 		try {
 			lift.setSpeed(100);
 			lift.rotate(-convertDistanceToAngle(liftHeight));
-		} catch (ArrayIndexOutOfBoundsException e){
-		
-		}
+		} catch (ArrayIndexOutOfBoundsException e){ }
 	}
 	
 	/**
@@ -48,7 +55,11 @@ public class Forklift {
 	 */
 	public static void setScanHeight() {
 		RConsole.println("lifting to scan height");
-		atScanHeight = true;
+		if (state == ForkliftState.LIFT_HEIGHT)
+			lowerObject();
+		if (state == ForkliftState.SCAN_HEIGHT)
+			return;
+		state = ForkliftState.SCAN_HEIGHT;
 		try {
 			lift.setSpeed(100);
 			lift.rotate(convertDistanceToAngle(scanHeight));
@@ -63,7 +74,11 @@ public class Forklift {
 	 */
 	public static void resetScanHeight() {
 		RConsole.println("lowering to default height");
-		atLiftHeight = false;
+		if (state == ForkliftState.LIFT_HEIGHT)
+			lowerObject();
+		if (state == ForkliftState.GROUND)
+			return;
+		state = ForkliftState.GROUND;
 		try {
 			lift.setSpeed(100);
 			lift.rotate(-convertDistanceToAngle(scanHeight));
@@ -71,8 +86,6 @@ public class Forklift {
 		
 		}
 	}
-	
-	
 
 	/**
 	 * This method turns a distance into an angle for the robot to turn. Takes as parameter the distance you want to lift. 
@@ -84,4 +97,8 @@ public class Forklift {
 	private static int convertDistanceToAngle(int distance) {
 		return (int)( (distance * 360) / (2 * Math.PI * radius) );
 	}
+	
+	public enum ForkliftState {
+		GROUND, SCAN_HEIGHT, LIFT_HEIGHT;
+	}
 }

commit 94ec2b4fa63a4f3f6f49efff9aa94e3448536b94
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Thu Nov 14 20:22:45 2013 -0500

    The forklift will now be used to detect obstacles and blue blocks. The
    method to do this is that it will go to a default height and detect the
    objects in the range and compare that with the values at its default
    height. The difference of these two will uniquely identify the obstacle.
    This has all been documented elsewhere. The work done sofar on this
    forklift is minimal just to allow this to happen. Also boolean
    identifiers of the forklift current state was added for convenience.

diff --git a/src/hardwareAbstraction/Forklift.java b/src/hardwareAbstraction/Forklift.java
index 91c83a6..3e6383e 100644
--- a/src/hardwareAbstraction/Forklift.java
+++ b/src/hardwareAbstraction/Forklift.java
@@ -6,8 +6,11 @@ import utilities.Settings;
 
 public class Forklift {
 	static RemoteMotor lift = Settings.forkliftMotor;
-	static int distance = -15; // 15 cm upwards. needs to be tested. 
+	static int liftHeight = -15; // 15 cm upwards. Should be ok
+	static int scanHeight = -10; // 10 cm upwards. Needs to be tested. 
 	private static double radius = 1; //radius of "spool". Must be tested. 
+	public static boolean atScanHeight = false;
+	public static boolean atLiftHeight = false;
 	
 	/**
 	 * This method lifts an object. Returns nothing.
@@ -15,9 +18,10 @@ public class Forklift {
 	 */
 	public static void liftObject() {
 		RConsole.println("lifting object");
+		atLiftHeight = true;
 		try {
 			lift.setSpeed(100);
-			lift.rotate(convertDistanceToAngle(distance));
+			lift.rotate(convertDistanceToAngle(liftHeight));
 		} catch (ArrayIndexOutOfBoundsException e){
 		
 		}
@@ -29,13 +33,46 @@ public class Forklift {
 	 */
 	public static void lowerObject() {
 		RConsole.println("lowering object");
+		atLiftHeight = false;
 		try {
 			lift.setSpeed(100);
-			lift.rotate(-convertDistanceToAngle(distance));
+			lift.rotate(-convertDistanceToAngle(liftHeight));
 		} catch (ArrayIndexOutOfBoundsException e){
 		
 		}
 	}
+	
+	/**
+	 * This method will raise the forklift to allow the color sensor to identify the block. 
+	 * @bug the execution of external motors causes exceptions. Try-catch block was put for now. Must be fixed.
+	 */
+	public static void setScanHeight() {
+		RConsole.println("lifting to scan height");
+		atScanHeight = true;
+		try {
+			lift.setSpeed(100);
+			lift.rotate(convertDistanceToAngle(scanHeight));
+		} catch (ArrayIndexOutOfBoundsException e){
+		
+		}
+	}
+	
+	/**
+	 * This method will lower the forklift after identifying the block. 
+	 * @bug the execution of external motors causes exceptions. Try-catch block was put for now. Must be fixed.
+	 */
+	public static void resetScanHeight() {
+		RConsole.println("lowering to default height");
+		atLiftHeight = false;
+		try {
+			lift.setSpeed(100);
+			lift.rotate(-convertDistanceToAngle(scanHeight));
+		} catch (ArrayIndexOutOfBoundsException e){
+		
+		}
+	}
+	
+	
 
 	/**
 	 * This method turns a distance into an angle for the robot to turn. Takes as parameter the distance you want to lift. 

commit bc18f99aa430374c78961962f40e4b31b5201aa1
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Thu Nov 14 20:20:09 2013 -0500

    Began working on a search algorithm. Added a useful method in
    ultrasonicPoller for the moment. The Navigation class was modified to
    accomodate the Recogintion step.

diff --git a/src/controllers/Recognize.java b/src/controllers/Recognize.java
index 99e1bcd..b46c118 100644
--- a/src/controllers/Recognize.java
+++ b/src/controllers/Recognize.java
@@ -1,15 +1,40 @@
 package controllers;
 
+import hardwareAbstraction.Forklift;
 import manager.Manager;
 
 public class Recognize extends Controller {
 
 private Manager manager;
+private boolean isSetup;
 	
 	public Recognize(Manager manager) {
 		this.manager = manager;
+		this.isSetup = false;
 	}
 	
 	public void run() {
+		if (!isSetup) {
+			// if not at scan height, set it to that
+			if(Forklift.atLiftHeight) {
+				manager.cm.setState(State.PAUSE);
+				Forklift.lowerObject();
+				manager.cm.setState(State.RECOGNIZE);
+			}
+			if (!Forklift.atScanHeight) {
+				manager.cm.setState(State.PAUSE);
+				Forklift.setScanHeight();
+				manager.cm.setState(State.RECOGNIZE);
+			}
+			//TODO figure out if we still need the colorPoller or not. 
+			// start the color poller 
+			manager.hm.colorPoller.start();
+		}
+		//if the color poller has finally collected enough values. 
+		if(manager.hm.colorPoller.isSetup()) {
+			// TODO we might not even need this code anymore!!!!!!!
+		}
+		
+		
 	}
 }
diff --git a/src/hardwareAbstraction/UltrasonicPoller.java b/src/hardwareAbstraction/UltrasonicPoller.java
index 2d5fb17..26cd0a0 100644
--- a/src/hardwareAbstraction/UltrasonicPoller.java
+++ b/src/hardwareAbstraction/UltrasonicPoller.java
@@ -85,6 +85,7 @@ public class UltrasonicPoller implements TimerListener {
 		//RConsole.println(String.valueOf(System.currentTimeMillis() - currentTime));
 	}
 	
+	//For debugging purposes. 
 	private String toStringLastValues() {
 		String out = "";
 		out += " L: " + getUSReading(left);
@@ -101,17 +102,24 @@ public class UltrasonicPoller implements TimerListener {
 		counter = 0;
 		
 		//for filtering purposes
-		readings[2][4] = -1;
-		readings[2][3] = -1;
-		readings[2][2] = -1;
-		readings[2][1] = -1;
-		readings[2][0] = -1;
+		this.resetUSP();
 		this.poller = new Timer(pollRate, this);
 		this.poller.start();
 		running = true;
 		this.previousTime = System.currentTimeMillis();
-		
-		RConsole.println(String.valueOf(poller.getDelay()));
+	}
+	
+	public void resetUSP() {
+		int i = 0;
+		for(int[] sensor : readings) {
+			int j = 0;
+			for(int reading : sensor) {
+				readings[i][j] = -1;
+				++j;
+			}
+			++i;
+		}
+			
 	}
 
 	/**
diff --git a/src/services/Navigation.java b/src/services/Navigation.java
index 43a798f..05da355 100644
--- a/src/services/Navigation.java
+++ b/src/services/Navigation.java
@@ -71,12 +71,12 @@ public class Navigation implements TimerListener {
 					RConsole.println(""+Math.abs(dX)+" "+Math.abs(dY));
 					//scan ahead only once facing the correct orientation, then travelTo that destination.
 					//TODO comment back this code. Problematic code for the moment. 
-//					if (!scannedAhead) {
-//						manager.hm.drive.stop();
-//						this.pause();
-//						manager.sm.obstacleAvoidance.scanAhead();
-//						this.start();
-//					}
+					if (!scannedAhead) {
+						manager.hm.drive.stop();
+						this.pause();
+						manager.cm.setState(State.RECOGNIZE);
+						this.start();
+					}
 					travelTo();
 				} else {
 					//stop the motors, reset scanning state and get next destination. 

commit af45e56805cf4653977bd560b9a396277a08232e
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Thu Nov 14 20:17:36 2013 -0500

    Began an implementation of a scanning feature for the robot. The robot
    side ultrasonic sensors should be able to move back and forward now.

diff --git a/src/hardwareAbstraction/UltrasonicMotor.java b/src/hardwareAbstraction/UltrasonicMotor.java
index 261af7e..37d5845 100644
--- a/src/hardwareAbstraction/UltrasonicMotor.java
+++ b/src/hardwareAbstraction/UltrasonicMotor.java
@@ -1,5 +1,26 @@
 package hardwareAbstraction;
 
+import utilities.Settings;
+
 public class UltrasonicMotor {
+	/**
+	 * The default position is set to be with the two side ultrasonic sensors
+	 * pointing away from the center of the robot. Therefore, it will be at an
+	 * angle when viewed from the front of the robot.
+	 */
+	public static void setDefaultPosition() {
+		Settings.ultrasonicMotor.setSpeed(200);
+		Settings.ultrasonicMotor.rotate(45);
+	}
+	
+	/**
+	 * The forward position is set to be with the two side ultrasonic sensors
+	 * pointing directly ahead, in line with the centre ultrasonic sensor. Therefore, it will be at an
+	 * angle when viewed from the front of the robot.
+	 */
+	public static void setForwardPosition() {
+		Settings.ultrasonicMotor.setSpeed(200);
+		Settings.ultrasonicMotor.rotate(-45);
+	}
 
 }

commit a5a8492f9ed48672ff5accdad528a8b61e45fded
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Thu Nov 14 20:16:14 2013 -0500

    Created a default path for the robot to navigate around in its search
    algorithm. Its a very primitive search algorithm.

diff --git a/src/controllers/Search.java b/src/controllers/Search.java
index c822add..b53fc91 100644
--- a/src/controllers/Search.java
+++ b/src/controllers/Search.java
@@ -14,7 +14,9 @@ public class Search extends Controller  {
 	}
 	
 	public void run() {
+		
 		defaultRouter();
+		
 	}
 	/**
 	 * This method will check the route in navigation and add a coordinate in the route. Allows the Navigation to always have "something to do" when nothing interesting is found

commit d335dd38db14aa73bac1ce7ea264c87a86209c86
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Thu Nov 14 20:15:27 2013 -0500

    Started the implementation of a colorPoller detector system. May be used
    or may be discarded.

diff --git a/src/hardwareAbstraction/ColorPoller.java b/src/hardwareAbstraction/ColorPoller.java
index 5d4faaa..7d8fe03 100644
--- a/src/hardwareAbstraction/ColorPoller.java
+++ b/src/hardwareAbstraction/ColorPoller.java
@@ -6,6 +6,15 @@ import lejos.robotics.Color;
 import lejos.util.Timer;
 import lejos.util.TimerListener;
 
+/**
+ * This class is the hardware abstraction for the ColorSensor with additonal
+ * functionality built in. The colorPoller will never have values below 0 during
+ * normal operation. Therefore, negative numbers mean the colorPoller has not
+ * been setup.
+ * 
+ * @author danielle
+ * 
+ */
 public class ColorPoller implements TimerListener {
 	private ColorSensor cs;
 	private Timer poller;
@@ -15,13 +24,15 @@ public class ColorPoller implements TimerListener {
 	public ColorPoller() {
 		this.cs = Settings.frontColorSensor;
 		this.readings = new int[5];
+		this.resetCP();
 	}
-	
+
 	public void start() {
 		this.poller = new Timer(poleRate, this);
+		this.resetCP();
 		this.poller.start();
 	}
-	
+
 	public void stop() {
 		this.poller.stop();
 		this.poller = null;
@@ -33,11 +44,11 @@ public class ColorPoller implements TimerListener {
 		Color color = cs.getColor();
 		red = color.getRed();
 		blue = color.getBlue();
-		double proportion = (double)red/blue;
+		double proportion = (double) red / blue;
 		proportion *= 100;
 		addReading((int) proportion);
 	}
-	
+
 	private void addReading(int shiftedProportion) {
 		readings[4] = readings[3];
 		readings[3] = readings[2];
@@ -45,4 +56,27 @@ public class ColorPoller implements TimerListener {
 		readings[1] = readings[0];
 		readings[0] = shiftedProportion;
 	}
+
+	/**
+	 * This method resets the color poller to a default value which is -1
+	 * everywhere. The colorPoller will never have values below 0 during normal
+	 * operation. Therefore, negative numbers mean the colorPoller has not been
+	 * setup.
+	 */
+	private void resetCP() {
+		for (int i = 0; i < readings.length; ++i)
+			readings[i] = -1;
+	}
+
+	/**
+	 * This method will identify whether the colorPoller has been setup or not. 
+	 * @return	True if the colorPoller is setup, else false.
+	 */
+	public boolean isSetup() {
+		if (readings[4] < 0)
+			return false;
+		else
+			return true;
+
+	}
 }
\ No newline at end of file

commit c3ec89a3079843ce1a9ce755adfcec018c86a059
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Thu Nov 14 18:55:39 2013 -0500

    Added some default ocations to head toduring dropoff. Small corrections
    made to all the other classes. Test..

diff --git a/src/controllers/DropOff.java b/src/controllers/DropOff.java
index d00bea1..b38a0cb 100644
--- a/src/controllers/DropOff.java
+++ b/src/controllers/DropOff.java
@@ -31,7 +31,6 @@ private Stack<Point> route;
 	 */
 	public void run() {
 		//upon initialization,
-		RConsole.println("drop_off");
 		if(!initialized) {
 			manager.cm.setState(State.DROP_OFF);
 			
@@ -48,7 +47,7 @@ private Stack<Point> route;
 			 */
 			
 			// when the robot gets to the greenZone, 
-			if(manager.sm.nav.getRoute().peek() == null) {
+			if(manager.sm.nav.getRoute().empty()) {
 				//drop off the block
 				Forklift.lowerObject();
 				Claw.releaseObject();
diff --git a/src/controllers/Search.java b/src/controllers/Search.java
index cc2c2e3..c822add 100644
--- a/src/controllers/Search.java
+++ b/src/controllers/Search.java
@@ -20,7 +20,7 @@ public class Search extends Controller  {
 	 * This method will check the route in navigation and add a coordinate in the route. Allows the Navigation to always have "something to do" when nothing interesting is found
 	 */
 	private void defaultRouter() {
-		if(manager.sm.nav.getRoute().peek() == null) {
+		if(manager.sm.nav.getRoute().empty()) {
 			switch(this.defaultPath) {
 			case 0 : manager.sm.nav.addToRoute(new Point(180,0));
 			break;
diff --git a/src/hardwareAbstraction/UltrasonicPoller.java b/src/hardwareAbstraction/UltrasonicPoller.java
index 35f64b7..2d5fb17 100644
--- a/src/hardwareAbstraction/UltrasonicPoller.java
+++ b/src/hardwareAbstraction/UltrasonicPoller.java
@@ -58,9 +58,6 @@ public class UltrasonicPoller implements TimerListener {
 		leftUS.run();
 		centerUS.run();
 		rightUS.run();
-		
-		RConsole.println(toStringLastValues());
-		
 //		counter++;
 		
 //		if(counter == 5) {
diff --git a/src/launcher/Launcher.java b/src/launcher/Launcher.java
index b8edd7b..7ff120f 100644
--- a/src/launcher/Launcher.java
+++ b/src/launcher/Launcher.java
@@ -31,11 +31,11 @@ public class Launcher {
 		Button.waitForPress();
 		
 		Manager manager = new Manager();
-		manager.sm.localization.start();
-		
-		while(manager.cm.getState() == State.LOCALIZING) {
-			manager.um.nap(150);
-		}
+//		manager.sm.localization.start();
+//		
+//		while(manager.cm.getState() == State.LOCALIZING) {
+//			manager.um.nap(150);
+//		}
 		
 		manager.cm.setState(State.SEARCH);
 		
diff --git a/src/services/Navigation.java b/src/services/Navigation.java
index e48395c..43a798f 100644
--- a/src/services/Navigation.java
+++ b/src/services/Navigation.java
@@ -50,8 +50,6 @@ public class Navigation implements TimerListener {
 
 	@Override
 	public void timedOut() {
-		RConsole.println("Navigation timedOut");
-		RConsole.println(manager.cm.getState().name());
 		if (manager.cm.getState() == State.SEARCH || manager.cm.getState() == State.DROP_OFF) {
 		
 			if (route.empty()) {

commit 7b3cf99a3461d55088dc2093f3a69e2272347cb2
Merge: 6c29f0a 361f8f7
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Thu Nov 14 17:38:29 2013 -0500

    Merge branch 'master' of https://github.com/danielle-mustillo/ECSE-211-Team-5.git

commit 6c29f0a1f8cd391ef0f3d0644ba3b0a5204e2436
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Thu Nov 14 17:38:16 2013 -0500

    Made some forklift and ultrasonic changes

diff --git a/src/controllers/Search.java b/src/controllers/Search.java
index e528253..cc2c2e3 100644
--- a/src/controllers/Search.java
+++ b/src/controllers/Search.java
@@ -1,16 +1,48 @@
 package controllers;
 
+import utilities.Point;
 import manager.Manager;
 
 public class Search extends Controller  {
 
 	private Manager manager;
+	private int defaultPath;
 	
 	public Search(Manager manager) {
+		this.defaultPath = 0;
 		this.manager = manager;
 	}
 	
 	public void run() {
+		defaultRouter();
 	}
-
+	/**
+	 * This method will check the route in navigation and add a coordinate in the route. Allows the Navigation to always have "something to do" when nothing interesting is found
+	 */
+	private void defaultRouter() {
+		if(manager.sm.nav.getRoute().peek() == null) {
+			switch(this.defaultPath) {
+			case 0 : manager.sm.nav.addToRoute(new Point(180,0));
+			break;
+			case 1 : manager.sm.nav.addToRoute(new Point(180,60));
+			break;
+			case 2 : manager.sm.nav.addToRoute(new Point(00,60));
+			break;
+			//wont run on the crack
+			case 3 : manager.sm.nav.addToRoute(new Point(00,120)); 
+			break;
+			case 4 : manager.sm.nav.addToRoute(new Point(180,120));
+			break;
+			case 5 : manager.sm.nav.addToRoute(new Point(180,180));
+			break;
+			case 6 : manager.sm.nav.addToRoute(new Point(00,180));
+			break;
+			case 7 : manager.sm.nav.addToRoute(new Point(00,00));
+			break;
+			}
+			this.defaultPath += 1;
+			this.defaultPath %= 8;
+		}
+	}
+	
 }
diff --git a/src/hardwareAbstraction/Claw.java b/src/hardwareAbstraction/Claw.java
index 6fb56fe..030d2d0 100644
--- a/src/hardwareAbstraction/Claw.java
+++ b/src/hardwareAbstraction/Claw.java
@@ -15,6 +15,7 @@ public class Claw {
 	public static void grabObject() {
 		RConsole.println("grabbing object");
 		try {
+			claw.setSpeed(150);
 			claw.rotate(value);
 		} catch (ArrayIndexOutOfBoundsException e){
 			
@@ -28,6 +29,7 @@ public class Claw {
 	public static void releaseObject() {
 		RConsole.println("releasing object");
 		try {
+			claw.setSpeed(150);
 			claw.rotate(-value);
 		} catch (ArrayIndexOutOfBoundsException e){
 			
diff --git a/src/hardwareAbstraction/Forklift.java b/src/hardwareAbstraction/Forklift.java
index 2f33def..91c83a6 100644
--- a/src/hardwareAbstraction/Forklift.java
+++ b/src/hardwareAbstraction/Forklift.java
@@ -6,7 +6,7 @@ import utilities.Settings;
 
 public class Forklift {
 	static RemoteMotor lift = Settings.forkliftMotor;
-	static int distance = -45; // 45 cm upwards. needs to be tested. 
+	static int distance = -15; // 15 cm upwards. needs to be tested. 
 	private static double radius = 1; //radius of "spool". Must be tested. 
 	
 	/**
@@ -16,6 +16,7 @@ public class Forklift {
 	public static void liftObject() {
 		RConsole.println("lifting object");
 		try {
+			lift.setSpeed(100);
 			lift.rotate(convertDistanceToAngle(distance));
 		} catch (ArrayIndexOutOfBoundsException e){
 		
@@ -29,6 +30,7 @@ public class Forklift {
 	public static void lowerObject() {
 		RConsole.println("lowering object");
 		try {
+			lift.setSpeed(100);
 			lift.rotate(-convertDistanceToAngle(distance));
 		} catch (ArrayIndexOutOfBoundsException e){
 		
diff --git a/src/hardwareAbstraction/UltrasonicPoller.java b/src/hardwareAbstraction/UltrasonicPoller.java
index ed78e64..35f64b7 100644
--- a/src/hardwareAbstraction/UltrasonicPoller.java
+++ b/src/hardwareAbstraction/UltrasonicPoller.java
@@ -50,7 +50,8 @@ public class UltrasonicPoller implements TimerListener {
 		this.start();
 	}
 
-	/**Pings all three ultrasonic sensors and gets their values. Puts them into the readings array
+	/**
+	 * Pings all three ultrasonic sensors and gets their values. Puts them into the readings array
 	 */
 	@Override
 	public void timedOut() {

commit 361f8f75bf65d2cab45677f29902c5b049f726b7
Author: RileyvanRyswyk <rileyvan@gmail.com>
Date:   Thu Nov 14 17:37:39 2013 -0500

    Line Poller Update

diff --git a/src/hardwareAbstraction/LinePoller.java b/src/hardwareAbstraction/LinePoller.java
index ca2623c..156a0f1 100644
--- a/src/hardwareAbstraction/LinePoller.java
+++ b/src/hardwareAbstraction/LinePoller.java
@@ -2,6 +2,7 @@ package hardwareAbstraction;
 
 import lejos.nxt.ColorSensor;
 import lejos.nxt.Sound;
+import lejos.nxt.comm.RConsole;
 import lejos.util.Timer;
 import lejos.util.TimerListener;
 import utilities.Settings;
@@ -32,8 +33,8 @@ public class LinePoller implements TimerListener {
 		sensorOnLine = new boolean[]{false, false};
 		sensorEnteringLine = new boolean[]{false, false};
 		timer = new Timer(UPDATE_PERIOD, this);
-		sensor[right].setFloodlight(0);
-		sensor[left].setFloodlight(0);
+		setFloodlight(left, 0);
+		setFloodlight(right, 0);
 	}
 	
 	/**
@@ -60,6 +61,8 @@ public class LinePoller implements TimerListener {
 		detectLine(right);
 		detectLine(left);
 		
+		RConsole.println("Left " + String.valueOf(readings[left][0]));
+		RConsole.println("Right " + String.valueOf(readings[right][0]));
 	}
 	
 	private void addReading(int sensor, int reading) {
@@ -109,4 +112,23 @@ public class LinePoller implements TimerListener {
 		return false;
 	}
 	
+	public void setFloodlight(int sensor, int color) {
+		this.sensor[sensor].setFloodlight(color);
+		do {
+			RConsole.println("Setting Flood light");
+			nap(75);
+		} while(this.sensor[sensor].getRawLightValue() == -1);
+	}
+	
+	/** Helper method to avoid large try/catch blocks. Sleeps the current thread. 
+	 * @param time int value which represents the sleep time
+	 */
+	public void nap(int time) {
+		try {
+			Thread.sleep(time);
+		} catch (InterruptedException e) {
+			e.printStackTrace();
+		}
+	}
+	
 }

commit 359586f154e3b41bc85c48ceada65a0b396ab06c
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Thu Nov 14 17:06:47 2013 -0500

    Made a multi-threaded implementation of USPoller. Needs to be threaded
    though.

diff --git a/src/hardwareAbstraction/UltrasonicPoller.java b/src/hardwareAbstraction/UltrasonicPoller.java
index d6120bb..ed78e64 100644
--- a/src/hardwareAbstraction/UltrasonicPoller.java
+++ b/src/hardwareAbstraction/UltrasonicPoller.java
@@ -25,7 +25,11 @@ public class UltrasonicPoller implements TimerListener {
 	private int counter;
 	private long previousTime;
 	private long deltaTime;
-
+	
+	private Thread leftUS;
+	private Thread centerUS;
+	private Thread rightUS;
+	
 	// TODO figure out what exactly this constructor should be.
 	public UltrasonicPoller() {
 		us[left] = Settings.leftUltrasonic;
@@ -35,35 +39,37 @@ public class UltrasonicPoller implements TimerListener {
 		this.pollRate = 10;
 		this.readings = new int[3][5];
 		
-		//us[left].off();
+		us[left].off();
 		us[center].off();
-		//us[right].off();
+		us[right].off();
 		
-		start();
+		this.leftUS = new Thread(new LeftUS());
+		this.centerUS = new Thread(new CenterUS());
+		this.rightUS = new Thread(new RightUS());
+		
+		this.start();
 	}
 
 	/**Pings all three ultrasonic sensors and gets their values. Puts them into the readings array
 	 */
 	@Override
 	public void timedOut() {
+		leftUS.run();
+		centerUS.run();
+		rightUS.run();
 		
-		long currentTime = System.currentTimeMillis();
+		RConsole.println(toStringLastValues());
 		
-		deltaTime += currentTime - previousTime;
-		previousTime = currentTime;
-				
-		pingUS(center);
+//		counter++;
 		
-		counter++;
-		
-		if(counter == 5) {
-			LCD.drawString("                          ", 0, 6);
-			LCD.drawInt((int) getUSReading(center), 0, 6);
-			deltaTime = 0;
-		}
+//		if(counter == 5) {
+//			LCD.drawString("                          ", 0, 6);
+//			LCD.drawInt((int) getUSReading(center), 0, 6);
+//			deltaTime = 0;
+//		}
 		
 		//keep the counter between 0 - 2
-		counter = counter % 5;
+//		counter = counter % 5;
 		
 		
 		/*if(counter == left) {
@@ -80,6 +86,14 @@ public class UltrasonicPoller implements TimerListener {
 
 		//RConsole.println(String.valueOf(System.currentTimeMillis() - currentTime));
 	}
+	
+	private String toStringLastValues() {
+		String out = "";
+		out += " L: " + getUSReading(left);
+		out += " C: " + getUSReading(center);
+		out += " R: " + getUSReading(right);
+		return out;
+	}
 
 	/**
 	 * Starts this instance of the ultrasonic poller Stop must be called to stop
@@ -87,6 +101,7 @@ public class UltrasonicPoller implements TimerListener {
 	 */
 	public void start() {
 		counter = 0;
+		
 		//for filtering purposes
 		readings[2][4] = -1;
 		readings[2][3] = -1;
@@ -203,4 +218,28 @@ public class UltrasonicPoller implements TimerListener {
 		readings[sensor][1] = readings[sensor][0];
 		readings[sensor][0] = reading;
 	}
+	
+	public class LeftUS implements Runnable {
+
+		@Override
+		public void run() {
+			pingUS(left);			
+		}
+	}
+	
+	public class RightUS implements Runnable {
+
+		@Override
+		public void run() {
+			pingUS(right);	
+		}
+	}
+	
+	public class CenterUS implements Runnable {
+
+		@Override
+		public void run() {
+			pingUS(center);	
+		}
+	}
 }

commit 35b55ee360a2e4094f1859188631283d2364e6c4
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Thu Nov 14 03:36:16 2013 -0500

    Added some intelligence to Dropoff.java. Should fix the issue with
    Dropoff. The try-catch blocks in Collect were moved to the
    hardwareAbstraction package.

diff --git a/src/controllers/Collect.java b/src/controllers/Collect.java
index eb9e3aa..18f4653 100644
--- a/src/controllers/Collect.java
+++ b/src/controllers/Collect.java
@@ -23,19 +23,8 @@ private Manager manager;
 		manager.cm.setState(State.PAUSE);
 		
 		//grab and lift
-		RConsole.println("grabbing object");
-		try {
-			Claw.grabObject();
-		} catch (ArrayIndexOutOfBoundsException e){
-			
-		}
-		RConsole.println("lifting object");
-		
-		try {
-			Forklift.liftObject();
-		} catch (ArrayIndexOutOfBoundsException e){
-			
-		}
+		Claw.grabObject();
+		Forklift.liftObject();
 		
 		//update storage count and go to the required next step (searching or dropping off).
 		RConsole.println("storage");
diff --git a/src/controllers/DropOff.java b/src/controllers/DropOff.java
index b204488..d00bea1 100644
--- a/src/controllers/DropOff.java
+++ b/src/controllers/DropOff.java
@@ -1,9 +1,13 @@
 package controllers;
 
+import hardwareAbstraction.Claw;
+import hardwareAbstraction.Forklift;
+
 import java.util.Stack;
 
 import utilities.Point;
 import utilities.Settings;
+import lejos.nxt.comm.RConsole;
 import manager.Manager;
 
 /**
@@ -14,24 +18,45 @@ import manager.Manager;
 public class DropOff extends Controller {
 
 private Manager manager;
+private boolean initialized;
+private Stack<Point> route;
 	
 	public DropOff(Manager manager) {
 		this.manager = manager;
+		this.initialized = false;
 	}
 	
+	/** 
+	 * @bug this method throws exceptions, which must be found and eliminated. 
+	 */
 	public void run() {
-		//pause the re-execution
-		manager.cm.setState(State.PAUSE);
-		/*
-		//store the route. 
-		Stack<Point> route = this.manager.sm.nav.exportAndResetRoute();
-		
-		//go to the green zone
-		this.manager.sm.nav.addToRoute(new Point(Settings.greenZoneCoords[0]));
-		
-		//go back to previous state
-		this.manager.sm.nav.setRoute(route);
-		*/
-		this.manager.cm.setState(State.SEARCH);
+		//upon initialization,
+		RConsole.println("drop_off");
+		if(!initialized) {
+			manager.cm.setState(State.DROP_OFF);
+			
+			//store old route temporarily, make a new route for the moment. 
+			this.route = this.manager.sm.nav.getRoute();
+			this.manager.sm.nav.setRoute(new Stack<Point>());
+			
+			//go to the green zone
+			this.manager.sm.nav.addToRoute(new Point(Settings.greenZoneCoords[0]));
+		} 
+		else {
+			/*now the robot should attempt to head to greenZone. 
+			 * so nothing is done here, everything is done in background. 
+			 */
+			
+			// when the robot gets to the greenZone, 
+			if(manager.sm.nav.getRoute().peek() == null) {
+				//drop off the block
+				Forklift.lowerObject();
+				Claw.releaseObject();
+				
+				//go back to previous state
+				this.manager.sm.nav.setRoute(route);
+				this.manager.cm.setState(State.SEARCH);
+			}
+		}
 	}
 }
diff --git a/src/utilities/Settings.java b/src/utilities/Settings.java
index e4a10b7..81f56ee 100644
--- a/src/utilities/Settings.java
+++ b/src/utilities/Settings.java
@@ -30,7 +30,7 @@ public class Settings {
 	
 	public static int role;
 	public static Point[] redZoneCoords;
-	public static Point[] greenZoneCoords;
+	public static Point[] greenZoneCoords = {new Point(60, 60), null, null, null}; //TODO remove once BT is working.
 	public static StartingCorner startingCorner = StartingCorner.BOTTOM_LEFT;
 	
 	public static final double LS_OFFSET = 15.0;

commit e984d8dccec4055aebfb42e2476f96fb45726c94
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Thu Nov 14 03:34:49 2013 -0500

    Added some useful methods in claw/forklift.java. Cleaned up some of the
    code worked on today. Added annotations of locations where more work
    must be done. @bug was used to in-code javadocs to explain the bugs in
    different methods.

diff --git a/src/hardwareAbstraction/Claw.java b/src/hardwareAbstraction/Claw.java
index 7ff4445..6fb56fe 100644
--- a/src/hardwareAbstraction/Claw.java
+++ b/src/hardwareAbstraction/Claw.java
@@ -1,6 +1,7 @@
 package hardwareAbstraction;
 
 import utilities.Settings;
+import lejos.nxt.comm.RConsole;
 import lejos.nxt.remote.RemoteMotor;
 
 public class Claw {
@@ -9,9 +10,27 @@ public class Claw {
 	
 	/**
 	 * This method grabs an object. Returns nothing
+	 * @bug the execution of external motors causes exceptions. Try-catch block was put for now. Must be fixed. 
 	 */
 	public static void grabObject() {
-		claw.rotate(value);
+		RConsole.println("grabbing object");
+		try {
+			claw.rotate(value);
+		} catch (ArrayIndexOutOfBoundsException e){
+			
+		}
+	}
+	
+	/**
+	 * This method releases an object. Returns nothing
+	 * @bug the execution of external motors causes exceptions. Try-catch block was put for now. Must be fixed. 
+	 */
+	public static void releaseObject() {
+		RConsole.println("releasing object");
+		try {
+			claw.rotate(-value);
+		} catch (ArrayIndexOutOfBoundsException e){
+			
+		}
 	}
-
 }
diff --git a/src/hardwareAbstraction/Forklift.java b/src/hardwareAbstraction/Forklift.java
index f9144c7..2f33def 100644
--- a/src/hardwareAbstraction/Forklift.java
+++ b/src/hardwareAbstraction/Forklift.java
@@ -1,5 +1,6 @@
 package hardwareAbstraction;
 
+import lejos.nxt.comm.RConsole;
 import lejos.nxt.remote.RemoteMotor;
 import utilities.Settings;
 
@@ -9,13 +10,32 @@ public class Forklift {
 	private static double radius = 1; //radius of "spool". Must be tested. 
 	
 	/**
-	 * This method lifts an object. Returns nothing
+	 * This method lifts an object. Returns nothing.
+	 * @bug the execution of external motors causes exceptions. Try-catch block was put for now. Must be fixed. 
 	 */
 	public static void liftObject() {
-		lift.rotate(convertDistanceToAngle(distance));
+		RConsole.println("lifting object");
+		try {
+			lift.rotate(convertDistanceToAngle(distance));
+		} catch (ArrayIndexOutOfBoundsException e){
+		
+		}
 	}
 	
 	/**
+	 * This method lowers an object. Returns nothing.
+	 * @bug the execution of external motors causes exceptions. Try-catch block was put for now. Must be fixed. 
+	 */
+	public static void lowerObject() {
+		RConsole.println("lowering object");
+		try {
+			lift.rotate(-convertDistanceToAngle(distance));
+		} catch (ArrayIndexOutOfBoundsException e){
+		
+		}
+	}
+
+	/**
 	 * This method turns a distance into an angle for the robot to turn. Takes as parameter the distance you want to lift. 
 	 * It is essential the radius of this class be calibrated. The radius is the radius of the "spool" the string winds onto.
 	 * The formula used is: d = 2*pi*radius*(angle)/360 ==> angle = 360 * d / (2*pi*radius).
diff --git a/src/services/Navigation.java b/src/services/Navigation.java
index d43272b..e48395c 100644
--- a/src/services/Navigation.java
+++ b/src/services/Navigation.java
@@ -52,8 +52,7 @@ public class Navigation implements TimerListener {
 	public void timedOut() {
 		RConsole.println("Navigation timedOut");
 		RConsole.println(manager.cm.getState().name());
-		if (manager.cm.getState() == State.SEARCH
-				|| manager.cm.getState() == State.DROP_OFF) {
+		if (manager.cm.getState() == State.SEARCH || manager.cm.getState() == State.DROP_OFF) {
 		
 			if (route.empty()) {
 				// nothing is done
@@ -73,11 +72,12 @@ public class Navigation implements TimerListener {
 				} else if (Math.abs(dX) > 1 || Math.abs(dY) > 1) {
 					RConsole.println(""+Math.abs(dX)+" "+Math.abs(dY));
 					//scan ahead only once facing the correct orientation, then travelTo that destination.
+					//TODO comment back this code. Problematic code for the moment. 
 //					if (!scannedAhead) {
 //						manager.hm.drive.stop();
-//						pause();
+//						this.pause();
 //						manager.sm.obstacleAvoidance.scanAhead();
-//						start();
+//						this.start();
 //					}
 					travelTo();
 				} else {
@@ -203,11 +203,15 @@ public class Navigation implements TimerListener {
 		this.route = route;
 	}
 	
-	//useful methods used within dropoff. 
+	
+	/**
+	 * This method will export the route currently programmed and resets it to an empty route. 
+	 * @return
+	 */
 	public Stack<Point> exportAndResetRoute() {
-		Stack<Point> route = this.route;
-		this.route = initializeRoute();
-		return route;
+		Stack<Point> export = this.route;
+		this.route = new Stack<Point>();
+		return export;
 	}
 	
 	public void addToRoute(Point xy) {

commit ac607096bb6ead226732ac1abca38d71fe27a871
Author: Nicole <witternicole@gmail.com>
Date:   Wed Nov 13 22:44:45 2013 -0500

    Heavy changes were made today. Collect and dropoff were modified to work
    with the curent implementation of the hardware. Many lines of code were
    commented out for the moment. ControllerMananger.java was modified to
    start the state. Communicator.java had its remoteMotors modifeid to match
    the hardware design. Launcher should work aswell. Robot currently
    localizes and then moves to a location.

diff --git a/src/controllers/Collect.java b/src/controllers/Collect.java
index 49fe9cf..eb9e3aa 100644
--- a/src/controllers/Collect.java
+++ b/src/controllers/Collect.java
@@ -3,6 +3,7 @@ package controllers;
 import utilities.Settings;
 import hardwareAbstraction.Claw;
 import hardwareAbstraction.Forklift;
+import lejos.nxt.comm.RConsole;
 import manager.Manager;
 
 public class Collect extends Controller {
@@ -22,10 +23,22 @@ private Manager manager;
 		manager.cm.setState(State.PAUSE);
 		
 		//grab and lift
-		Claw.grabObject();
-		Forklift.liftObject();
+		RConsole.println("grabbing object");
+		try {
+			Claw.grabObject();
+		} catch (ArrayIndexOutOfBoundsException e){
+			
+		}
+		RConsole.println("lifting object");
+		
+		try {
+			Forklift.liftObject();
+		} catch (ArrayIndexOutOfBoundsException e){
+			
+		}
 		
 		//update storage count and go to the required next step (searching or dropping off).
+		RConsole.println("storage");
 		manager.cm.setStored(manager.cm.getStored() + 1);
 		if(manager.cm.getStored() >= Settings.maxBlockCapacity)
 			manager.cm.setState(State.DROP_OFF);
diff --git a/src/controllers/DropOff.java b/src/controllers/DropOff.java
index 7914d7a..b204488 100644
--- a/src/controllers/DropOff.java
+++ b/src/controllers/DropOff.java
@@ -22,7 +22,7 @@ private Manager manager;
 	public void run() {
 		//pause the re-execution
 		manager.cm.setState(State.PAUSE);
-		
+		/*
 		//store the route. 
 		Stack<Point> route = this.manager.sm.nav.exportAndResetRoute();
 		
@@ -31,6 +31,7 @@ private Manager manager;
 		
 		//go back to previous state
 		this.manager.sm.nav.setRoute(route);
+		*/
 		this.manager.cm.setState(State.SEARCH);
 	}
 }
diff --git a/src/hardwareAbstraction/Claw.java b/src/hardwareAbstraction/Claw.java
index 28b02f7..7ff4445 100644
--- a/src/hardwareAbstraction/Claw.java
+++ b/src/hardwareAbstraction/Claw.java
@@ -5,7 +5,7 @@ import lejos.nxt.remote.RemoteMotor;
 
 public class Claw {
 	static RemoteMotor claw = Settings.clawMotor;
-	static int value = 45; // 45 degrees. needs to be tested. 
+	static int value = 90; // 45 degrees. needs to be tested. 
 	
 	/**
 	 * This method grabs an object. Returns nothing
diff --git a/src/hardwareAbstraction/Forklift.java b/src/hardwareAbstraction/Forklift.java
index 8c404ac..f9144c7 100644
--- a/src/hardwareAbstraction/Forklift.java
+++ b/src/hardwareAbstraction/Forklift.java
@@ -5,7 +5,7 @@ import utilities.Settings;
 
 public class Forklift {
 	static RemoteMotor lift = Settings.forkliftMotor;
-	static int distance = 15; // 15 cm upwards. needs to be tested. 
+	static int distance = -45; // 45 cm upwards. needs to be tested. 
 	private static double radius = 1; //radius of "spool". Must be tested. 
 	
 	/**
diff --git a/src/launcher/Launcher.java b/src/launcher/Launcher.java
index 0cbcc05..b8edd7b 100644
--- a/src/launcher/Launcher.java
+++ b/src/launcher/Launcher.java
@@ -30,9 +30,7 @@ public class Launcher {
 		RConsole.openUSB(20000);
 		Button.waitForPress();
 		
-		
 		Manager manager = new Manager();
-		
 		manager.sm.localization.start();
 		
 		while(manager.cm.getState() == State.LOCALIZING) {
@@ -45,6 +43,8 @@ public class Launcher {
 		manager.sm.nav.addToRoute(new Point(60,0));
 		manager.sm.nav.turnToComplete(0);
 		
+		manager.cm.setState(State.COLLECT);
+		
 		Button.waitForPress();
 	
 	}
diff --git a/src/manager/ControllerManager.java b/src/manager/ControllerManager.java
index 28b6a9c..f342aed 100644
--- a/src/manager/ControllerManager.java
+++ b/src/manager/ControllerManager.java
@@ -29,6 +29,7 @@ public class ControllerManager implements TimerListener {
 		this.stored = 0;
 		this.timer = new Timer(UPDATE_PERIOD, this);
 		this.controllers = new Controller[]{new Search(manager), new Recognize(manager), new Collect(manager), new DropOff(manager), new WallFollower(manager)};
+		start();
 	}
 	
 	public void start() {
diff --git a/src/manager/Manager.java b/src/manager/Manager.java
index 380800b..9cfeb8b 100644
--- a/src/manager/Manager.java
+++ b/src/manager/Manager.java
@@ -15,10 +15,10 @@ public class Manager {
 		
 		this.hm = new HardwareManager(this);
 		
-		this.sm = new ServiceManager(this);
-		
 		this.cm = new ControllerManager(this);
 		
+		this.sm = new ServiceManager(this);
+		
 		
 		//Start Services
 		this.sm.start();
diff --git a/src/utilities/Communicator.java b/src/utilities/Communicator.java
index a549d08..59dbeaf 100644
--- a/src/utilities/Communicator.java
+++ b/src/utilities/Communicator.java
@@ -40,8 +40,8 @@ public class Communicator {
 
 		LCD.clear();
 		
-		Settings.forkliftMotor = nxt.A;
-		Settings.clawMotor = nxt.C;
+		Settings.forkliftMotor = nxt.C;
+		Settings.clawMotor = nxt.A;
 		Settings.ultrasonicMotor = nxt.B;
 		Settings.leftUltrasonic = new UltrasonicSensor(nxt.S3);
 		Settings.centerUltrasonic = new UltrasonicSensor(nxt.S1);

commit ac0607d7c941679b0ab9eb11a01af307e1fefb13
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Wed Nov 13 21:33:46 2013 -0500

    Got Navigation to work, working on localization and navigation
    integration together.

diff --git a/src/launcher/Launcher.java b/src/launcher/Launcher.java
index 69f375a..0cbcc05 100644
--- a/src/launcher/Launcher.java
+++ b/src/launcher/Launcher.java
@@ -39,7 +39,10 @@ public class Launcher {
 			manager.um.nap(150);
 		}
 		
-		manager.sm.nav.addToRoute(new Point(0,0));
+		manager.cm.setState(State.SEARCH);
+		
+		manager.sm.nav.start();
+		manager.sm.nav.addToRoute(new Point(60,0));
 		manager.sm.nav.turnToComplete(0);
 		
 		Button.waitForPress();
diff --git a/src/services/Localization.java b/src/services/Localization.java
index 7367ce0..bb4ef96 100644
--- a/src/services/Localization.java
+++ b/src/services/Localization.java
@@ -10,125 +10,136 @@ import lejos.util.TimerListener;
 import manager.*;
 
 public class Localization implements TimerListener {
-
+	
 	private Manager manager;
 	private Timer timer;
-
-	// Speed in deg/sec of which to rotate during localization
+	
+	
+	//Speed in deg/sec of which to rotate during localization
 	private double ROTATION_SPEED = 30;
-
-	// period to check ultrasonic sensor in ms
+	
+	//period to check ultrasonic sensor in ms
 	private final int UPDATE_PERIOD = 20;
-
-	// threshold distance in cm, to determine if we are at a critical angle
+	
+	//threshold distance in cm, to determine if we are at a critical angle
 	private final int THRESHOLD = 30;
-
+	
 	private boolean rising;
 	private double angleA;
 	private double angleB;
-
+	
 	private boolean lineLocalization;
 	private int rightLineCount;
 	private int leftLineCount;
-	private double[] lineDetectedHeadings = new double[8];
-
+	private double[] lineDetectedHeadings = new double[8]; 
+	
+	public boolean corrected = false;
+	
 	public Localization(Manager manager) {
 		this.manager = manager;
 		this.timer = new Timer(UPDATE_PERIOD, this);
 	}
-
+	
 	/**
 	 * Starts the localization process
 	 */
 	public void start() {
-
-		// Retrieves center Ultrasonic reading
+		
+		//Retrieves center Ultrasonic reading
 		int usReading = updateUltrasonic();
-
-		// Currently facing a wall, use rising edge detection for both angles
-		if (usReading < 4) {
+		
+		//Currently facing a wall, use rising edge detection for both angles
+		if(usReading < 4) {
 			manager.um.nap(120);
 			start();
 		}
-
-		else if (usReading < THRESHOLD) {
+		
+		else if(usReading < THRESHOLD) {
 			rising = true;
-
-		}
-		// currently not facing a wall, use falling edge, then rising edge
+			
+		} 
+		//currently not facing a wall, use falling edge, then rising edge
 		else if (usReading > THRESHOLD) {
 			rising = false;
-
-		}
-		// on the threshold, so start moving then try to start again
+			
+		} 
+		//on the threshold, so start moving then try to start again
 		else {
-
+			
 			manager.hm.drive.setSpeeds(0, ROTATION_SPEED);
 			manager.um.nap(50);
 			start();
 			return;
 		}
-
+		
 		LCD.drawString("Initial: ", 0, 4);
 		LCD.drawInt(usReading, 10, 4);
-
+		
 		angleA = Double.NaN;
 		angleB = Double.NaN;
 		lineDetectedHeadings[3] = Double.NaN;
-
+		
 		timer.start();
-
+		
 	}
-
-	public void stop() {
+	
+	public void stop() {	
 		timer.stop();
 	}
-
+	
 	/**
-	 * Controls Localization Calls relevant methods depending on stage of
-	 * localization
+	 * Controls Localization
+	 * Calls relevant methods depending on stage of localization 
 	 */
 	public void timedOut() {
-		// ultrasonic localization complete.
-		if (Double.isNaN(angleB)) {
+		// ultrasonic localization complete. 
+		if(Double.isNaN(angleB)) {
 			ultrasonicLocalization();
-		}
-		// //not finished line localization
-		else if (Double.isNaN(lineDetectedHeadings[3])) {
-			// move to correct orientation for line localization
-			if (!lineLocalization) {
-				prepareLineLocalization();
-			} else {
-				lineLocalization();
-			}
-		}
-		// localization complete, update position
+		} 
+//		//not finished line localization
+//		else if(Double.isNaN(lineDetectedHeadings[3])) {
+//			//move to correct orientation for line localization
+//			if(!lineLocalization) {
+//				prepareLineLocalization();
+//			} else {
+//				lineLocalization();
+//			}
+//		} 
+//		//localization complete, update position
+//		else {
+//			updatePosition();
+//			stop();
+//		}
+		//test stub :)
 		else {
-			updatePosition();
-			stop();
+			if(Math.abs(manager.sm.odo.getTheta()) > 0.1 )
+				manager.hm.drive.setSpeeds(0, ROTATION_SPEED);
+			else {
+				manager.hm.drive.setSpeeds(0,0);
+				stop();
+				manager.cm.setState(State.SEARCH);
+			}
 		}
-		// test stub :)
 	}
-
+	
 	/**
-	 * If the robot starts facing the fall the robot will do rising, rising edge
-	 * detection (angleA, angleB) if the robot starts facing the field the robot
-	 * will do falling edge, rising edge (angleA, angleB)
+	 * If the robot starts facing the fall the robot will do rising, rising edge detection (angleA, angleB)
+	 * if the robot starts facing the field the robot will do falling edge, rising edge (angleA, angleB) 
 	 */
 	public void ultrasonicLocalization() {
 		int distance = updateUltrasonic();
-
-		if (Double.isNaN(angleA)) {
-			if (rising) {
+		
+		if(Double.isNaN(angleA)) {
+			if(rising) {
 				manager.hm.drive.setSpeeds(0, -ROTATION_SPEED);
-				if (distance > THRESHOLD) {
+				if(distance > THRESHOLD) {
 					Sound.beep();
 					angleA = manager.sm.odo.getTheta();
 					manager.hm.drive.setSpeeds(0, ROTATION_SPEED);
 				}
 			} else {
 				manager.hm.drive.setSpeeds(0, ROTATION_SPEED);
-				if (distance < THRESHOLD) {
+				if(distance < THRESHOLD) {
 					Sound.beep();
 					manager.hm.drive.stop();
 					angleA = manager.sm.odo.getTheta();
@@ -136,8 +147,7 @@ public class Localization implements TimerListener {
 			}
 		} else {
 			manager.hm.drive.setSpeeds(0, ROTATION_SPEED);
-			if (distance > THRESHOLD
-					&& Math.abs(angleA - manager.sm.odo.getTheta()) > 1) {
+			if(distance > THRESHOLD && Math.abs(angleA-manager.sm.odo.getTheta()) > 1) {
 				Sound.beep();
 				angleB = manager.sm.odo.getTheta();
 				updateTheta();
@@ -145,55 +155,53 @@ public class Localization implements TimerListener {
 			}
 		}
 	}
-
+	
 	/**
 	 * Updates theta based on the results of ultrasonic sensor localization
 	 */
 	public void updateTheta() {
 		double deltaTheta = -(angleA + angleB) / 2;
-		if (rising) {
-			// Depending on what angle is bigger, offset deltaTheta to the
-			// correct amount
-			if (angleA > angleB) {
-				deltaTheta += 5.0 * Math.PI / 4.0;
+		if(rising) {
+			//Depending on what angle is bigger, offset deltaTheta to the correct amount
+			if(angleA > angleB) {
+				deltaTheta +=  5.0 * Math.PI / 4.0;
 			} else {
-				deltaTheta += Math.PI / 4.0;
+				deltaTheta +=  Math.PI / 4.0;
 			}
 		} else {
-			// Depending on what angle is bigger, offset deltaTheta to the
-			// correct amount
-			if (angleA > angleB) {
-				deltaTheta += 5.0 * Math.PI / 4.0;
+			//Depending on what angle is bigger, offset deltaTheta to the correct amount
+			if(angleA > angleB) {
+				deltaTheta +=  5.0 * Math.PI / 4.0;
 			} else {
-				deltaTheta += Math.PI / 4.0;
+				deltaTheta +=  Math.PI / 4.0;
 			}
 		}
-
+		
 		/*
 		 * Adjust for the starting corner
 		 */
-		if (Settings.startingCorner == StartingCorner.BOTTOM_RIGHT) {
-			deltaTheta -= Math.PI / 2;
+		if(Settings.startingCorner == StartingCorner.BOTTOM_RIGHT) {
+			deltaTheta -= Math.PI/2;
 		} else if (Settings.startingCorner == StartingCorner.TOP_RIGHT) {
 			deltaTheta -= Math.PI;
 		} else if (Settings.startingCorner == StartingCorner.TOP_LEFT) {
-			deltaTheta += Math.PI / 2;
+			deltaTheta += Math.PI/2;
 		}
-
-		RConsole.println("" + manager.sm.odo.getTheta());
-
-		// update the odometer
+		
+		RConsole.println(""+manager.sm.odo.getTheta());
+		
+		//update the odometer
 		manager.sm.odo.adjustPosition(0, 0, deltaTheta);
-
+		
 		LCD.drawString("X: ", 0, 0);
 		LCD.drawString("Y: ", 0, 1);
 		LCD.drawString("H: ", 0, 2);
 		LCD.drawInt(0, 3, 0);
 		LCD.drawInt(0, 3, 1);
 		LCD.drawInt((int) manager.sm.odo.getTheta(), 3, 2);
-
+		
 	}
-
+	
 	/**
 	 * calls checkLineSensor for each lineSensor
 	 */
@@ -201,7 +209,7 @@ public class Localization implements TimerListener {
 		checkLineSensor(true);
 		checkLineSensor(false);
 	}
-
+	
 	/**
 	 * Updates the odometers position based on line localization results
 	 */
@@ -210,50 +218,51 @@ public class Localization implements TimerListener {
 		double thetaYminus = (lineDetectedHeadings[3] + lineDetectedHeadings[7]) / 2.0;
 		double thetaYplus = (lineDetectedHeadings[1] + lineDetectedHeadings[5]) / 2.0;
 		double thetaXplus = (lineDetectedHeadings[2] + lineDetectedHeadings[6]) / 2.0;
-
+		
 		double thetaX = thetaXminus - thetaXplus;
 		double thetaY = thetaYplus - thetaYminus;
-
-		double x = -Settings.LS_OFFSET * Math.cos(thetaY / 2.0);
-		double y = -Settings.LS_OFFSET * Math.cos(thetaX / 2.0);
-
-		double dThetaX = -Math.PI / 2.0 + thetaX / 2.0 - thetaXminus;
-		double dThetaY = -Math.PI - thetaYminus - thetaY / 2.0;
-
+		
+		double x = -Settings.LS_OFFSET * Math.cos(thetaY/2.0);
+		double y = -Settings.LS_OFFSET * Math.cos(thetaX/2.0);
+		
+		double dThetaX = -Math.PI/2.0 + thetaX / 2.0 - thetaXminus;
+		double dThetaY = -Math.PI - thetaYminus - thetaY/2.0;
+		
 		double dTheta = (dThetaX + dThetaY) / 2.0;
-
+		
 		manager.sm.odo.adjustPosition(x, y, dTheta);
 
 		Position pos = manager.sm.odo.getPosition();
-
+		
 		LCD.drawString("X: ", 0, 0);
 		LCD.drawString("Y: ", 0, 1);
 		LCD.drawString("H: ", 0, 2);
 		LCD.drawInt((int) pos.x, 3, 0);
 		LCD.drawInt((int) pos.y, 3, 1);
 		LCD.drawInt((int) pos.theta, 3, 2);
-
+		
+		
 		manager.cm.setState(State.SEARCH);
 	}
-
+	
 	public void prepareLineLocalization() {
-		if (manager.sm.odo.getTheta() > lineLocalizationStartingOrientation() + 0.2) {
+		if(manager.sm.odo.getTheta() > lineLocalizationStartingOrientation() + 0.2 ) {
 			manager.hm.drive.setSpeeds(0, ROTATION_SPEED);
-		} else if (manager.sm.odo.getTheta() < lineLocalizationStartingOrientation() - 0.2) {
+		} else if(manager.sm.odo.getTheta() < lineLocalizationStartingOrientation() - 0.2 ) {
 			manager.hm.drive.setSpeeds(0, -ROTATION_SPEED);
 		} else {
 			manager.hm.drive.setSpeeds(0, ROTATION_SPEED);
 			lineLocalization = true;
 			rightLineCount = 0;
-			leftLineCount = 4;
+			leftLineCount = 4;					
 		}
 	}
-
+	
 	/**
 	 * returns the desired starting angle for line localization
 	 */
 	public double lineLocalizationStartingOrientation() {
-		if (Settings.startingCorner == StartingCorner.BOTTOM_RIGHT) {
+		if(Settings.startingCorner == StartingCorner.BOTTOM_RIGHT) {
 			return 3.0 * Math.PI / 4.0;
 		} else if (Settings.startingCorner == StartingCorner.TOP_RIGHT) {
 			return 5.0 * Math.PI / 4.0;
@@ -264,26 +273,19 @@ public class Localization implements TimerListener {
 		}
 	}
 
+	
 	public int updateUltrasonic() {
 		return manager.hm.ultrasonicPoller.getUSReading(1);
 	}
-
+	
 	/**
-	 * Updates the lineDetectedHeadings[] based on whether a new line has been
-	 * detected
-	 * 
-	 * @param rightSensor
-	 *            -> true if the right sensor is to be checked, false if the
-	 *            left sensor is to be checked
+	 * Updates the lineDetectedHeadings[] based on whether a new line has been detected
+	 * @param rightSensor -> true if the right sensor is to be checked, false if the left sensor is to be checked
 	 */
 	public void checkLineSensor(boolean rightSensor) {
-		/* This statement will choose either the left or right color (which
-		 * correspond to 0 and 1 respectively) sensor based on whether
-		 * rightSensor is true or false. */
-		if (manager.hm.linePoller.enteringLine((rightSensor) ? 1 : 0)) {
-			if (rightSensor && rightLineCount < 4) {
-				lineDetectedHeadings[rightLineCount] = manager.sm.odo
-						.getTheta();
+		if(manager.hm.linePoller.enteringLine((rightSensor) ? 1 : 0)) {
+			if(rightSensor && rightLineCount < 4) {
+				lineDetectedHeadings[rightLineCount] = manager.sm.odo.getTheta();
 				rightLineCount++;
 			} else if (leftLineCount < 8) {
 				lineDetectedHeadings[leftLineCount] = manager.sm.odo.getTheta();
@@ -291,5 +293,5 @@ public class Localization implements TimerListener {
 			}
 		}
 	}
-
+	
 }
diff --git a/src/services/Navigation.java b/src/services/Navigation.java
index 09a1e9e..d43272b 100644
--- a/src/services/Navigation.java
+++ b/src/services/Navigation.java
@@ -4,6 +4,7 @@ import java.util.Stack;
 
 import utilities.*;
 import controllers.State;
+import lejos.nxt.comm.RConsole;
 import lejos.util.Timer;
 import lejos.util.TimerListener;
 import manager.*;
@@ -35,6 +36,7 @@ public class Navigation implements TimerListener {
 	private boolean scannedAhead;
 
 	public Navigation(Manager manager) {
+		RConsole.println("Navigation initialized");
 		this.manager = manager;
 		this.route = initializeRoute();
 		this.currentPos = new Position();
@@ -48,6 +50,8 @@ public class Navigation implements TimerListener {
 
 	@Override
 	public void timedOut() {
+		RConsole.println("Navigation timedOut");
+		RConsole.println(manager.cm.getState().name());
 		if (manager.cm.getState() == State.SEARCH
 				|| manager.cm.getState() == State.DROP_OFF) {
 		
@@ -67,13 +71,14 @@ public class Navigation implements TimerListener {
 					// one wheel down slightly
 					turnTo(dH);
 				} else if (Math.abs(dX) > 1 || Math.abs(dY) > 1) {
+					RConsole.println(""+Math.abs(dX)+" "+Math.abs(dY));
 					//scan ahead only once facing the correct orientation, then travelTo that destination.
-					if (!scannedAhead) {
-						manager.hm.drive.stop();
-						pause();
-						manager.sm.obstacleAvoidance.scanAhead();
-						start();
-					}
+//					if (!scannedAhead) {
+//						manager.hm.drive.stop();
+//						pause();
+//						manager.sm.obstacleAvoidance.scanAhead();
+//						start();
+//					}
 					travelTo();
 				} else {
 					//stop the motors, reset scanning state and get next destination. 
@@ -90,6 +95,7 @@ public class Navigation implements TimerListener {
 	}
 	
 	public void start() {
+		RConsole.println("Navigation started");
 		this.time.start();
 	}
 	

commit 7f7e7629b22fd1abf59d6fe4ec3fd72e21252ec8
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Wed Nov 13 20:46:29 2013 -0500

    Added commentary.

diff --git a/src/services/Localization.java b/src/services/Localization.java
index c21c089..7367ce0 100644
--- a/src/services/Localization.java
+++ b/src/services/Localization.java
@@ -10,135 +10,125 @@ import lejos.util.TimerListener;
 import manager.*;
 
 public class Localization implements TimerListener {
-	
+
 	private Manager manager;
 	private Timer timer;
-	
-	
-	//Speed in deg/sec of which to rotate during localization
+
+	// Speed in deg/sec of which to rotate during localization
 	private double ROTATION_SPEED = 30;
-	
-	//period to check ultrasonic sensor in ms
+
+	// period to check ultrasonic sensor in ms
 	private final int UPDATE_PERIOD = 20;
-	
-	//threshold distance in cm, to determine if we are at a critical angle
+
+	// threshold distance in cm, to determine if we are at a critical angle
 	private final int THRESHOLD = 30;
-	
+
 	private boolean rising;
 	private double angleA;
 	private double angleB;
-	
+
 	private boolean lineLocalization;
 	private int rightLineCount;
 	private int leftLineCount;
-	private double[] lineDetectedHeadings = new double[8]; 
-	
-	public boolean corrected = false;
-	
+	private double[] lineDetectedHeadings = new double[8];
+
 	public Localization(Manager manager) {
 		this.manager = manager;
 		this.timer = new Timer(UPDATE_PERIOD, this);
 	}
-	
+
 	/**
 	 * Starts the localization process
 	 */
 	public void start() {
-		
-		//Retrieves center Ultrasonic reading
+
+		// Retrieves center Ultrasonic reading
 		int usReading = updateUltrasonic();
-		
-		//Currently facing a wall, use rising edge detection for both angles
-		if(usReading < 4) {
+
+		// Currently facing a wall, use rising edge detection for both angles
+		if (usReading < 4) {
 			manager.um.nap(120);
 			start();
 		}
-		
-		else if(usReading < THRESHOLD) {
+
+		else if (usReading < THRESHOLD) {
 			rising = true;
-			
-		} 
-		//currently not facing a wall, use falling edge, then rising edge
+
+		}
+		// currently not facing a wall, use falling edge, then rising edge
 		else if (usReading > THRESHOLD) {
 			rising = false;
-			
-		} 
-		//on the threshold, so start moving then try to start again
+
+		}
+		// on the threshold, so start moving then try to start again
 		else {
-			
+
 			manager.hm.drive.setSpeeds(0, ROTATION_SPEED);
 			manager.um.nap(50);
 			start();
 			return;
 		}
-		
+
 		LCD.drawString("Initial: ", 0, 4);
 		LCD.drawInt(usReading, 10, 4);
-		
+
 		angleA = Double.NaN;
 		angleB = Double.NaN;
 		lineDetectedHeadings[3] = Double.NaN;
-		
+
 		timer.start();
-		
+
 	}
-	
-	public void stop() {	
+
+	public void stop() {
 		timer.stop();
 	}
-	
+
 	/**
-	 * Controls Localization
-	 * Calls relevant methods depending on stage of localization 
+	 * Controls Localization Calls relevant methods depending on stage of
+	 * localization
 	 */
 	public void timedOut() {
-		// ultrasonic localization complete. 
-		if(Double.isNaN(angleB)) {
+		// ultrasonic localization complete.
+		if (Double.isNaN(angleB)) {
 			ultrasonicLocalization();
-		} 
-//		//not finished line localization
-//		else if(Double.isNaN(lineDetectedHeadings[3])) {
-//			//move to correct orientation for line localization
-//			if(!lineLocalization) {
-//				prepareLineLocalization();
-//			} else {
-//				lineLocalization();
-//			}
-//		} 
-//		//localization complete, update position
-//		else {
-//			updatePosition();
-//			stop();
-//		}
-		//test stub :)
-		else {
-			if(Math.abs(manager.sm.odo.getTheta()) > 0.1 )
-				manager.hm.drive.setSpeeds(0, ROTATION_SPEED);
-			else {
-				manager.hm.drive.setSpeeds(0,0);
-				stop();
+		}
+		// //not finished line localization
+		else if (Double.isNaN(lineDetectedHeadings[3])) {
+			// move to correct orientation for line localization
+			if (!lineLocalization) {
+				prepareLineLocalization();
+			} else {
+				lineLocalization();
 			}
 		}
+		// localization complete, update position
+		else {
+			updatePosition();
+			stop();
+		}
+		// test stub :)
 	}
-	
+
 	/**
-	 * If the robot starts facing the fall the robot will do rising, rising edge detection (angleA, angleB)
-	 * if the robot starts facing the field the robot will do falling edge, rising edge (angleA, angleB) 
+	 * If the robot starts facing the fall the robot will do rising, rising edge
+	 * detection (angleA, angleB) if the robot starts facing the field the robot
+	 * will do falling edge, rising edge (angleA, angleB)
 	 */
 	public void ultrasonicLocalization() {
 		int distance = updateUltrasonic();
-		
-		if(Double.isNaN(angleA)) {
-			if(rising) {
+
+		if (Double.isNaN(angleA)) {
+			if (rising) {
 				manager.hm.drive.setSpeeds(0, -ROTATION_SPEED);
-				if(distance > THRESHOLD) {
+				if (distance > THRESHOLD) {
 					Sound.beep();
 					angleA = manager.sm.odo.getTheta();
 					manager.hm.drive.setSpeeds(0, ROTATION_SPEED);
 				}
 			} else {
 				manager.hm.drive.setSpeeds(0, ROTATION_SPEED);
-				if(distance < THRESHOLD) {
+				if (distance < THRESHOLD) {
 					Sound.beep();
 					manager.hm.drive.stop();
 					angleA = manager.sm.odo.getTheta();
@@ -146,7 +136,8 @@ public class Localization implements TimerListener {
 			}
 		} else {
 			manager.hm.drive.setSpeeds(0, ROTATION_SPEED);
-			if(distance > THRESHOLD && Math.abs(angleA-manager.sm.odo.getTheta()) > 1) {
+			if (distance > THRESHOLD
+					&& Math.abs(angleA - manager.sm.odo.getTheta()) > 1) {
 				Sound.beep();
 				angleB = manager.sm.odo.getTheta();
 				updateTheta();
@@ -154,53 +145,55 @@ public class Localization implements TimerListener {
 			}
 		}
 	}
-	
+
 	/**
 	 * Updates theta based on the results of ultrasonic sensor localization
 	 */
 	public void updateTheta() {
 		double deltaTheta = -(angleA + angleB) / 2;
-		if(rising) {
-			//Depending on what angle is bigger, offset deltaTheta to the correct amount
-			if(angleA > angleB) {
-				deltaTheta +=  5.0 * Math.PI / 4.0;
+		if (rising) {
+			// Depending on what angle is bigger, offset deltaTheta to the
+			// correct amount
+			if (angleA > angleB) {
+				deltaTheta += 5.0 * Math.PI / 4.0;
 			} else {
-				deltaTheta +=  Math.PI / 4.0;
+				deltaTheta += Math.PI / 4.0;
 			}
 		} else {
-			//Depending on what angle is bigger, offset deltaTheta to the correct amount
-			if(angleA > angleB) {
-				deltaTheta +=  5.0 * Math.PI / 4.0;
+			// Depending on what angle is bigger, offset deltaTheta to the
+			// correct amount
+			if (angleA > angleB) {
+				deltaTheta += 5.0 * Math.PI / 4.0;
 			} else {
-				deltaTheta +=  Math.PI / 4.0;
+				deltaTheta += Math.PI / 4.0;
 			}
 		}
-		
+
 		/*
 		 * Adjust for the starting corner
 		 */
-		if(Settings.startingCorner == StartingCorner.BOTTOM_RIGHT) {
-			deltaTheta -= Math.PI/2;
+		if (Settings.startingCorner == StartingCorner.BOTTOM_RIGHT) {
+			deltaTheta -= Math.PI / 2;
 		} else if (Settings.startingCorner == StartingCorner.TOP_RIGHT) {
 			deltaTheta -= Math.PI;
 		} else if (Settings.startingCorner == StartingCorner.TOP_LEFT) {
-			deltaTheta += Math.PI/2;
+			deltaTheta += Math.PI / 2;
 		}
-		
-		RConsole.println(""+manager.sm.odo.getTheta());
-		
-		//update the odometer
+
+		RConsole.println("" + manager.sm.odo.getTheta());
+
+		// update the odometer
 		manager.sm.odo.adjustPosition(0, 0, deltaTheta);
-		
+
 		LCD.drawString("X: ", 0, 0);
 		LCD.drawString("Y: ", 0, 1);
 		LCD.drawString("H: ", 0, 2);
 		LCD.drawInt(0, 3, 0);
 		LCD.drawInt(0, 3, 1);
 		LCD.drawInt((int) manager.sm.odo.getTheta(), 3, 2);
-		
+
 	}
-	
+
 	/**
 	 * calls checkLineSensor for each lineSensor
 	 */
@@ -208,7 +201,7 @@ public class Localization implements TimerListener {
 		checkLineSensor(true);
 		checkLineSensor(false);
 	}
-	
+
 	/**
 	 * Updates the odometers position based on line localization results
 	 */
@@ -217,51 +210,50 @@ public class Localization implements TimerListener {
 		double thetaYminus = (lineDetectedHeadings[3] + lineDetectedHeadings[7]) / 2.0;
 		double thetaYplus = (lineDetectedHeadings[1] + lineDetectedHeadings[5]) / 2.0;
 		double thetaXplus = (lineDetectedHeadings[2] + lineDetectedHeadings[6]) / 2.0;
-		
+
 		double thetaX = thetaXminus - thetaXplus;
 		double thetaY = thetaYplus - thetaYminus;
-		
-		double x = -Settings.LS_OFFSET * Math.cos(thetaY/2.0);
-		double y = -Settings.LS_OFFSET * Math.cos(thetaX/2.0);
-		
-		double dThetaX = -Math.PI/2.0 + thetaX / 2.0 - thetaXminus;
-		double dThetaY = -Math.PI - thetaYminus - thetaY/2.0;
-		
+
+		double x = -Settings.LS_OFFSET * Math.cos(thetaY / 2.0);
+		double y = -Settings.LS_OFFSET * Math.cos(thetaX / 2.0);
+
+		double dThetaX = -Math.PI / 2.0 + thetaX / 2.0 - thetaXminus;
+		double dThetaY = -Math.PI - thetaYminus - thetaY / 2.0;
+
 		double dTheta = (dThetaX + dThetaY) / 2.0;
-		
+
 		manager.sm.odo.adjustPosition(x, y, dTheta);
 
 		Position pos = manager.sm.odo.getPosition();
-		
+
 		LCD.drawString("X: ", 0, 0);
 		LCD.drawString("Y: ", 0, 1);
 		LCD.drawString("H: ", 0, 2);
 		LCD.drawInt((int) pos.x, 3, 0);
 		LCD.drawInt((int) pos.y, 3, 1);
 		LCD.drawInt((int) pos.theta, 3, 2);
-		
-		
+
 		manager.cm.setState(State.SEARCH);
 	}
-	
+
 	public void prepareLineLocalization() {
-		if(manager.sm.odo.getTheta() > lineLocalizationStartingOrientation() + 0.2 ) {
+		if (manager.sm.odo.getTheta() > lineLocalizationStartingOrientation() + 0.2) {
 			manager.hm.drive.setSpeeds(0, ROTATION_SPEED);
-		} else if(manager.sm.odo.getTheta() < lineLocalizationStartingOrientation() - 0.2 ) {
+		} else if (manager.sm.odo.getTheta() < lineLocalizationStartingOrientation() - 0.2) {
 			manager.hm.drive.setSpeeds(0, -ROTATION_SPEED);
 		} else {
 			manager.hm.drive.setSpeeds(0, ROTATION_SPEED);
 			lineLocalization = true;
 			rightLineCount = 0;
-			leftLineCount = 4;					
+			leftLineCount = 4;
 		}
 	}
-	
+
 	/**
 	 * returns the desired starting angle for line localization
 	 */
 	public double lineLocalizationStartingOrientation() {
-		if(Settings.startingCorner == StartingCorner.BOTTOM_RIGHT) {
+		if (Settings.startingCorner == StartingCorner.BOTTOM_RIGHT) {
 			return 3.0 * Math.PI / 4.0;
 		} else if (Settings.startingCorner == StartingCorner.TOP_RIGHT) {
 			return 5.0 * Math.PI / 4.0;
@@ -272,19 +264,26 @@ public class Localization implements TimerListener {
 		}
 	}
 
-	
 	public int updateUltrasonic() {
 		return manager.hm.ultrasonicPoller.getUSReading(1);
 	}
-	
+
 	/**
-	 * Updates the lineDetectedHeadings[] based on whether a new line has been detected
-	 * @param rightSensor -> true if the right sensor is to be checked, false if the left sensor is to be checked
+	 * Updates the lineDetectedHeadings[] based on whether a new line has been
+	 * detected
+	 * 
+	 * @param rightSensor
+	 *            -> true if the right sensor is to be checked, false if the
+	 *            left sensor is to be checked
 	 */
 	public void checkLineSensor(boolean rightSensor) {
-		if(manager.hm.linePoller.enteringLine((rightSensor) ? 1 : 0)) {
-			if(rightSensor && rightLineCount < 4) {
-				lineDetectedHeadings[rightLineCount] = manager.sm.odo.getTheta();
+		/* This statement will choose either the left or right color (which
+		 * correspond to 0 and 1 respectively) sensor based on whether
+		 * rightSensor is true or false. */
+		if (manager.hm.linePoller.enteringLine((rightSensor) ? 1 : 0)) {
+			if (rightSensor && rightLineCount < 4) {
+				lineDetectedHeadings[rightLineCount] = manager.sm.odo
+						.getTheta();
 				rightLineCount++;
 			} else if (leftLineCount < 8) {
 				lineDetectedHeadings[leftLineCount] = manager.sm.odo.getTheta();
@@ -292,5 +291,5 @@ public class Localization implements TimerListener {
 			}
 		}
 	}
-	
+
 }

commit c11fa239a249184cf521c2c720385f0e190b8663
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Wed Nov 13 20:29:58 2013 -0500

    UltrasonicLocalization should work now. Ready to be tested.

diff --git a/src/services/Localization.java b/src/services/Localization.java
index f0707fe..c21c089 100644
--- a/src/services/Localization.java
+++ b/src/services/Localization.java
@@ -33,6 +33,8 @@ public class Localization implements TimerListener {
 	private int leftLineCount;
 	private double[] lineDetectedHeadings = new double[8]; 
 	
+	public boolean corrected = false;
+	
 	public Localization(Manager manager) {
 		this.manager = manager;
 		this.timer = new Timer(UPDATE_PERIOD, this);
@@ -90,23 +92,32 @@ public class Localization implements TimerListener {
 	 * Calls relevant methods depending on stage of localization 
 	 */
 	public void timedOut() {
-		//Not finished Ultrasonic localization
+		// ultrasonic localization complete. 
 		if(Double.isNaN(angleB)) {
 			ultrasonicLocalization();
 		} 
-		//not finished line localization
-		else if(Double.isNaN(lineDetectedHeadings[3])) {
-			//move to correct orientation for line localization
-			if(!lineLocalization) {
-				prepareLineLocalization();
-			} else {
-				lineLocalization();
-			}
-		} 
-		//localization complete, update position
+//		//not finished line localization
+//		else if(Double.isNaN(lineDetectedHeadings[3])) {
+//			//move to correct orientation for line localization
+//			if(!lineLocalization) {
+//				prepareLineLocalization();
+//			} else {
+//				lineLocalization();
+//			}
+//		} 
+//		//localization complete, update position
+//		else {
+//			updatePosition();
+//			stop();
+//		}
+		//test stub :)
 		else {
-			updatePosition();
-			stop();
+			if(Math.abs(manager.sm.odo.getTheta()) > 0.1 )
+				manager.hm.drive.setSpeeds(0, ROTATION_SPEED);
+			else {
+				manager.hm.drive.setSpeeds(0,0);
+				stop();
+			}
 		}
 	}
 	
@@ -139,6 +150,7 @@ public class Localization implements TimerListener {
 				Sound.beep();
 				angleB = manager.sm.odo.getTheta();
 				updateTheta();
+				manager.hm.drive.setSpeeds(0, 0);
 			}
 		}
 	}
@@ -175,6 +187,8 @@ public class Localization implements TimerListener {
 			deltaTheta += Math.PI/2;
 		}
 		
+		RConsole.println(""+manager.sm.odo.getTheta());
+		
 		//update the odometer
 		manager.sm.odo.adjustPosition(0, 0, deltaTheta);
 		

commit 3eafe30fcb2e39576c334860d4abdf265e860525
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Wed Nov 13 20:29:29 2013 -0500

    Added RConsole for debugging purposes. Seems to work fine for
    localization.

diff --git a/src/launcher/Launcher.java b/src/launcher/Launcher.java
index 8b2d545..69f375a 100644
--- a/src/launcher/Launcher.java
+++ b/src/launcher/Launcher.java
@@ -27,7 +27,7 @@ public class Launcher {
 	 * @param args
 	 */
 	public static void main(String[] args) {
-		//RConsole.openUSB(20000);
+		RConsole.openUSB(20000);
 		Button.waitForPress();
 		
 		

commit 90c407edf9cce581bdfaed686c73f638158728d0
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Wed Nov 13 20:29:02 2013 -0500

    Fixed printing issue. Small bug fix.

diff --git a/src/hardwareAbstraction/UltrasonicPoller.java b/src/hardwareAbstraction/UltrasonicPoller.java
index cf25565..d6120bb 100644
--- a/src/hardwareAbstraction/UltrasonicPoller.java
+++ b/src/hardwareAbstraction/UltrasonicPoller.java
@@ -57,6 +57,7 @@ public class UltrasonicPoller implements TimerListener {
 		counter++;
 		
 		if(counter == 5) {
+			LCD.drawString("                          ", 0, 6);
 			LCD.drawInt((int) getUSReading(center), 0, 6);
 			deltaTime = 0;
 		}

commit 897fefed57f5bf48bb5303bd793236002f17e3c8
Author: RileyvanRyswyk <rileyvan@gmail.com>
Date:   Wed Nov 13 15:58:24 2013 -0500

    Updates
    
    Use LCD to debug.  Bluetooth is too laggy.  RS485 is now used again.
    Minimum Ultrasonic poller period is about 100ms.  Started localization,
    but it needs some work.

diff --git a/src/hardwareAbstraction/Drive.java b/src/hardwareAbstraction/Drive.java
index 1fd0399..2a0a8b6 100644
--- a/src/hardwareAbstraction/Drive.java
+++ b/src/hardwareAbstraction/Drive.java
@@ -20,6 +20,8 @@ public class Drive {
 	public Drive() {
 		leftMotor = Settings.leftDriveMotor;
 		rightMotor = Settings.rightDriveMotor;
+		leftMotor.setAcceleration(500);
+		rightMotor.setAcceleration(500);
 	}
 	
 	/**
diff --git a/src/hardwareAbstraction/UltrasonicPoller.java b/src/hardwareAbstraction/UltrasonicPoller.java
index a6e279c..cf25565 100644
--- a/src/hardwareAbstraction/UltrasonicPoller.java
+++ b/src/hardwareAbstraction/UltrasonicPoller.java
@@ -1,6 +1,7 @@
 package hardwareAbstraction;
 
 import utilities.Settings;
+import lejos.nxt.LCD;
 import lejos.nxt.UltrasonicSensor;
 import lejos.nxt.comm.RConsole;
 import lejos.util.Timer;
@@ -22,6 +23,8 @@ public class UltrasonicPoller implements TimerListener {
 	private int center = 1;
 	private int right = 2;
 	private int counter;
+	private long previousTime;
+	private long deltaTime;
 
 	// TODO figure out what exactly this constructor should be.
 	public UltrasonicPoller() {
@@ -29,12 +32,12 @@ public class UltrasonicPoller implements TimerListener {
 		us[center] = Settings.centerUltrasonic;
 		us[right] = Settings.rightUltrasonic;
 
-		this.pollRate = 25;
+		this.pollRate = 10;
 		this.readings = new int[3][5];
 		
-		us[left].off();
+		//us[left].off();
 		us[center].off();
-		us[right].off();
+		//us[right].off();
 		
 		start();
 	}
@@ -44,17 +47,37 @@ public class UltrasonicPoller implements TimerListener {
 	@Override
 	public void timedOut() {
 		
-		if(counter == left) {
-			pingUS(left);
+		long currentTime = System.currentTimeMillis();
+		
+		deltaTime += currentTime - previousTime;
+		previousTime = currentTime;
+				
+		pingUS(center);
+		
+		counter++;
+		
+		if(counter == 5) {
+			LCD.drawInt((int) getUSReading(center), 0, 6);
+			deltaTime = 0;
+		}
+		
+		//keep the counter between 0 - 2
+		counter = counter % 5;
+		
+		
+		/*if(counter == left) {
+			//pingUS(left);
 		} else if(counter == center) {
 			pingUS(center);
 		} else {
-			pingUS(right);
+			//pingUS(right);
 		}
 		
 		counter++;
 		//keep the counter between 0 - 2
-		counter = counter % 3;
+		counter = counter % 3;*/
+
+		//RConsole.println(String.valueOf(System.currentTimeMillis() - currentTime));
 	}
 
 	/**
@@ -72,6 +95,9 @@ public class UltrasonicPoller implements TimerListener {
 		this.poller = new Timer(pollRate, this);
 		this.poller.start();
 		running = true;
+		this.previousTime = System.currentTimeMillis();
+		
+		RConsole.println(String.valueOf(poller.getDelay()));
 	}
 
 	/**
@@ -155,7 +181,7 @@ public class UltrasonicPoller implements TimerListener {
 	 */
 	private void pingUS(int sensor) {
 		int distance;
-
+		
 		// do a ping
 		us[sensor].ping();
 		
@@ -164,7 +190,7 @@ public class UltrasonicPoller implements TimerListener {
 		
 		// there will be a delay here
 		distance = us[sensor].getDistance();
-
+		
 		addReading(sensor, distance);
 	}
 
diff --git a/src/launcher/Launcher.java b/src/launcher/Launcher.java
index 003d7df..8b2d545 100644
--- a/src/launcher/Launcher.java
+++ b/src/launcher/Launcher.java
@@ -3,6 +3,7 @@
  */
 package launcher;
 
+import hardwareAbstraction.UltrasonicPoller;
 import utilities.Point;
 import controllers.State;
 import lejos.nxt.Button;
@@ -26,9 +27,10 @@ public class Launcher {
 	 * @param args
 	 */
 	public static void main(String[] args) {
-		RConsole.openUSB(20000);
+		//RConsole.openUSB(20000);
 		Button.waitForPress();
 		
+		
 		Manager manager = new Manager();
 		
 		manager.sm.localization.start();
diff --git a/src/manager/Manager.java b/src/manager/Manager.java
index 001125a..380800b 100644
--- a/src/manager/Manager.java
+++ b/src/manager/Manager.java
@@ -10,15 +10,15 @@ public class Manager {
 	public HardwareManager hm;	
 
 	public Manager() {
-		RConsole.println("initializing");
+		
 		this.um = new UtilityManager(this);
-		RConsole.println("um");
+		
 		this.hm = new HardwareManager(this);
-		RConsole.println("hm");
+		
 		this.sm = new ServiceManager(this);
-		RConsole.println("sm");
+		
 		this.cm = new ControllerManager(this);
-		RConsole.println("ControllerManager");
+		
 		
 		//Start Services
 		this.sm.start();
diff --git a/src/manager/ServiceManager.java b/src/manager/ServiceManager.java
index 3bfc9b8..d432f5a 100644
--- a/src/manager/ServiceManager.java
+++ b/src/manager/ServiceManager.java
@@ -21,11 +21,11 @@ public class ServiceManager {
 		this.obstacleAvoidance = new ObstacleAvoidance(manager);
 		this.mapper = new Mapper(manager);
 		this.localization = new Localization(manager);
-		this.hwView = new HardwareViewer(manager);
+		//this.hwView = new HardwareViewer(manager);
 	}
 	
 	public void start() {
 		nav.start();
-		hwView.start(75);
+		//hwView.start(75);
 	}
 }
diff --git a/src/services/HardwareViewer.java b/src/services/HardwareViewer.java
index 63c2117..821979a 100644
--- a/src/services/HardwareViewer.java
+++ b/src/services/HardwareViewer.java
@@ -54,7 +54,7 @@ public class HardwareViewer implements TimerListener {
 		int usL = usp.getUSReading(left);
 		int usC = usp.getUSReading(center);
 		int usR = usp.getUSReading(right);
-		RConsole.println(usL + ";" + usC + ";" + usR);
+		//RConsole.println(usL + ";" + usC + ";" + usR);
 	}
 	
 //	private void printLP() {
diff --git a/src/services/Localization.java b/src/services/Localization.java
index 3aff58c..f0707fe 100644
--- a/src/services/Localization.java
+++ b/src/services/Localization.java
@@ -2,6 +2,8 @@ package services;
 
 import controllers.State;
 import utilities.*;
+import lejos.nxt.LCD;
+import lejos.nxt.Sound;
 import lejos.nxt.comm.RConsole;
 import lejos.util.Timer;
 import lejos.util.TimerListener;
@@ -40,54 +42,69 @@ public class Localization implements TimerListener {
 	 * Starts the localization process
 	 */
 	public void start() {
-		RConsole.println("Localizing");
+		
 		//Retrieves center Ultrasonic reading
 		int usReading = updateUltrasonic();
 		
 		//Currently facing a wall, use rising edge detection for both angles
-		if(usReading < THRESHOLD) {
+		if(usReading < 4) {
+			manager.um.nap(120);
+			start();
+		}
+		
+		else if(usReading < THRESHOLD) {
 			rising = true;
-			RConsole.println("Rising");
+			
 		} 
 		//currently not facing a wall, use falling edge, then rising edge
 		else if (usReading > THRESHOLD) {
 			rising = false;
-			RConsole.println("falling");
+			
 		} 
 		//on the threshold, so start moving then try to start again
 		else {
-			RConsole.println("At threshold");
+			
 			manager.hm.drive.setSpeeds(0, ROTATION_SPEED);
 			manager.um.nap(50);
 			start();
 			return;
 		}
-		RConsole.println("initializing");
+		
+		LCD.drawString("Initial: ", 0, 4);
+		LCD.drawInt(usReading, 10, 4);
+		
 		angleA = Double.NaN;
 		angleB = Double.NaN;
 		lineDetectedHeadings[3] = Double.NaN;
-		RConsole.println("Starting");
+		
 		timer.start();
 		
 	}
 	
-	public void stop() {
-		
+	public void stop() {	
 		timer.stop();
 	}
 	
+	/**
+	 * Controls Localization
+	 * Calls relevant methods depending on stage of localization 
+	 */
 	public void timedOut() {
-		RConsole.println("localization");
+		//Not finished Ultrasonic localization
 		if(Double.isNaN(angleB)) {
 			ultrasonicLocalization();
-		} else if(Double.isNaN(lineDetectedHeadings[3])) {
-			
+		} 
+		//not finished line localization
+		else if(Double.isNaN(lineDetectedHeadings[3])) {
+			//move to correct orientation for line localization
 			if(!lineLocalization) {
 				prepareLineLocalization();
 			} else {
 				lineLocalization();
 			}
-		} else {
+		} 
+		//localization complete, update position
+		else {
 			updatePosition();
 			stop();
 		}
@@ -104,12 +121,14 @@ public class Localization implements TimerListener {
 			if(rising) {
 				manager.hm.drive.setSpeeds(0, -ROTATION_SPEED);
 				if(distance > THRESHOLD) {
+					Sound.beep();
 					angleA = manager.sm.odo.getTheta();
 					manager.hm.drive.setSpeeds(0, ROTATION_SPEED);
 				}
 			} else {
 				manager.hm.drive.setSpeeds(0, ROTATION_SPEED);
 				if(distance < THRESHOLD) {
+					Sound.beep();
 					manager.hm.drive.stop();
 					angleA = manager.sm.odo.getTheta();
 				}
@@ -117,6 +136,7 @@ public class Localization implements TimerListener {
 		} else {
 			manager.hm.drive.setSpeeds(0, ROTATION_SPEED);
 			if(distance > THRESHOLD && Math.abs(angleA-manager.sm.odo.getTheta()) > 1) {
+				Sound.beep();
 				angleB = manager.sm.odo.getTheta();
 				updateTheta();
 			}
@@ -157,7 +177,14 @@ public class Localization implements TimerListener {
 		
 		//update the odometer
 		manager.sm.odo.adjustPosition(0, 0, deltaTheta);
-		RConsole.println(manager.sm.odo.getPosition().toString());
+		
+		LCD.drawString("X: ", 0, 0);
+		LCD.drawString("Y: ", 0, 1);
+		LCD.drawString("H: ", 0, 2);
+		LCD.drawInt(0, 3, 0);
+		LCD.drawInt(0, 3, 1);
+		LCD.drawInt((int) manager.sm.odo.getTheta(), 3, 2);
+		
 	}
 	
 	/**
@@ -189,7 +216,17 @@ public class Localization implements TimerListener {
 		double dTheta = (dThetaX + dThetaY) / 2.0;
 		
 		manager.sm.odo.adjustPosition(x, y, dTheta);
-		RConsole.println(manager.sm.odo.getPosition().toString());
+
+		Position pos = manager.sm.odo.getPosition();
+		
+		LCD.drawString("X: ", 0, 0);
+		LCD.drawString("Y: ", 0, 1);
+		LCD.drawString("H: ", 0, 2);
+		LCD.drawInt((int) pos.x, 3, 0);
+		LCD.drawInt((int) pos.y, 3, 1);
+		LCD.drawInt((int) pos.theta, 3, 2);
+		
+		
 		manager.cm.setState(State.SEARCH);
 	}
 	
diff --git a/src/utilities/Communicator.java b/src/utilities/Communicator.java
index 1ea9d49..a549d08 100644
--- a/src/utilities/Communicator.java
+++ b/src/utilities/Communicator.java
@@ -26,7 +26,7 @@ public class Communicator {
 	public Communicator(String slaveNXT) {
 		RemoteNXT nxt = null;
 		try {
-			nxt = new RemoteNXT(slaveNXT, Bluetooth.getConnector());
+			nxt = new RemoteNXT(slaveNXT, RS485.getConnector());
 			LCD.clear();
             LCD.drawString("Connected",0,1);
             Thread.sleep(2000);
@@ -44,9 +44,9 @@ public class Communicator {
 		Settings.clawMotor = nxt.C;
 		Settings.ultrasonicMotor = nxt.B;
 		Settings.leftUltrasonic = new UltrasonicSensor(nxt.S3);
-		//Settings.centerUltrasonic = new UltrasonicSensor(nxt.S1);
+		Settings.centerUltrasonic = new UltrasonicSensor(nxt.S1);
 		Settings.rightUltrasonic = new UltrasonicSensor(nxt.S2);
-		RConsole.println("Connected");
+		
 	}
 
 	/**
diff --git a/src/utilities/Responder.java b/src/utilities/Responder.java
index bd5d304..89c8063 100644
--- a/src/utilities/Responder.java
+++ b/src/utilities/Responder.java
@@ -44,7 +44,7 @@ public class Responder {
 	
 	public static void main(String[] args) throws Exception {
 		LCD.drawString("Connecting", 1, 1);
-		ResponderTool resp = new ResponderTool(Bluetooth.getConnector());
+		ResponderTool resp = new ResponderTool(RS485.getConnector());
 		resp.start();
 		resp.join();
 		
diff --git a/src/utilities/Settings.java b/src/utilities/Settings.java
index dd7fd39..e4a10b7 100644
--- a/src/utilities/Settings.java
+++ b/src/utilities/Settings.java
@@ -16,7 +16,7 @@ public class Settings {
 	public static ColorSensor rearRightColorSensor = new ColorSensor(SensorPort.S3);
 	
 	public static UltrasonicSensor leftUltrasonic;
-	public static UltrasonicSensor centerUltrasonic = new UltrasonicSensor(SensorPort.S4);
+	public static UltrasonicSensor centerUltrasonic;
 	public static UltrasonicSensor rightUltrasonic;
 	
 	public static NXTRegulatedMotor leftDriveMotor = Motor.B;

commit 63ee6c0d133ec17a274ab8b13218f129683122bb
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Mon Nov 11 15:49:35 2013 -0500

    Updated ObstacleAvoidance.java method to scanAhead() method. It now
    should work, pending a final revision. Added a helper method (and
    documented it) in Position to allow scanAhead() to work. scan() still
    needs work.

diff --git a/src/services/ObstacleAvoidance.java b/src/services/ObstacleAvoidance.java
index 3252385..c266658 100644
--- a/src/services/ObstacleAvoidance.java
+++ b/src/services/ObstacleAvoidance.java
@@ -1,6 +1,7 @@
 package services;
 
 import utilities.Point;
+import utilities.Position;
 import controllers.State;
 import manager.*;
 
@@ -38,7 +39,7 @@ public class ObstacleAvoidance {
 
 	public boolean scanAhead() {
 		// TODO note this may be necessary to avoid having the robot navigate while scanning. 
-//		manager.cm.setState(State.PAUSE);
+		manager.cm.setState(State.PAUSE);
 		
 		// TODO somehow move all the three ultrasonic sensors forward with slave brick. Waiting for ultrasonicMotor implementation. 
 		
@@ -59,14 +60,18 @@ public class ObstacleAvoidance {
 		}
 		else {
 			//TODO remove or add this depending if state is changed to pause at start of scanAhead(); 
-//			manager.cm.setState(State.SEARCH);
+			manager.cm.setState(State.SEARCH);
 			if(smallestReading > threshold + safetyThreshold)
 				return true;
 			else {
-				//put this point in the route stack as the next place to go. 
-				Point pos = manager.sm.odo.getPosition().getPoint();
-				//TODO calculate the new position to navigate to... summation of two points. To figure out. 
-				manager.sm.nav.addToRoute(pos /* + add a point here*/);
+				// Get current position
+				Position pos = manager.sm.odo.getPosition();
+				
+				// Compute position to head to, minus a safety margin.
+				Point next = pos.addDistanceToPosition(smallestReading - this.safetyThreshold);
+				
+				// Add this position to the stack, head to then next. 
+				manager.sm.nav.addToRoute(next);
 				return true;
 			}
 		}
diff --git a/src/utilities/Position.java b/src/utilities/Position.java
index 093b5ab..a970a2d 100644
--- a/src/utilities/Position.java
+++ b/src/utilities/Position.java
@@ -3,13 +3,13 @@ package utilities;
 public class Position extends Point {
 
 	public double theta;
-	
-	public Position (double x, double y, double theta) {
+
+	public Position(double x, double y, double theta) {
 		this.x = x;
 		this.y = y;
 		this.theta = theta;
 	}
-	
+
 	public Position() {
 		this.x = Double.NaN;
 		this.y = Double.NaN;
@@ -19,4 +19,22 @@ public class Position extends Point {
 	public String toString() {
 		return "{x:" + x + ", y:" + y + ", theta:" + theta + "}";
 	}
+
+	/**
+	 * This method assumes the robot is at this position. It adds a distance to
+	 * the position, generating a new position. Useful when the robot needs to
+	 * travel somewhere in a straight line ahead of it. Formula used for newX
+	 * position is x + deltaX where deltaX is distance * cos(theta). Theta is
+	 * discarded due to logical reasons (the angle the robot ends up at its
+	 * destination is not necessarily the same as the angle it started with.
+	 * <p>
+	 * @param distance
+	 *            A distance the robot should travel forward
+	 * @return A point with the destination coordinates.
+	 */
+	public Point addDistanceToPosition(double distance) {
+		double posX = this.x + distance * Math.cos(this.theta);
+		double posY = this.y + distance * Math.sin(this.theta);
+		return new Point(posX, posY);
+	}
 }

commit 2b128aa900ec849229aacd0754ef2e84937d41db
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Mon Nov 11 14:30:27 2013 -0500

    Updated the Point.java class with a useful getter.
    ObstacleAvoidance.java has holes that were documented.

diff --git a/src/services/ObstacleAvoidance.java b/src/services/ObstacleAvoidance.java
index 3719a3e..3252385 100644
--- a/src/services/ObstacleAvoidance.java
+++ b/src/services/ObstacleAvoidance.java
@@ -1,5 +1,7 @@
 package services;
 
+import utilities.Point;
+import controllers.State;
 import manager.*;
 
 /**
@@ -24,37 +26,71 @@ public class ObstacleAvoidance {
 	private hardwareAbstraction.UltrasonicPoller poller;
 	private int threshold;
 	private int safetyThreshold;
+	private Manager manager;
 	
 	public ObstacleAvoidance(Manager manager) {
+		this.manager = manager;
 		poller = manager.hm.ultrasonicPoller;
+		//TODO test these values, find appropriate values for our robot. 
 		this.threshold=20;
 		this.safetyThreshold=5;
 	}
-	
-	//TODO complete this stub.
+
 	public boolean scanAhead() {
-		// TODO somehow move all the three ultrasonic sensors forward with slave brick. Waiting for feedback from RS485 to do this. 
+		// TODO note this may be necessary to avoid having the robot navigate while scanning. 
+//		manager.cm.setState(State.PAUSE);
 		
-		//reset pollers. 
-		poller.stop();
-		poller.start();
+		// TODO somehow move all the three ultrasonic sensors forward with slave brick. Waiting for ultrasonicMotor implementation. 
 		
-		// let the current heading readings propogate through the poller.
-		nap(poller.pollRate * 6);
+		this.resetUSP();
+		
+		int smallestReading = -1;
+		/* Only go forward when the data has propagated through. Only here for fail safe. */ 
+		do {
+			// let the current heading readings propagate through the poller.
+			nap(poller.pollRate * 6);
+		
+			smallestReading = poller.getLowestReading();
+		} while(smallestReading < 0);
 		
-		int smallestReading = poller.getLowestReading();
 		if(smallestReading < threshold) {
-			// TODO set the state
+			manager.cm.setState(State.RECOGNIZE);
 			return false;
 		}
-		else if(smallestReading > threshold + safetyThreshold)
-			return true;
 		else {
-			//TODO add point in navigation class. 
-			return true;
+			//TODO remove or add this depending if state is changed to pause at start of scanAhead(); 
+//			manager.cm.setState(State.SEARCH);
+			if(smallestReading > threshold + safetyThreshold)
+				return true;
+			else {
+				//put this point in the route stack as the next place to go. 
+				Point pos = manager.sm.odo.getPosition().getPoint();
+				//TODO calculate the new position to navigate to... summation of two points. To figure out. 
+				manager.sm.nav.addToRoute(pos /* + add a point here*/);
+				return true;
+			}
 		}
 	}
 	
+	/**
+	 * Scans with the central ultrasonic sensor. Used to verify if there is anything within this.threshold of robot.
+	 * @return	True if nothing is found, otherwise false
+	 */
+	
+	//TODO complete method stub. 
+	public boolean scan() {
+		this.resetUSP();
+		//scan center 
+		return true;
+	}
+	
+	/**
+	 * Useful method to reset pollers. Ensures only 
+	 */
+	private void resetUSP() {
+		poller.stop();
+		poller.start();
+	}
 	
 	
 	/** Helper method to avoid large try/catch blocks. Sleeps the current thread. 
diff --git a/src/utilities/Point.java b/src/utilities/Point.java
index cb1fc6d..72e25bf 100644
--- a/src/utilities/Point.java
+++ b/src/utilities/Point.java
@@ -22,4 +22,9 @@ public class Point  {
 	public String toString() {
 		return "{x:" + x + ", y:" + y + "}";
 	}
+	
+	//return a point object identical to the current point. Not passed by reference. 
+	public Point getPoint() {
+		return new Point(this.x, this.y);
+	}
 }

commit 05f5ab2723d351e1e403731b086672f6eb360295
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Mon Nov 11 14:18:58 2013 -0500

    Cleaned up some of the comments in Responder.java.

diff --git a/src/utilities/Responder.java b/src/utilities/Responder.java
index d90a6b0..bd5d304 100644
--- a/src/utilities/Responder.java
+++ b/src/utilities/Responder.java
@@ -8,7 +8,7 @@ import lejos.nxt.comm.RS485;
 
 /**
  * The responder class responds to the LCP requests sent by the Communicator.java class. 
- * Uses by default Bluetooth without exception for a reliable, stable connection.
+ * Uses by default Bluetooth.
  * 
  * Slight modification for LeJOS samples
  * <p> 

commit f20e37c7a34239dc75ab9c49d3779a37859eeab9
Author: RileyvanRyswyk <rileyvan@gmail.com>
Date:   Sun Nov 10 23:26:46 2013 -0500

    NXT-NXT communicator fixes
    
    Also setup for localization debugging.

diff --git a/src/hardwareAbstraction/Drive.java b/src/hardwareAbstraction/Drive.java
index 2fb372a..1fd0399 100644
--- a/src/hardwareAbstraction/Drive.java
+++ b/src/hardwareAbstraction/Drive.java
@@ -13,9 +13,9 @@ public class Drive {
 	private NXTRegulatedMotor leftMotor;
 	private NXTRegulatedMotor rightMotor;
 	
-	public static final double LEFT_RADIUS = 2.11;
-	public static final double RIGHT_RADIUS = 2.11;
-	public static final double WIDTH = 15.00;
+	public static final double LEFT_RADIUS = 2.03;
+	public static final double RIGHT_RADIUS = 2.03;
+	public static final double WIDTH = 15.90;
 	
 	public Drive() {
 		leftMotor = Settings.leftDriveMotor;
diff --git a/src/launcher/Launcher.java b/src/launcher/Launcher.java
index 4b6d23c..003d7df 100644
--- a/src/launcher/Launcher.java
+++ b/src/launcher/Launcher.java
@@ -31,17 +31,7 @@ public class Launcher {
 		
 		Manager manager = new Manager();
 		
-		manager.hm.drive.setSpeeds(10, 0);
-		int count = 0;
-		while(count < 80) {
-			RConsole.println(manager.sm.odo.getPosition().toString());
-			manager.um.nap(100);
-			count++;
-		}
-		manager.hm.drive.stop();
-		RConsole.println(manager.sm.odo.getPosition().toString());
-		
-		/*manager.sm.localization.start();
+		manager.sm.localization.start();
 		
 		while(manager.cm.getState() == State.LOCALIZING) {
 			manager.um.nap(150);
@@ -50,8 +40,6 @@ public class Launcher {
 		manager.sm.nav.addToRoute(new Point(0,0));
 		manager.sm.nav.turnToComplete(0);
 		
-		*/
-		
 		Button.waitForPress();
 	
 	}
diff --git a/src/manager/Manager.java b/src/manager/Manager.java
index ce775bb..001125a 100644
--- a/src/manager/Manager.java
+++ b/src/manager/Manager.java
@@ -20,6 +20,8 @@ public class Manager {
 		this.cm = new ControllerManager(this);
 		RConsole.println("ControllerManager");
 		
+		//Start Services
+		this.sm.start();
 		
 	}
 }
diff --git a/src/manager/ServiceManager.java b/src/manager/ServiceManager.java
index cf12c52..3bfc9b8 100644
--- a/src/manager/ServiceManager.java
+++ b/src/manager/ServiceManager.java
@@ -23,4 +23,9 @@ public class ServiceManager {
 		this.localization = new Localization(manager);
 		this.hwView = new HardwareViewer(manager);
 	}
+	
+	public void start() {
+		nav.start();
+		hwView.start(75);
+	}
 }
diff --git a/src/services/HardwareViewer.java b/src/services/HardwareViewer.java
index b47b944..63c2117 100644
--- a/src/services/HardwareViewer.java
+++ b/src/services/HardwareViewer.java
@@ -24,17 +24,11 @@ public class HardwareViewer implements TimerListener {
 	private Timer refresher;
 
 	public HardwareViewer(Manager manager) {
-		//get console
-		RConsole.openBluetooth(20000);
 		
 		//get hardware
 		this.usp = manager.hm.ultrasonicPoller;
 //		this.lp = manager.hm.linePoller;
-		
-		
-		//begin printing now
-		this.pollRate = 75;
-		this.start(pollRate);
+
 	}
 	
 	@Override
diff --git a/src/services/Localization.java b/src/services/Localization.java
index f986b15..3aff58c 100644
--- a/src/services/Localization.java
+++ b/src/services/Localization.java
@@ -26,7 +26,7 @@ public class Localization implements TimerListener {
 	private double angleA;
 	private double angleB;
 	
-	private boolean lightLocalization;
+	private boolean lineLocalization;
 	private int rightLineCount;
 	private int leftLineCount;
 	private double[] lineDetectedHeadings = new double[8]; 
@@ -77,22 +77,13 @@ public class Localization implements TimerListener {
 	}
 	
 	public void timedOut() {
-		RConsole.println("timedOut");
+		RConsole.println("localization");
 		if(Double.isNaN(angleB)) {
 			ultrasonicLocalization();
 		} else if(Double.isNaN(lineDetectedHeadings[3])) {
 			
-			if(!lightLocalization) {
-				if(manager.sm.odo.getTheta() > lineLocalizationStartingOrientation() + 0.2 ) {
-					manager.hm.drive.setSpeeds(0, ROTATION_SPEED);
-				} else if(manager.sm.odo.getTheta() < lineLocalizationStartingOrientation() - 0.2 ) {
-					manager.hm.drive.setSpeeds(0, -ROTATION_SPEED);
-				} else {
-					manager.hm.drive.setSpeeds(0, ROTATION_SPEED);
-					lightLocalization = true;
-					rightLineCount = 0;
-					leftLineCount = 4;					
-				}
+			if(!lineLocalization) {
+				prepareLineLocalization();
 			} else {
 				lineLocalization();
 			}
@@ -178,7 +169,7 @@ public class Localization implements TimerListener {
 	}
 	
 	/**
-	 * Updates the odometers position based on light localization results
+	 * Updates the odometers position based on line localization results
 	 */
 	public void updatePosition() {
 		double thetaXminus = (lineDetectedHeadings[0] + lineDetectedHeadings[4]) / 2.0;
@@ -202,8 +193,21 @@ public class Localization implements TimerListener {
 		manager.cm.setState(State.SEARCH);
 	}
 	
+	public void prepareLineLocalization() {
+		if(manager.sm.odo.getTheta() > lineLocalizationStartingOrientation() + 0.2 ) {
+			manager.hm.drive.setSpeeds(0, ROTATION_SPEED);
+		} else if(manager.sm.odo.getTheta() < lineLocalizationStartingOrientation() - 0.2 ) {
+			manager.hm.drive.setSpeeds(0, -ROTATION_SPEED);
+		} else {
+			manager.hm.drive.setSpeeds(0, ROTATION_SPEED);
+			lineLocalization = true;
+			rightLineCount = 0;
+			leftLineCount = 4;					
+		}
+	}
+	
 	/**
-	 * returns the desired starting angle for light localization
+	 * returns the desired starting angle for line localization
 	 */
 	public double lineLocalizationStartingOrientation() {
 		if(Settings.startingCorner == StartingCorner.BOTTOM_RIGHT) {
diff --git a/src/services/Navigation.java b/src/services/Navigation.java
index a15ce1f..09a1e9e 100644
--- a/src/services/Navigation.java
+++ b/src/services/Navigation.java
@@ -39,8 +39,6 @@ public class Navigation implements TimerListener {
 		this.route = initializeRoute();
 		this.currentPos = new Position();
 		this.time = new Timer(UPDATE_PERIOD, this);
-		//start navigation right away
-		this.time.start();
 	}
 
 	// TODO an initializer of default points should be constructed here.
diff --git a/src/utilities/Communicator.java b/src/utilities/Communicator.java
index dd23de4..1ea9d49 100644
--- a/src/utilities/Communicator.java
+++ b/src/utilities/Communicator.java
@@ -4,6 +4,7 @@ import java.io.IOException;
 
 import lejos.nxt.LCD;
 import lejos.nxt.UltrasonicSensor;
+import lejos.nxt.comm.Bluetooth;
 import lejos.nxt.comm.RConsole;
 import lejos.nxt.comm.RS485;
 import lejos.nxt.remote.RemoteNXT;
@@ -25,10 +26,16 @@ public class Communicator {
 	public Communicator(String slaveNXT) {
 		RemoteNXT nxt = null;
 		try {
-			nxt = new RemoteNXT(slaveNXT, RS485.getConnector());
+			nxt = new RemoteNXT(slaveNXT, Bluetooth.getConnector());
+			LCD.clear();
+            LCD.drawString("Connected",0,1);
+            Thread.sleep(2000);
 		} catch (IOException ioe) {
 			catchBug("RS485 Connection has Failed. See error: "
 					+ ioe.getMessage());
+		} catch (InterruptedException e) {
+			// TODO Auto-generated catch block
+			e.printStackTrace();
 		}
 
 		LCD.clear();
@@ -36,10 +43,10 @@ public class Communicator {
 		Settings.forkliftMotor = nxt.A;
 		Settings.clawMotor = nxt.C;
 		Settings.ultrasonicMotor = nxt.B;
-		RConsole.println("Connected");
 		Settings.leftUltrasonic = new UltrasonicSensor(nxt.S3);
-		Settings.centerUltrasonic = new UltrasonicSensor(nxt.S1);
+		//Settings.centerUltrasonic = new UltrasonicSensor(nxt.S1);
 		Settings.rightUltrasonic = new UltrasonicSensor(nxt.S2);
+		RConsole.println("Connected");
 	}
 
 	/**
diff --git a/src/utilities/Responder.java b/src/utilities/Responder.java
index af7d564..d90a6b0 100644
--- a/src/utilities/Responder.java
+++ b/src/utilities/Responder.java
@@ -1,20 +1,25 @@
 package utilities;
 
 import lejos.nxt.LCD;
+import lejos.nxt.comm.Bluetooth;
 import lejos.nxt.comm.LCPResponder;
 import lejos.nxt.comm.NXTCommConnector;
 import lejos.nxt.comm.RS485;
 
 /**
  * The responder class responds to the LCP requests sent by the Communicator.java class. 
- * Uses by default RS485 without exception for a reliable, stable connection.
+ * Uses by default Bluetooth without exception for a reliable, stable connection.
+ * 
+ * Slight modification for LeJOS samples
  * <p> 
+ * @author Andy Shaw
  * @author danielle
  * 
  */
 public class Responder {
 	/**
 	 * The subclass that handles the LCP connections. In particular, it is modified version of the LCPResponder to shutdown the connection once the program disconnects.
+	 * @author Andy Shaw
 	 * @author danielle
 	 *
 	 */
@@ -37,16 +42,12 @@ public class Responder {
 	 *            This is the default constructor, not needed.
 	 */
 	
-	public static void main(String[] args) {
+	public static void main(String[] args) throws Exception {
 		LCD.drawString("Connecting", 1, 1);
-		ResponderTool resp = new ResponderTool(RS485.getConnector());
+		ResponderTool resp = new ResponderTool(Bluetooth.getConnector());
 		resp.start();
-		try {
-			resp.join();
-		} catch (InterruptedException e) {
-			Communicator.catchBug("The responder failed in the Responder.java class " + e.getMessage());
-		}
-		LCD.drawString("Connected", 2, 2);
+		resp.join();
+		
     }
 	
 }
\ No newline at end of file
diff --git a/src/utilities/Settings.java b/src/utilities/Settings.java
index 9cff55c..dd7fd39 100644
--- a/src/utilities/Settings.java
+++ b/src/utilities/Settings.java
@@ -16,11 +16,11 @@ public class Settings {
 	public static ColorSensor rearRightColorSensor = new ColorSensor(SensorPort.S3);
 	
 	public static UltrasonicSensor leftUltrasonic;
-	public static UltrasonicSensor centerUltrasonic;
+	public static UltrasonicSensor centerUltrasonic = new UltrasonicSensor(SensorPort.S4);
 	public static UltrasonicSensor rightUltrasonic;
 	
 	public static NXTRegulatedMotor leftDriveMotor = Motor.B;
-	public static NXTRegulatedMotor rightDriveMotor = Motor.C;
+	public static NXTRegulatedMotor rightDriveMotor = Motor.A;
 	
 	public static RemoteMotor forkliftMotor;
 	public static RemoteMotor ultrasonicMotor;

commit be49c7f7613f231ef0c111b47ca0a9324a013c0f
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Sun Nov 10 16:27:31 2013 -0500

    Collect and dropoff commentation updated.

diff --git a/src/controllers/Collect.java b/src/controllers/Collect.java
index e3a4283..49fe9cf 100644
--- a/src/controllers/Collect.java
+++ b/src/controllers/Collect.java
@@ -20,10 +20,14 @@ private Manager manager;
 	public void run() {
 		//pause the re-execution
 		manager.cm.setState(State.PAUSE);
+		
+		//grab and lift
 		Claw.grabObject();
 		Forklift.liftObject();
-		manager.cm.setStored(manager.cm.getStored());
-		if(manager.cm.getStored() == Settings.maxBlockCapacity)
+		
+		//update storage count and go to the required next step (searching or dropping off).
+		manager.cm.setStored(manager.cm.getStored() + 1);
+		if(manager.cm.getStored() >= Settings.maxBlockCapacity)
 			manager.cm.setState(State.DROP_OFF);
 		else
 			manager.cm.setState(State.SEARCH);
diff --git a/src/controllers/DropOff.java b/src/controllers/DropOff.java
index ee395ef..7914d7a 100644
--- a/src/controllers/DropOff.java
+++ b/src/controllers/DropOff.java
@@ -6,6 +6,11 @@ import utilities.Point;
 import utilities.Settings;
 import manager.Manager;
 
+/**
+ * This class will dropoff the block at the destination required. 
+ * It will navigate to the green zone location and drop off the block.
+ * @author danielle
+ */
 public class DropOff extends Controller {
 
 private Manager manager;
@@ -21,7 +26,7 @@ private Manager manager;
 		//store the route. 
 		Stack<Point> route = this.manager.sm.nav.exportAndResetRoute();
 		
-		//go to the end
+		//go to the green zone
 		this.manager.sm.nav.addToRoute(new Point(Settings.greenZoneCoords[0]));
 		
 		//go back to previous state

commit 659e3d6d2e543ba22a1b253fe36ff6353048f06d
Author: RileyvanRyswyk <rileyvan@gmail.com>
Date:   Sun Nov 10 15:04:53 2013 -0500

    CollerPoller fix

diff --git a/src/hardwareAbstraction/ColorPoller.java b/src/hardwareAbstraction/ColorPoller.java
index 8db08ca..5d4faaa 100644
--- a/src/hardwareAbstraction/ColorPoller.java
+++ b/src/hardwareAbstraction/ColorPoller.java
@@ -15,7 +15,6 @@ public class ColorPoller implements TimerListener {
 	public ColorPoller() {
 		this.cs = Settings.frontColorSensor;
 		this.readings = new int[5];
-		this.poller = new Timer(poleRate, this);
 	}
 	
 	public void start() {
@@ -24,6 +23,7 @@ public class ColorPoller implements TimerListener {
 	}
 	
 	public void stop() {
+		this.poller.stop();
 		this.poller = null;
 	}
 

commit 3ab0d7d26920be0fa4afec395a166ca7b6f8f8ed
Author: RileyvanRyswyk <rileyvan@gmail.com>
Date:   Sun Nov 10 13:45:04 2013 -0500

    Navigation Fix

diff --git a/src/services/Navigation.java b/src/services/Navigation.java
index 4b40269..a15ce1f 100644
--- a/src/services/Navigation.java
+++ b/src/services/Navigation.java
@@ -207,6 +207,7 @@ public class Navigation implements TimerListener {
 	}
 	
 	public void addToRoute(Point xy) {
+		this.scannedAhead = false;
 		this.route.push(xy);
 	}
 }

commit 16df0944d8d7a18b67f6ae2756d025cf829898e6
Author: RileyvanRyswyk <rileyvan@gmail.com>
Date:   Sun Nov 10 11:58:03 2013 -0500

    Localization testing

diff --git a/src/launcher/Launcher.java b/src/launcher/Launcher.java
index 2316d7e..4b6d23c 100644
--- a/src/launcher/Launcher.java
+++ b/src/launcher/Launcher.java
@@ -3,6 +3,7 @@
  */
 package launcher;
 
+import utilities.Point;
 import controllers.State;
 import lejos.nxt.Button;
 import lejos.nxt.comm.RConsole;
@@ -44,7 +45,12 @@ public class Launcher {
 		
 		while(manager.cm.getState() == State.LOCALIZING) {
 			manager.um.nap(150);
-		}*/
+		}
+		
+		manager.sm.nav.addToRoute(new Point(0,0));
+		manager.sm.nav.turnToComplete(0);
+		
+		*/
 		
 		Button.waitForPress();
 	
diff --git a/src/services/Localization.java b/src/services/Localization.java
index 843151e..f986b15 100644
--- a/src/services/Localization.java
+++ b/src/services/Localization.java
@@ -166,7 +166,7 @@ public class Localization implements TimerListener {
 		
 		//update the odometer
 		manager.sm.odo.adjustPosition(0, 0, deltaTheta);
-		manager.cm.setState(State.SEARCH);
+		RConsole.println(manager.sm.odo.getPosition().toString());
 	}
 	
 	/**
@@ -198,6 +198,8 @@ public class Localization implements TimerListener {
 		double dTheta = (dThetaX + dThetaY) / 2.0;
 		
 		manager.sm.odo.adjustPosition(x, y, dTheta);
+		RConsole.println(manager.sm.odo.getPosition().toString());
+		manager.cm.setState(State.SEARCH);
 	}
 	
 	/**
diff --git a/src/services/Navigation.java b/src/services/Navigation.java
index e6f802c..4b40269 100644
--- a/src/services/Navigation.java
+++ b/src/services/Navigation.java
@@ -67,7 +67,7 @@ public class Navigation implements TimerListener {
 					// completing a turn, call the turnTo method
 					// otherwise we can adjust small angle errors by slowing
 					// one wheel down slightly
-					turnTo();
+					turnTo(dH);
 				} else if (Math.abs(dX) > 1 || Math.abs(dY) > 1) {
 					//scan ahead only once facing the correct orientation, then travelTo that destination.
 					if (!scannedAhead) {
@@ -132,7 +132,7 @@ public class Navigation implements TimerListener {
 
 	}
 
-	public void turnTo() {
+	public void turnTo(double dH) {
 
 		// if angle error greater than 0.6 deg
 		if (Math.abs(dH) >= 0.01) {
@@ -143,6 +143,21 @@ public class Navigation implements TimerListener {
 		}
 	}
 	
+	
+	public void turnToComplete(double angle) {
+		
+		angle = Angle.principleAngle(angle);
+		// set dH to the difference of theta and currentTheta adjust to [-PI, PI]
+		double dH = Angle.minimumAngle(currentPos.theta, angle);
+		
+		while(Math.abs(dH) > 0.01) {
+			dH = Angle.minimumAngle(currentPos.theta, angle);
+			turnTo(dH);
+			manager.um.nap(100);
+		}
+		
+	}
+	
 	public int calculateRotationSpeed(double dH) {
 		if (Math.abs(dH) > 0.01) {
 			// if error positive and greater than 0.2 rad -> max speed CCW
diff --git a/src/utilities/Settings.java b/src/utilities/Settings.java
index f10a154..9cff55c 100644
--- a/src/utilities/Settings.java
+++ b/src/utilities/Settings.java
@@ -31,7 +31,7 @@ public class Settings {
 	public static int role;
 	public static Point[] redZoneCoords;
 	public static Point[] greenZoneCoords;
-	public static StartingCorner startingCorner;
+	public static StartingCorner startingCorner = StartingCorner.BOTTOM_LEFT;
 	
 	public static final double LS_OFFSET = 15.0;
 	public static final int maxBlockCapacity = 1;

commit 301d077c51f80203bf18ab7d3f5b4e4721064f50
Author: RileyvanRyswyk <rileyvan@gmail.com>
Date:   Sun Nov 10 11:24:40 2013 -0500

    hardwareViewer export modification

diff --git a/src/services/HardwareViewer.java b/src/services/HardwareViewer.java
index bd50636..b47b944 100644
--- a/src/services/HardwareViewer.java
+++ b/src/services/HardwareViewer.java
@@ -60,10 +60,7 @@ public class HardwareViewer implements TimerListener {
 		int usL = usp.getUSReading(left);
 		int usC = usp.getUSReading(center);
 		int usR = usp.getUSReading(right);
-		RConsole.println("US poller readings:");
-		RConsole.println("\tLeft: " + usL);
-		RConsole.println("\tCent: " + usC);
-		RConsole.println("\tRight: " + usR);
+		RConsole.println(usL + ";" + usC + ";" + usR);
 	}
 	
 //	private void printLP() {

commit cd97374415c30da0728b24bd4e266d450e67c6db
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Sun Nov 10 01:34:26 2013 -0500

    Developed further the collect and dropoff controllers. Needed to
    implement a new state in order to avoid overlapping executions of a
    single activity. Settings and Point were updated for convenience.
    Navigation was updated to alter route.

diff --git a/src/controllers/Collect.java b/src/controllers/Collect.java
index 70d9336..e3a4283 100644
--- a/src/controllers/Collect.java
+++ b/src/controllers/Collect.java
@@ -1,5 +1,6 @@
 package controllers;
 
+import utilities.Settings;
 import hardwareAbstraction.Claw;
 import hardwareAbstraction.Forklift;
 import manager.Manager;
@@ -17,9 +18,14 @@ private Manager manager;
 	 * Maintains the singleton design of this system. 
 	 */
 	public void run() {
+		//pause the re-execution
+		manager.cm.setState(State.PAUSE);
 		Claw.grabObject();
 		Forklift.liftObject();
-		//TODO determine if the robot needs to drop off or search again. By default now it searches. 
-		manager.cm.setState(State.SEARCH);
+		manager.cm.setStored(manager.cm.getStored());
+		if(manager.cm.getStored() == Settings.maxBlockCapacity)
+			manager.cm.setState(State.DROP_OFF);
+		else
+			manager.cm.setState(State.SEARCH);
 	}
 }
diff --git a/src/controllers/DropOff.java b/src/controllers/DropOff.java
index 2291a3f..ee395ef 100644
--- a/src/controllers/DropOff.java
+++ b/src/controllers/DropOff.java
@@ -1,5 +1,9 @@
 package controllers;
 
+import java.util.Stack;
+
+import utilities.Point;
+import utilities.Settings;
 import manager.Manager;
 
 public class DropOff extends Controller {
@@ -11,5 +15,17 @@ private Manager manager;
 	}
 	
 	public void run() {
+		//pause the re-execution
+		manager.cm.setState(State.PAUSE);
+		
+		//store the route. 
+		Stack<Point> route = this.manager.sm.nav.exportAndResetRoute();
+		
+		//go to the end
+		this.manager.sm.nav.addToRoute(new Point(Settings.greenZoneCoords[0]));
+		
+		//go back to previous state
+		this.manager.sm.nav.setRoute(route);
+		this.manager.cm.setState(State.SEARCH);
 	}
 }
diff --git a/src/controllers/State.java b/src/controllers/State.java
index edf2d74..669624c 100644
--- a/src/controllers/State.java
+++ b/src/controllers/State.java
@@ -6,5 +6,5 @@ package controllers;
  *
  */
 public enum State {
-	SEARCH, RECOGNIZE, COLLECT, DROP_OFF, WALL_FOLLOWER, LOCALIZING
+	SEARCH, RECOGNIZE, COLLECT, DROP_OFF, WALL_FOLLOWER, LOCALIZING, PAUSE
 }
diff --git a/src/manager/ControllerManager.java b/src/manager/ControllerManager.java
index 2e3adcd..28b6a9c 100644
--- a/src/manager/ControllerManager.java
+++ b/src/manager/ControllerManager.java
@@ -18,6 +18,7 @@ public class ControllerManager implements TimerListener {
 
 	public Manager manager;
 	private State state; 
+	private int stored;
 	private Controller[] controllers; 
 	private Timer timer;
 	
@@ -25,6 +26,7 @@ public class ControllerManager implements TimerListener {
 	
 	public ControllerManager(Manager manager) {
 		this.manager = manager;
+		this.stored = 0;
 		this.timer = new Timer(UPDATE_PERIOD, this);
 		this.controllers = new Controller[]{new Search(manager), new Recognize(manager), new Collect(manager), new DropOff(manager), new WallFollower(manager)};
 	}
@@ -55,5 +57,15 @@ public class ControllerManager implements TimerListener {
 	public void setState(State state) {
 		this.state = state;
 	}
+
+	public int getStored() {
+		return stored;
+	}
+
+	public void setStored(int stored) {
+		this.stored = stored;
+	}
+	
+	
 	
 }
diff --git a/src/services/Navigation.java b/src/services/Navigation.java
index 97fd47c..e6f802c 100644
--- a/src/services/Navigation.java
+++ b/src/services/Navigation.java
@@ -87,11 +87,11 @@ public class Navigation implements TimerListener {
 		}
 	}
 	
-	private void pause() {
+	public void pause() {
 		this.time.stop();
 	}
 	
-	private void start() {
+	public void start() {
 		this.time.start();
 	}
 	
@@ -175,4 +175,23 @@ public class Navigation implements TimerListener {
 		return 0;
 	}
 
+	//accessors and mutators
+	public Stack<Point> getRoute() {
+		return route;
+	}
+
+	public void setRoute(Stack<Point> route) {
+		this.route = route;
+	}
+	
+	//useful methods used within dropoff. 
+	public Stack<Point> exportAndResetRoute() {
+		Stack<Point> route = this.route;
+		this.route = initializeRoute();
+		return route;
+	}
+	
+	public void addToRoute(Point xy) {
+		this.route.push(xy);
+	}
 }
diff --git a/src/utilities/Point.java b/src/utilities/Point.java
index c75fb48..cb1fc6d 100644
--- a/src/utilities/Point.java
+++ b/src/utilities/Point.java
@@ -9,6 +9,11 @@ public class Point  {
 		this.y = y;
 	}
 	
+	public Point(Point point) {
+		this.x = point.x;
+		this.y = point.y;
+	}
+	
 	public Point() {
 		this.x = Double.NaN;
 		this.y = Double.NaN;
diff --git a/src/utilities/Settings.java b/src/utilities/Settings.java
index d62a6ba..f10a154 100644
--- a/src/utilities/Settings.java
+++ b/src/utilities/Settings.java
@@ -34,5 +34,6 @@ public class Settings {
 	public static StartingCorner startingCorner;
 	
 	public static final double LS_OFFSET = 15.0;
+	public static final int maxBlockCapacity = 1;
 	
 }

commit d5026b78c0223fa049238190857dcd3b54542788
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Sun Nov 10 01:07:22 2013 -0500

    Added bluetooth results in settings. Now it is globally accessible in a
    logical place.

diff --git a/src/utilities/BluetoothTransmission.java b/src/utilities/BluetoothTransmission.java
index 7bba92c..7adb519 100644
--- a/src/utilities/BluetoothTransmission.java
+++ b/src/utilities/BluetoothTransmission.java
@@ -18,14 +18,10 @@ import lejos.nxt.comm.NXTConnection;
  */
 public class BluetoothTransmission {
 	static DataInputStream stream; 
-	static int role;
-	static int startingCorner;
-	static Point[] redZoneCoords;
-	static Point[] greenZoneCoords;
 	
 	public static void getBluetoothData() {
-		greenZoneCoords = new Point[4];
-		redZoneCoords = new Point[4];
+		Settings.greenZoneCoords = new Point[4];
+		Settings.redZoneCoords = new Point[4];
 		stream = new DataInputStream(getConnection());
 		getInformation();
 	}
@@ -38,22 +34,33 @@ public class BluetoothTransmission {
 	private static void getInformation() {
 		//TODO verify the input of the coordinates with the server. I am assuming the coordinates are sent as a series of 8 integers. The order is unknown. 
 		try {
-			role = stream.readInt();
+			Settings.role = stream.readInt();
 			char useless = stream.readChar();
-			startingCorner = stream.readInt();
-			for(int i = 0; i < greenZoneCoords.length; i++) {
+			int startingCorner = stream.readInt();
+			//TODO figure out which numbers correspond to which corners. And their values. 
+			switch(startingCorner) {
+			case 1 : Settings.startingCorner = StartingCorner.BOTTOM_LEFT; 
+			break;
+			case 2 : Settings.startingCorner = StartingCorner.BOTTOM_RIGHT; 
+			break;
+			case 3 : Settings.startingCorner = StartingCorner.TOP_LEFT; 
+			break;
+			case 4 : Settings.startingCorner = StartingCorner.TOP_RIGHT; 
+			break;
+			}
+			for(int i = 0; i < Settings.greenZoneCoords.length; i++) {
 				useless = stream.readChar();
 				int x = stream.readInt();
 				useless = stream.readChar();
 				int y = stream.readInt();
-				greenZoneCoords[i] = new Point(x,y);
+				Settings.greenZoneCoords[i] = new Point(x,y);
 			}
-			for(int i = 0; i < redZoneCoords.length; i++) {
+			for(int i = 0; i < Settings.redZoneCoords.length; i++) {
 				useless = stream.readChar();
 				int x = stream.readInt();
 				useless = stream.readChar();
 				int y = stream.readInt();
-				redZoneCoords[i] = new Point(x,y);
+				Settings.redZoneCoords[i] = new Point(x,y);
 			}
 		} catch (IOException e) {
 			catchBug("Bluetooth recieve failed: " + e.getMessage());
diff --git a/src/utilities/Settings.java b/src/utilities/Settings.java
index f248638..d62a6ba 100644
--- a/src/utilities/Settings.java
+++ b/src/utilities/Settings.java
@@ -28,7 +28,11 @@ public class Settings {
 	
 	public static final String NXTSlaveName = "NXT";
 	
+	public static int role;
+	public static Point[] redZoneCoords;
+	public static Point[] greenZoneCoords;
 	public static StartingCorner startingCorner;
+	
 	public static final double LS_OFFSET = 15.0;
 	
 }

commit d79fb5058e525f79ca39808f9bb95e18eed7f857
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Sun Nov 10 00:25:05 2013 -0500

    Implemented simple collection logic. Maintains state. Still needs work
    determining if "dropoff" or "search" must be called.

diff --git a/src/controllers/Collect.java b/src/controllers/Collect.java
index b0702ab..70d9336 100644
--- a/src/controllers/Collect.java
+++ b/src/controllers/Collect.java
@@ -1,5 +1,7 @@
 package controllers;
 
+import hardwareAbstraction.Claw;
+import hardwareAbstraction.Forklift;
 import manager.Manager;
 
 public class Collect extends Controller {
@@ -10,6 +12,14 @@ private Manager manager;
 		this.manager = manager;
 	}
 	
+	/**
+	 * This method grabs the object, lifts it and then tells the robot to Search again. 
+	 * Maintains the singleton design of this system. 
+	 */
 	public void run() {
+		Claw.grabObject();
+		Forklift.liftObject();
+		//TODO determine if the robot needs to drop off or search again. By default now it searches. 
+		manager.cm.setState(State.SEARCH);
 	}
 }
diff --git a/src/controllers/State.java b/src/controllers/State.java
index b37b2c2..edf2d74 100644
--- a/src/controllers/State.java
+++ b/src/controllers/State.java
@@ -1,5 +1,10 @@
 package controllers;
 
+/**
+ * The robot can only ever have one state at a time. Therefore, it maintains a singleton design pattern. The robot can only execute one "task" at a time. 
+ * @author Riley
+ *
+ */
 public enum State {
 	SEARCH, RECOGNIZE, COLLECT, DROP_OFF, WALL_FOLLOWER, LOCALIZING
 }
diff --git a/src/hardwareAbstraction/Forklift.java b/src/hardwareAbstraction/Forklift.java
index 21fe798..8c404ac 100644
--- a/src/hardwareAbstraction/Forklift.java
+++ b/src/hardwareAbstraction/Forklift.java
@@ -5,12 +5,24 @@ import utilities.Settings;
 
 public class Forklift {
 	static RemoteMotor lift = Settings.forkliftMotor;
-	static int value = 45; // 45 degrees. needs to be tested. 
+	static int distance = 15; // 15 cm upwards. needs to be tested. 
+	private static double radius = 1; //radius of "spool". Must be tested. 
 	
 	/**
 	 * This method lifts an object. Returns nothing
 	 */
 	public static void liftObject() {
-		lift.rotate(value);
+		lift.rotate(convertDistanceToAngle(distance));
+	}
+	
+	/**
+	 * This method turns a distance into an angle for the robot to turn. Takes as parameter the distance you want to lift. 
+	 * It is essential the radius of this class be calibrated. The radius is the radius of the "spool" the string winds onto.
+	 * The formula used is: d = 2*pi*radius*(angle)/360 ==> angle = 360 * d / (2*pi*radius).
+	 * @param distance
+	 * @return
+	 */
+	private static int convertDistanceToAngle(int distance) {
+		return (int)( (distance * 360) / (2 * Math.PI * radius) );
 	}
 }

commit 9fb7aa62e35caa0606800423ed316e51bdeddbf9
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Sat Nov 9 23:55:42 2013 -0500

    Made protoype of Claw and Forklift. Simple methods. Must be adjusted

diff --git a/src/hardwareAbstraction/Claw.java b/src/hardwareAbstraction/Claw.java
index 3dcadad..28b02f7 100644
--- a/src/hardwareAbstraction/Claw.java
+++ b/src/hardwareAbstraction/Claw.java
@@ -1,5 +1,17 @@
 package hardwareAbstraction;
 
+import utilities.Settings;
+import lejos.nxt.remote.RemoteMotor;
+
 public class Claw {
+	static RemoteMotor claw = Settings.clawMotor;
+	static int value = 45; // 45 degrees. needs to be tested. 
+	
+	/**
+	 * This method grabs an object. Returns nothing
+	 */
+	public static void grabObject() {
+		claw.rotate(value);
+	}
 
 }
diff --git a/src/hardwareAbstraction/Forklift.java b/src/hardwareAbstraction/Forklift.java
index 38f5152..21fe798 100644
--- a/src/hardwareAbstraction/Forklift.java
+++ b/src/hardwareAbstraction/Forklift.java
@@ -1,5 +1,16 @@
 package hardwareAbstraction;
 
-public class Forklift {
+import lejos.nxt.remote.RemoteMotor;
+import utilities.Settings;
 
+public class Forklift {
+	static RemoteMotor lift = Settings.forkliftMotor;
+	static int value = 45; // 45 degrees. needs to be tested. 
+	
+	/**
+	 * This method lifts an object. Returns nothing
+	 */
+	public static void liftObject() {
+		lift.rotate(value);
+	}
 }

commit fae15dc28906127ce7f66dee5ff3641950a31975
Author: RileyvanRyswyk <rileyvan@gmail.com>
Date:   Sat Nov 9 21:09:13 2013 -0500

    Angle.java fixed
    
    Hopefully for the last time.

diff --git a/src/launcher/Launcher.java b/src/launcher/Launcher.java
index 220b59c..2316d7e 100644
--- a/src/launcher/Launcher.java
+++ b/src/launcher/Launcher.java
@@ -30,7 +30,7 @@ public class Launcher {
 		
 		Manager manager = new Manager();
 		
-		manager.hm.drive.setSpeeds(300, 0);
+		manager.hm.drive.setSpeeds(10, 0);
 		int count = 0;
 		while(count < 80) {
 			RConsole.println(manager.sm.odo.getPosition().toString());
diff --git a/src/utilities/Angle.java b/src/utilities/Angle.java
index 209bfeb..6f88d25 100644
--- a/src/utilities/Angle.java
+++ b/src/utilities/Angle.java
@@ -16,10 +16,11 @@ public class Angle {
 	 * @return
 	 */
 	public static double principleAngle(double angle) {		
-		if (angle < 0.0)
-			angle = 2*Math.PI + (angle % 2*Math.PI);
+		if (angle < 0.0) {
+			angle = 2*Math.PI + (angle % (2*Math.PI));
+		}
 		
-		return angle % 2*Math.PI;
+		return angle % (2*Math.PI);
 	}
 	/**
 	 * Returns the minimum angle

commit a0b85abdb9b0aac9d971f8f66e5daa0256a49c94
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Sat Nov 9 20:58:04 2013 -0500

    Created a ultrasonicPoller as per request from Riley. To be tested.
    Prints to RConsole using bluetooth. To be removed when final project is
    to be handed in.

diff --git a/src/hardwareAbstraction/LinePoller.java b/src/hardwareAbstraction/LinePoller.java
index 6a344a3..ca2623c 100644
--- a/src/hardwareAbstraction/LinePoller.java
+++ b/src/hardwareAbstraction/LinePoller.java
@@ -21,7 +21,7 @@ public class LinePoller implements TimerListener {
 	private boolean[] sensorEnteringLine;
 	private ColorSensor[] sensor = new ColorSensor[2];
 	private Timer timer;
-	private int[][] readings;
+	public int[][] readings;
 	private int left = 0;
 	private int right = 1;
 	
diff --git a/src/manager/HardwareManager.java b/src/manager/HardwareManager.java
index 6ecb659..2759aa8 100644
--- a/src/manager/HardwareManager.java
+++ b/src/manager/HardwareManager.java
@@ -1,8 +1,5 @@
 package manager;
 
-import lejos.nxt.ColorSensor;
-import lejos.nxt.NXTRegulatedMotor;
-import lejos.nxt.UltrasonicSensor;
 import hardwareAbstraction.*;
 
 public class HardwareManager {
diff --git a/src/manager/ServiceManager.java b/src/manager/ServiceManager.java
index 2585e2a..cf12c52 100644
--- a/src/manager/ServiceManager.java
+++ b/src/manager/ServiceManager.java
@@ -11,6 +11,7 @@ public class ServiceManager {
 	public ObstacleAvoidance obstacleAvoidance;
 	public Mapper mapper;
 	public Localization localization;
+	public HardwareViewer hwView;
 	
 	public ServiceManager(Manager manager) {
 		this.manager = manager;
@@ -20,5 +21,6 @@ public class ServiceManager {
 		this.obstacleAvoidance = new ObstacleAvoidance(manager);
 		this.mapper = new Mapper(manager);
 		this.localization = new Localization(manager);
+		this.hwView = new HardwareViewer(manager);
 	}
 }
diff --git a/src/services/HardwareViewer.java b/src/services/HardwareViewer.java
new file mode 100644
index 0000000..bd50636
--- /dev/null
+++ b/src/services/HardwareViewer.java
@@ -0,0 +1,80 @@
+package services;
+
+import hardwareAbstraction.*;
+import lejos.nxt.comm.RConsole;
+import lejos.util.Timer;
+import lejos.util.TimerListener;
+import manager.*;
+
+
+/**
+ * This class takes hardwareAbstractions and prints them to screen.
+ * Currently supports line poller and USPoller. 
+ * Easily extended to support colorPoller.
+ * Will be removed for final project.
+ * 
+ * THE CALL IN SERVICE MANAGER MUST BE REMOVED WHEN FINAL PROJECT IS TO BE HANDED IN.
+ * @author danielle
+ *
+ */
+public class HardwareViewer implements TimerListener {
+	public UltrasonicPoller usp;
+//	public LinePoller lp;
+	private int pollRate;
+	private Timer refresher;
+
+	public HardwareViewer(Manager manager) {
+		//get console
+		RConsole.openBluetooth(20000);
+		
+		//get hardware
+		this.usp = manager.hm.ultrasonicPoller;
+//		this.lp = manager.hm.linePoller;
+		
+		
+		//begin printing now
+		this.pollRate = 75;
+		this.start(pollRate);
+	}
+	
+	@Override
+	public void timedOut() {
+		printUS();
+//		printLP();
+	}
+	
+	public void start(int pollRate) {
+		this.refresher = new Timer(pollRate, this);
+		this.refresher.start();
+	}
+	
+	public void stop() {
+		this.refresher.stop();
+		this.refresher = null;
+	}
+
+	private void printUS() {
+		int left = 0;
+		int center = 1;
+		int right = 2; 
+		int usL = usp.getUSReading(left);
+		int usC = usp.getUSReading(center);
+		int usR = usp.getUSReading(right);
+		RConsole.println("US poller readings:");
+		RConsole.println("\tLeft: " + usL);
+		RConsole.println("\tCent: " + usC);
+		RConsole.println("\tRight: " + usR);
+	}
+	
+//	private void printLP() {
+//		int[][] readings = lp.readings;
+//		int left = 0;
+//		int right = 1;
+//		int lpL = readings[left][0];
+//		int lpR = readings[right][0];
+//		RConsole.println("LP readings for LEFT and RIGHT");
+//		RConsole.println("\tLeft: " + lpL);
+//		RConsole.println("\tRight: " + lpR);
+//	}
+	
+}

commit 5f1ee104eb0ca3cd18d420b1cfac92c7608693e7
Author: RileyvanRyswyk <rileyvan@gmail.com>
Date:   Sat Nov 9 20:24:11 2013 -0500

    fixed angle class problem

diff --git a/src/utilities/Angle.java b/src/utilities/Angle.java
index 882f2a9..209bfeb 100644
--- a/src/utilities/Angle.java
+++ b/src/utilities/Angle.java
@@ -17,9 +17,9 @@ public class Angle {
 	 */
 	public static double principleAngle(double angle) {		
 		if (angle < 0.0)
-			angle = 2*Math.PI + (angle % Math.PI);
+			angle = 2*Math.PI + (angle % 2*Math.PI);
 		
-		return angle % Math.PI;
+		return angle % 2*Math.PI;
 	}
 	/**
 	 * Returns the minimum angle

commit 21fba8028fc3a49e7a54bb19030f5aa31e520e80
Author: RileyvanRyswyk <rileyvan@gmail.com>
Date:   Sat Nov 9 20:15:48 2013 -0500

    Odo test

diff --git a/src/hardwareAbstraction/Drive.java b/src/hardwareAbstraction/Drive.java
index a8f2a42..2fb372a 100644
--- a/src/hardwareAbstraction/Drive.java
+++ b/src/hardwareAbstraction/Drive.java
@@ -31,7 +31,7 @@ public class Drive {
 		leftTacho = leftMotor.getTachoCount();
 		rightTacho = rightMotor.getTachoCount();
 		
-		data[0] = (leftTacho * LEFT_RADIUS + rightTacho * RIGHT_RADIUS) *	Math.PI / 360.0;
+		data[0] = (leftTacho * LEFT_RADIUS + rightTacho * RIGHT_RADIUS) * Math.PI / 360.0;
 		data[1] = (leftTacho * LEFT_RADIUS - rightTacho * RIGHT_RADIUS) / WIDTH * Math.PI / 180.0;
 	}
 	
diff --git a/src/launcher/Launcher.java b/src/launcher/Launcher.java
index 625636b..220b59c 100644
--- a/src/launcher/Launcher.java
+++ b/src/launcher/Launcher.java
@@ -31,7 +31,12 @@ public class Launcher {
 		Manager manager = new Manager();
 		
 		manager.hm.drive.setSpeeds(300, 0);
-		manager.um.nap(8000);
+		int count = 0;
+		while(count < 80) {
+			RConsole.println(manager.sm.odo.getPosition().toString());
+			manager.um.nap(100);
+			count++;
+		}
 		manager.hm.drive.stop();
 		RConsole.println(manager.sm.odo.getPosition().toString());
 		
diff --git a/src/services/Odometer.java b/src/services/Odometer.java
index bf44803..85ea9c6 100644
--- a/src/services/Odometer.java
+++ b/src/services/Odometer.java
@@ -50,8 +50,8 @@ public class Odometer implements TimerListener {
 			theta -= dDH[1];
 			theta = Angle.principleAngle(theta);
 			
-			x -= dDH[0] * Math.cos(theta);
-			y -= dDH[0] * Math.sin(theta);
+			x += dDH[0] * Math.cos(theta);
+			y += dDH[0] * Math.sin(theta);
 		}
 		
 		//update old displacement and heading

commit c7aa7cfc6c7f5f43e676e87948440fe1f60924f9
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Sat Nov 9 20:04:12 2013 -0500

    Created a protoype of a bluetoothTransmission class. It is implemented
    using a static method that can be called from the main. Will have to be
    reconfigured and tested however.

diff --git a/src/utilities/BluetoothTransmission.java b/src/utilities/BluetoothTransmission.java
index 0572a19..7bba92c 100644
--- a/src/utilities/BluetoothTransmission.java
+++ b/src/utilities/BluetoothTransmission.java
@@ -3,10 +3,80 @@
  */
 package utilities;
 
+import java.io.DataInputStream;
+import java.io.IOException;
+
+import lejos.nxt.LCD;
+import lejos.nxt.comm.BTConnection;
+import lejos.nxt.comm.Bluetooth;
+import lejos.nxt.comm.NXTConnection;
+
 /**
+ * This class will open a new 
  * @author Riley
  *
  */
 public class BluetoothTransmission {
+	static DataInputStream stream; 
+	static int role;
+	static int startingCorner;
+	static Point[] redZoneCoords;
+	static Point[] greenZoneCoords;
+	
+	public static void getBluetoothData() {
+		greenZoneCoords = new Point[4];
+		redZoneCoords = new Point[4];
+		stream = new DataInputStream(getConnection());
+		getInformation();
+	}
+	
+	private static DataInputStream getConnection() {
+		BTConnection btc = Bluetooth.waitForConnection(0, NXTConnection.LCP);
+		return btc.openDataInputStream();
+	}
+	
+	private static void getInformation() {
+		//TODO verify the input of the coordinates with the server. I am assuming the coordinates are sent as a series of 8 integers. The order is unknown. 
+		try {
+			role = stream.readInt();
+			char useless = stream.readChar();
+			startingCorner = stream.readInt();
+			for(int i = 0; i < greenZoneCoords.length; i++) {
+				useless = stream.readChar();
+				int x = stream.readInt();
+				useless = stream.readChar();
+				int y = stream.readInt();
+				greenZoneCoords[i] = new Point(x,y);
+			}
+			for(int i = 0; i < redZoneCoords.length; i++) {
+				useless = stream.readChar();
+				int x = stream.readInt();
+				useless = stream.readChar();
+				int y = stream.readInt();
+				redZoneCoords[i] = new Point(x,y);
+			}
+		} catch (IOException e) {
+			catchBug("Bluetooth recieve failed: " + e.getMessage());
+		}
 
+	}
+	
+	/**
+	 * The static helper method here just exits the system when commanded. It
+	 * displays a message on the NXT for the user.
+	 * <p>
+	 * @param bug
+	 *            A String object with the message on screen.
+	 */
+	public static void catchBug(String bug) {
+		LCD.clear();
+		LCD.drawString(bug, 0, 0);
+		try {
+			Thread.sleep(5000);
+		} catch (InterruptedException e) {
+			// No bug expected here ever.
+		}
+		LCD.clear();
+		System.exit(1);
+	}
 }

commit 61dbb95efe3673d3666fbb1d6e498fdbd3286eac
Author: RileyvanRyswyk <rileyvan@gmail.com>
Date:   Sat Nov 9 19:58:56 2013 -0500

    Odometer fix

diff --git a/src/hardwareAbstraction/Drive.java b/src/hardwareAbstraction/Drive.java
index 863a082..a8f2a42 100644
--- a/src/hardwareAbstraction/Drive.java
+++ b/src/hardwareAbstraction/Drive.java
@@ -43,9 +43,9 @@ public class Drive {
 	public void setSpeeds(double forwardSpeed, double rotationalSpeed) {
 		double leftSpeed, rightSpeed;
 
-		leftSpeed = -(forwardSpeed + rotationalSpeed * WIDTH * Math.PI / 360.0) *
+		leftSpeed = (forwardSpeed + rotationalSpeed * WIDTH * Math.PI / 360.0) *
 				180.0 / (LEFT_RADIUS * Math.PI);
-		rightSpeed = -(forwardSpeed - rotationalSpeed * WIDTH * Math.PI / 360.0) *
+		rightSpeed = (forwardSpeed - rotationalSpeed * WIDTH * Math.PI / 360.0) *
 				180.0 / (RIGHT_RADIUS * Math.PI);
 
 		
diff --git a/src/services/Odometer.java b/src/services/Odometer.java
index 85ea9c6..bf44803 100644
--- a/src/services/Odometer.java
+++ b/src/services/Odometer.java
@@ -50,8 +50,8 @@ public class Odometer implements TimerListener {
 			theta -= dDH[1];
 			theta = Angle.principleAngle(theta);
 			
-			x += dDH[0] * Math.cos(theta);
-			y += dDH[0] * Math.sin(theta);
+			x -= dDH[0] * Math.cos(theta);
+			y -= dDH[0] * Math.sin(theta);
 		}
 		
 		//update old displacement and heading

commit 930cf763771cb891074514a99f91193f17a7a43f
Author: RileyvanRyswyk <rileyvan@gmail.com>
Date:   Sat Nov 9 19:54:01 2013 -0500

    Drive direction fix

diff --git a/src/hardwareAbstraction/Drive.java b/src/hardwareAbstraction/Drive.java
index a8f2a42..863a082 100644
--- a/src/hardwareAbstraction/Drive.java
+++ b/src/hardwareAbstraction/Drive.java
@@ -43,9 +43,9 @@ public class Drive {
 	public void setSpeeds(double forwardSpeed, double rotationalSpeed) {
 		double leftSpeed, rightSpeed;
 
-		leftSpeed = (forwardSpeed + rotationalSpeed * WIDTH * Math.PI / 360.0) *
+		leftSpeed = -(forwardSpeed + rotationalSpeed * WIDTH * Math.PI / 360.0) *
 				180.0 / (LEFT_RADIUS * Math.PI);
-		rightSpeed = (forwardSpeed - rotationalSpeed * WIDTH * Math.PI / 360.0) *
+		rightSpeed = -(forwardSpeed - rotationalSpeed * WIDTH * Math.PI / 360.0) *
 				180.0 / (RIGHT_RADIUS * Math.PI);
 
 		

commit 442d5e81b2e90eeae4532fb4c394f62d43e72525
Author: RileyvanRyswyk <rileyvan@gmail.com>
Date:   Sat Nov 9 19:07:52 2013 -0500

    Odometer Tweaking

diff --git a/src/launcher/Launcher.java b/src/launcher/Launcher.java
index a0cf427..625636b 100644
--- a/src/launcher/Launcher.java
+++ b/src/launcher/Launcher.java
@@ -30,11 +30,16 @@ public class Launcher {
 		
 		Manager manager = new Manager();
 		
-		manager.sm.localization.start();
+		manager.hm.drive.setSpeeds(300, 0);
+		manager.um.nap(8000);
+		manager.hm.drive.stop();
+		RConsole.println(manager.sm.odo.getPosition().toString());
+		
+		/*manager.sm.localization.start();
 		
 		while(manager.cm.getState() == State.LOCALIZING) {
 			manager.um.nap(150);
-		}
+		}*/
 		
 		Button.waitForPress();
 	
diff --git a/src/services/Navigation.java b/src/services/Navigation.java
index 0162a1a..97fd47c 100644
--- a/src/services/Navigation.java
+++ b/src/services/Navigation.java
@@ -53,7 +53,6 @@ public class Navigation implements TimerListener {
 		if (manager.cm.getState() == State.SEARCH
 				|| manager.cm.getState() == State.DROP_OFF) {
 		
-			
 			if (route.empty()) {
 				// nothing is done
 			} else {

commit 50d88f6abdc5fa9690bffcf3964c97811fb9a577
Author: RileyvanRyswyk <rileyvan@gmail.com>
Date:   Sat Nov 9 18:22:05 2013 -0500

    Navigation
    
    Remove exception caused by route.peek() when route is empty

diff --git a/src/services/Navigation.java b/src/services/Navigation.java
index 73a0b45..0162a1a 100644
--- a/src/services/Navigation.java
+++ b/src/services/Navigation.java
@@ -53,10 +53,11 @@ public class Navigation implements TimerListener {
 		if (manager.cm.getState() == State.SEARCH
 				|| manager.cm.getState() == State.DROP_OFF) {
 		
-			nextDestination = route.peek();
-			if (nextDestination == null) {
+			
+			if (route.empty()) {
 				// nothing is done
 			} else {
+				nextDestination = route.peek();
 				// if navigation must be done
 			
 				// update the new headings to travel to

commit 3209a5cbc57e23973c507bad491686ba0f1125d1
Author: RileyvanRyswyk <rileyvan@gmail.com>
Date:   Sat Nov 9 18:17:39 2013 -0500

    The second half

diff --git a/.gitignore b/.gitignore
index bde72a7..101a3c4 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,4 +1,6 @@
 /bin
 *.class
 *.classpath
-*.gitignore
\ No newline at end of file
+*.gitignore
+*.nxj
+*.nxd
diff --git a/src/controllers/State.java b/src/controllers/State.java
index af5c4c3..b37b2c2 100644
--- a/src/controllers/State.java
+++ b/src/controllers/State.java
@@ -1,5 +1,5 @@
 package controllers;
 
 public enum State {
-	SEARCH, RECOGNIZE, COLLECT, DROP_OFF, WALL_FOLLOWER
+	SEARCH, RECOGNIZE, COLLECT, DROP_OFF, WALL_FOLLOWER, LOCALIZING
 }
diff --git a/src/hardwareAbstraction/Drive.java b/src/hardwareAbstraction/Drive.java
index c2ddc49..a8f2a42 100644
--- a/src/hardwareAbstraction/Drive.java
+++ b/src/hardwareAbstraction/Drive.java
@@ -15,7 +15,7 @@ public class Drive {
 	
 	public static final double LEFT_RADIUS = 2.11;
 	public static final double RIGHT_RADIUS = 2.11;
-	public static final double WIDTH = 14.92;
+	public static final double WIDTH = 15.00;
 	
 	public Drive() {
 		leftMotor = Settings.leftDriveMotor;
diff --git a/src/manager/ControllerManager.java b/src/manager/ControllerManager.java
index 4e8f0a5..2e3adcd 100644
--- a/src/manager/ControllerManager.java
+++ b/src/manager/ControllerManager.java
@@ -30,7 +30,7 @@ public class ControllerManager implements TimerListener {
 	}
 	
 	public void start() {
-		state = State.SEARCH;
+		state = State.LOCALIZING;
 		timer.start();
 	}
 	
diff --git a/src/manager/Manager.java b/src/manager/Manager.java
index 18a88c2..ce775bb 100644
--- a/src/manager/Manager.java
+++ b/src/manager/Manager.java
@@ -1,5 +1,7 @@
 package manager;
 
+import lejos.nxt.comm.RConsole;
+
 public class Manager {
 	
 	public UtilityManager um;
@@ -8,9 +10,16 @@ public class Manager {
 	public HardwareManager hm;	
 
 	public Manager() {
+		RConsole.println("initializing");
 		this.um = new UtilityManager(this);
-		this.cm = new ControllerManager(this);
-		this.sm = new ServiceManager(this);
+		RConsole.println("um");
 		this.hm = new HardwareManager(this);
+		RConsole.println("hm");
+		this.sm = new ServiceManager(this);
+		RConsole.println("sm");
+		this.cm = new ControllerManager(this);
+		RConsole.println("ControllerManager");
+		
+		
 	}
 }
diff --git a/src/services/Navigation.java b/src/services/Navigation.java
index f9a64c5..73a0b45 100644
--- a/src/services/Navigation.java
+++ b/src/services/Navigation.java
@@ -50,13 +50,15 @@ public class Navigation implements TimerListener {
 
 	@Override
 	public void timedOut() {
-		nextDestination = route.peek();
-		if (nextDestination == null) {
-			// nothing is done
-		} else {
-			// if navigation must be done
-			if (manager.cm.getState() == State.SEARCH
-					|| manager.cm.getState() == State.DROP_OFF) {
+		if (manager.cm.getState() == State.SEARCH
+				|| manager.cm.getState() == State.DROP_OFF) {
+		
+			nextDestination = route.peek();
+			if (nextDestination == null) {
+				// nothing is done
+			} else {
+				// if navigation must be done
+			
 				// update the new headings to travel to
 				setupDeltaPositonAndHeading();
 				// see if we need to make a big turn
diff --git a/src/utilities/Communicator.java b/src/utilities/Communicator.java
index e9ccab8..dd23de4 100644
--- a/src/utilities/Communicator.java
+++ b/src/utilities/Communicator.java
@@ -4,6 +4,7 @@ import java.io.IOException;
 
 import lejos.nxt.LCD;
 import lejos.nxt.UltrasonicSensor;
+import lejos.nxt.comm.RConsole;
 import lejos.nxt.comm.RS485;
 import lejos.nxt.remote.RemoteNXT;
 
@@ -31,14 +32,14 @@ public class Communicator {
 		}
 
 		LCD.clear();
-
+		
 		Settings.forkliftMotor = nxt.A;
-		Settings.clawMotor = nxt.B;
-		Settings.ultrasonicMotor = nxt.C;
-
-		Settings.rightUltrasonic = new UltrasonicSensor(nxt.S3);
-		Settings.centerUltrasonic = new UltrasonicSensor(nxt.S2);
-		Settings.rightUltrasonic = new UltrasonicSensor(nxt.S1);
+		Settings.clawMotor = nxt.C;
+		Settings.ultrasonicMotor = nxt.B;
+		RConsole.println("Connected");
+		Settings.leftUltrasonic = new UltrasonicSensor(nxt.S3);
+		Settings.centerUltrasonic = new UltrasonicSensor(nxt.S1);
+		Settings.rightUltrasonic = new UltrasonicSensor(nxt.S2);
 	}
 
 	/**
diff --git a/src/utilities/Responder.java b/src/utilities/Responder.java
index 3cc079a..af7d564 100644
--- a/src/utilities/Responder.java
+++ b/src/utilities/Responder.java
@@ -1,5 +1,6 @@
 package utilities;
 
+import lejos.nxt.LCD;
 import lejos.nxt.comm.LCPResponder;
 import lejos.nxt.comm.NXTCommConnector;
 import lejos.nxt.comm.RS485;
@@ -37,6 +38,7 @@ public class Responder {
 	 */
 	
 	public static void main(String[] args) {
+		LCD.drawString("Connecting", 1, 1);
 		ResponderTool resp = new ResponderTool(RS485.getConnector());
 		resp.start();
 		try {
@@ -44,6 +46,7 @@ public class Responder {
 		} catch (InterruptedException e) {
 			Communicator.catchBug("The responder failed in the Responder.java class " + e.getMessage());
 		}
+		LCD.drawString("Connected", 2, 2);
     }
 	
 }
\ No newline at end of file

commit 08074a31deedd14a61e51a98e8f106c757e22681
Author: RileyvanRyswyk <rileyvan@gmail.com>
Date:   Sat Nov 9 13:23:33 2013 -0500

    Localization + bug fixes

diff --git a/src/hardwareAbstraction/LinePoller.java b/src/hardwareAbstraction/LinePoller.java
index 1691318..6a344a3 100644
--- a/src/hardwareAbstraction/LinePoller.java
+++ b/src/hardwareAbstraction/LinePoller.java
@@ -1,20 +1,112 @@
 package hardwareAbstraction;
 
-public class LinePoller {
+import lejos.nxt.ColorSensor;
+import lejos.nxt.Sound;
+import lejos.util.Timer;
+import lejos.util.TimerListener;
+import utilities.Settings;
 
-	private boolean rightSensorOnLine;
-	private boolean leftSensorOnLine;
+/**
+ * Detects grid lines with two rear floor facing color sensors
+ * other threads should call enteringLine to know when a new line has been detected
+ * @author Riley
+ *
+ */
+
+public class LinePoller implements TimerListener {
+
+	private final int UPDATE_PERIOD = 15;
+	private final int THRESHOLD = 40;
+	private boolean[] sensorOnLine;
+	private boolean[] sensorEnteringLine;
+	private ColorSensor[] sensor = new ColorSensor[2];
+	private Timer timer;
+	private int[][] readings;
+	private int left = 0;
+	private int right = 1;
+	
+	public LinePoller() {
+		sensor[right] = Settings.rearRightColorSensor;
+		sensor[left] = Settings.rearLeftColorSensor;
+		readings = new int[2][4];
+		sensorOnLine = new boolean[]{false, false};
+		sensorEnteringLine = new boolean[]{false, false};
+		timer = new Timer(UPDATE_PERIOD, this);
+		sensor[right].setFloodlight(0);
+		sensor[left].setFloodlight(0);
+	}
 	
-	public int getFilteredData(boolean rightSensor) {
-		return 1;
+	/**
+	 * Starts line polling
+	 */
+	public void start() {		
+		//Populate Readings Array
+		addReading(left, sensor[left].getRawLightValue()/2);
+		addReading(right, sensor[right].getRawLightValue()/2);
+		addReading(left, sensor[left].getRawLightValue()/2);
+		addReading(right, sensor[right].getRawLightValue()/2);
+		addReading(left, sensor[left].getRawLightValue()/2);
+		addReading(right, sensor[right].getRawLightValue()/2);
+		addReading(left, sensor[left].getRawLightValue()/2);
+		addReading(right, sensor[right].getRawLightValue()/2);
+		
+		timer.start();
 	}
 	
-	public boolean onLine(boolean rightSensor) {
-		return (rightSensor) ? rightSensorOnLine : leftSensorOnLine;
+	public void timedOut() {
+		addReading(left, sensor[left].getRawLightValue()/2);
+		addReading(right, sensor[right].getRawLightValue()/2);
+		
+		detectLine(right);
+		detectLine(left);
+		
 	}
 	
-	public boolean enteringLine(boolean rightSensor) {
-		return true;
+	private void addReading(int sensor, int reading) {
+		readings[sensor][3] = readings[sensor][2];
+		readings[sensor][2] = readings[sensor][1];
+		readings[sensor][1] = readings[sensor][0];
+		readings[sensor][0] = reading;
+	}
+	
+	/**
+	 * Filters and differences the data
+	 * @param sensor
+	 */
+	private void detectLine(int sensor) {
+		int result;
+		
+		// Smooth and difference
+		result = -readings[sensor][3] - readings[sensor][2] + readings[sensor][1] + readings[sensor][0];
+		
+		//if not currently on a line and filter result is less than -45 we just enter a line			
+		if(!sensorOnLine[sensor] && result < -THRESHOLD) {
+			sensorOnLine[sensor] = true;
+			sensorEnteringLine[sensor] = true;
+			//alert us with a beep that a line was detected
+			Sound.beep();
+		}
+		//if we are on a line and filter result > 45 we have now left the line
+		else if(sensorOnLine[sensor] && result > THRESHOLD) {
+			sensorOnLine[sensor] = false;
+			//in the event that no other thread was running at the time
+			sensorEnteringLine[sensor] = false;
+		}
+	}
+		
+	/**
+	 * Returns true if the sensor has just detected a black line
+	 * 
+	 * @param sensor | left = 0 & right = 1
+	 * @return
+	 */
+	public boolean enteringLine(int sensor) {
+		if(sensorEnteringLine[sensor]) {
+			//reset so the line is only counted once;
+			sensorEnteringLine[sensor] = false;
+			return true;
+		}
+		return false;
 	}
 	
 }
diff --git a/src/hardwareAbstraction/UltrasonicPoller.java b/src/hardwareAbstraction/UltrasonicPoller.java
index 2a0355e..a6e279c 100644
--- a/src/hardwareAbstraction/UltrasonicPoller.java
+++ b/src/hardwareAbstraction/UltrasonicPoller.java
@@ -1,8 +1,8 @@
 package hardwareAbstraction;
 
-import java.util.Arrays;
-
+import utilities.Settings;
 import lejos.nxt.UltrasonicSensor;
+import lejos.nxt.comm.RConsole;
 import lejos.util.Timer;
 import lejos.util.TimerListener;
 
@@ -10,19 +10,32 @@ import lejos.util.TimerListener;
  * wrapped in a poller class which will now handle the returned values and the
  * polling of that sensor
  * <p>
- * @author danielle
+ * @author danielle, Riley
  */
 public class UltrasonicPoller implements TimerListener {
-	private UltrasonicSensor[] us = {utilities.Settings.leftUltrasonic, utilities.Settings.centerUltrasonic, utilities.Settings.rightUltrasonic};
+	private UltrasonicSensor[] us =  new UltrasonicSensor[3];
 	public int pollRate;
 	private Timer poller;
 	private int readings[][];
 	private boolean running = false;
+	private int left = 0;
+	private int center = 1;
+	private int right = 2;
+	private int counter;
 
 	// TODO figure out what exactly this constructor should be.
 	public UltrasonicPoller() {
-		this.pollRate = 250;
+		us[left] = Settings.leftUltrasonic;
+		us[center] = Settings.centerUltrasonic;
+		us[right] = Settings.rightUltrasonic;
+
+		this.pollRate = 25;
 		this.readings = new int[3][5];
+		
+		us[left].off();
+		us[center].off();
+		us[right].off();
+		
 		start();
 	}
 
@@ -30,15 +43,18 @@ public class UltrasonicPoller implements TimerListener {
 	 */
 	@Override
 	public void timedOut() {
-		//ping left sensor
-		us[0].ping();
-		addReading(us[0].getDistance(), 0);
-		// ping center sensor
-		us[1].ping();
-		addReading(us[1].getDistance(), 1);
-		//ping right sensor
-		us[2].ping();
-		addReading(us[2].getDistance(), 2);
+		
+		if(counter == left) {
+			pingUS(left);
+		} else if(counter == center) {
+			pingUS(center);
+		} else {
+			pingUS(right);
+		}
+		
+		counter++;
+		//keep the counter between 0 - 2
+		counter = counter % 3;
 	}
 
 	/**
@@ -46,6 +62,13 @@ public class UltrasonicPoller implements TimerListener {
 	 * the reading again.
 	 */
 	public void start() {
+		counter = 0;
+		//for filtering purposes
+		readings[2][4] = -1;
+		readings[2][3] = -1;
+		readings[2][2] = -1;
+		readings[2][1] = -1;
+		readings[2][0] = -1;
 		this.poller = new Timer(pollRate, this);
 		this.poller.start();
 		running = true;
@@ -60,11 +83,41 @@ public class UltrasonicPoller implements TimerListener {
 		running = false;
 	}
 	
+	/**
+	 * Returns the filtered data for the sensor (median filtering)
+	 * @param sensor
+	 * @return
+	 */
 	public int getUSReading(int sensor) {
-		return 20;
+		
+		// makes sure readings array is full of values so we have enough to filter with
+		if(readings[2][4] > -1) {
+			
+			//initialize vars
+			int size = 5;
+			int[] usReadingsSorted = new int[5];
+			//Copy array
+			System.arraycopy(readings[sensor], 0, usReadingsSorted, 0, 5);
+
+			//sort the values: lowest to highest
+			for(int i=0; i<size; i++) {
+				for(int j=i+1; j<size;j++) {
+					if(usReadingsSorted[i] > usReadingsSorted[j]) {
+						int temp = usReadingsSorted[i];
+						usReadingsSorted[i] = usReadingsSorted[j];
+						usReadingsSorted[j] = temp;					
+					}
+				}
+			}
+			
+			//return the median
+			return usReadingsSorted[2];			
+			
+		} else {
+			return readings[sensor][0];
+		}
 	}
 	
-
 	/**
 	 * gets the lowest reading in the ultrasonicPoller at that time. Readings
 	 * are not taken temporarily as they are not needed;
@@ -96,9 +149,27 @@ public class UltrasonicPoller implements TimerListener {
 		return minValue;
 
 	}
+	
+	/**
+	 * Pings ultrasonic sensor and records the result in readings
+	 */
+	private void pingUS(int sensor) {
+		int distance;
+
+		// do a ping
+		us[sensor].ping();
+		
+		// wait for the ping to complete
+		try { Thread.sleep(20); } catch (InterruptedException e) {}
+		
+		// there will be a delay here
+		distance = us[sensor].getDistance();
+
+		addReading(sensor, distance);
+	}
 
 	//helper method. 
-	private void addReading(int reading, int sensor) {
+	private void addReading(int sensor, int reading) {
 		readings[sensor][4] = readings[sensor][3];
 		readings[sensor][3] = readings[sensor][2];
 		readings[sensor][2] = readings[sensor][1];
diff --git a/src/launcher/Launcher.java b/src/launcher/Launcher.java
index e54bf4e..a0cf427 100644
--- a/src/launcher/Launcher.java
+++ b/src/launcher/Launcher.java
@@ -3,6 +3,9 @@
  */
 package launcher;
 
+import controllers.State;
+import lejos.nxt.Button;
+import lejos.nxt.comm.RConsole;
 import manager.Manager;
 
 /**
@@ -10,6 +13,7 @@ import manager.Manager;
  * Main Entry
  * 
  * @author Riley
+ * @version 1.00
  *
  */
 public class Launcher {
@@ -21,8 +25,19 @@ public class Launcher {
 	 * @param args
 	 */
 	public static void main(String[] args) {
+		RConsole.openUSB(20000);
+		Button.waitForPress();
 		
 		Manager manager = new Manager();
+		
+		manager.sm.localization.start();
+		
+		while(manager.cm.getState() == State.LOCALIZING) {
+			manager.um.nap(150);
+		}
+		
+		Button.waitForPress();
+	
 	}
 
 }
diff --git a/src/services/Localization.java b/src/services/Localization.java
index 82e2403..843151e 100644
--- a/src/services/Localization.java
+++ b/src/services/Localization.java
@@ -1,5 +1,8 @@
 package services;
 
+import controllers.State;
+import utilities.*;
+import lejos.nxt.comm.RConsole;
 import lejos.util.Timer;
 import lejos.util.TimerListener;
 import manager.*;
@@ -23,7 +26,6 @@ public class Localization implements TimerListener {
 	private double angleA;
 	private double angleB;
 	
-	
 	private boolean lightLocalization;
 	private int rightLineCount;
 	private int leftLineCount;
@@ -38,45 +40,52 @@ public class Localization implements TimerListener {
 	 * Starts the localization process
 	 */
 	public void start() {
+		RConsole.println("Localizing");
 		//Retrieves center Ultrasonic reading
-		int usReading = updateUltrasonic() ;
+		int usReading = updateUltrasonic();
 		
 		//Currently facing a wall, use rising edge detection for both angles
 		if(usReading < THRESHOLD) {
 			rising = true;
+			RConsole.println("Rising");
 		} 
 		//currently not facing a wall, use falling edge, then rising edge
 		else if (usReading > THRESHOLD) {
 			rising = false;
+			RConsole.println("falling");
 		} 
 		//on the threshold, so start moving then try to start again
 		else {
+			RConsole.println("At threshold");
 			manager.hm.drive.setSpeeds(0, ROTATION_SPEED);
 			manager.um.nap(50);
 			start();
 			return;
 		}
-		
+		RConsole.println("initializing");
 		angleA = Double.NaN;
 		angleB = Double.NaN;
-		lineDetectedHeadings[7] = Double.NaN;
+		lineDetectedHeadings[3] = Double.NaN;
+		RConsole.println("Starting");
 		timer.start();
 		
 	}
 	
 	public void stop() {
+		
 		timer.stop();
 	}
 	
 	public void timedOut() {
-		if(angleB == Double.NaN) {
+		RConsole.println("timedOut");
+		if(Double.isNaN(angleB)) {
 			ultrasonicLocalization();
-		} else if(lineDetectedHeadings[7] == Double.NaN) {
+		} else if(Double.isNaN(lineDetectedHeadings[3])) {
 			
 			if(!lightLocalization) {
-				if(manager.sm.odo.getTheta() > 50) {
+				if(manager.sm.odo.getTheta() > lineLocalizationStartingOrientation() + 0.2 ) {
 					manager.hm.drive.setSpeeds(0, ROTATION_SPEED);
-				} else if(manager.sm.odo.getTheta() < 40) {
+				} else if(manager.sm.odo.getTheta() < lineLocalizationStartingOrientation() - 0.2 ) {
 					manager.hm.drive.setSpeeds(0, -ROTATION_SPEED);
 				} else {
 					manager.hm.drive.setSpeeds(0, ROTATION_SPEED);
@@ -100,7 +109,7 @@ public class Localization implements TimerListener {
 	public void ultrasonicLocalization() {
 		int distance = updateUltrasonic();
 		
-		if(angleA == Double.NaN) {
+		if(Double.isNaN(angleA)) {
 			if(rising) {
 				manager.hm.drive.setSpeeds(0, -ROTATION_SPEED);
 				if(distance > THRESHOLD) {
@@ -116,7 +125,7 @@ public class Localization implements TimerListener {
 			}
 		} else {
 			manager.hm.drive.setSpeeds(0, ROTATION_SPEED);
-			if(distance > THRESHOLD && Math.abs(angleA-manager.sm.odo.getTheta()) > 50) {
+			if(distance > THRESHOLD && Math.abs(angleA-manager.sm.odo.getTheta()) > 1) {
 				angleB = manager.sm.odo.getTheta();
 				updateTheta();
 			}
@@ -131,21 +140,33 @@ public class Localization implements TimerListener {
 		if(rising) {
 			//Depending on what angle is bigger, offset deltaTheta to the correct amount
 			if(angleA > angleB) {
-				deltaTheta += 225;
+				deltaTheta +=  5.0 * Math.PI / 4.0;
 			} else {
-				deltaTheta += 45;
+				deltaTheta +=  Math.PI / 4.0;
 			}
 		} else {
 			//Depending on what angle is bigger, offset deltaTheta to the correct amount
 			if(angleA > angleB) {
-				deltaTheta += 225;
+				deltaTheta +=  5.0 * Math.PI / 4.0;
 			} else {
-				deltaTheta += 45;
+				deltaTheta +=  Math.PI / 4.0;
 			}
 		}
 		
+		/*
+		 * Adjust for the starting corner
+		 */
+		if(Settings.startingCorner == StartingCorner.BOTTOM_RIGHT) {
+			deltaTheta -= Math.PI/2;
+		} else if (Settings.startingCorner == StartingCorner.TOP_RIGHT) {
+			deltaTheta -= Math.PI;
+		} else if (Settings.startingCorner == StartingCorner.TOP_LEFT) {
+			deltaTheta += Math.PI/2;
+		}
+		
 		//update the odometer
 		manager.sm.odo.adjustPosition(0, 0, deltaTheta);
+		manager.cm.setState(State.SEARCH);
 	}
 	
 	/**
@@ -156,8 +177,42 @@ public class Localization implements TimerListener {
 		checkLineSensor(false);
 	}
 	
+	/**
+	 * Updates the odometers position based on light localization results
+	 */
 	public void updatePosition() {
+		double thetaXminus = (lineDetectedHeadings[0] + lineDetectedHeadings[4]) / 2.0;
+		double thetaYminus = (lineDetectedHeadings[3] + lineDetectedHeadings[7]) / 2.0;
+		double thetaYplus = (lineDetectedHeadings[1] + lineDetectedHeadings[5]) / 2.0;
+		double thetaXplus = (lineDetectedHeadings[2] + lineDetectedHeadings[6]) / 2.0;
+		
+		double thetaX = thetaXminus - thetaXplus;
+		double thetaY = thetaYplus - thetaYminus;
+		
+		double x = -Settings.LS_OFFSET * Math.cos(thetaY/2.0);
+		double y = -Settings.LS_OFFSET * Math.cos(thetaX/2.0);
 		
+		double dThetaX = -Math.PI/2.0 + thetaX / 2.0 - thetaXminus;
+		double dThetaY = -Math.PI - thetaYminus - thetaY/2.0;
+		
+		double dTheta = (dThetaX + dThetaY) / 2.0;
+		
+		manager.sm.odo.adjustPosition(x, y, dTheta);
+	}
+	
+	/**
+	 * returns the desired starting angle for light localization
+	 */
+	public double lineLocalizationStartingOrientation() {
+		if(Settings.startingCorner == StartingCorner.BOTTOM_RIGHT) {
+			return 3.0 * Math.PI / 4.0;
+		} else if (Settings.startingCorner == StartingCorner.TOP_RIGHT) {
+			return 5.0 * Math.PI / 4.0;
+		} else if (Settings.startingCorner == StartingCorner.TOP_LEFT) {
+			return 7.0 * Math.PI / 4.0;
+		} else {
+			return Math.PI / 4.0;
+		}
 	}
 
 	
@@ -170,7 +225,7 @@ public class Localization implements TimerListener {
 	 * @param rightSensor -> true if the right sensor is to be checked, false if the left sensor is to be checked
 	 */
 	public void checkLineSensor(boolean rightSensor) {
-		if(manager.hm.linePoller.enteringLine(rightSensor)) {
+		if(manager.hm.linePoller.enteringLine((rightSensor) ? 1 : 0)) {
 			if(rightSensor && rightLineCount < 4) {
 				lineDetectedHeadings[rightLineCount] = manager.sm.odo.getTheta();
 				rightLineCount++;
diff --git a/src/utilities/Settings.java b/src/utilities/Settings.java
index a9c7f58..f248638 100644
--- a/src/utilities/Settings.java
+++ b/src/utilities/Settings.java
@@ -1,22 +1,26 @@
 package utilities;
 
 import lejos.nxt.ColorSensor;
+import lejos.nxt.Motor;
 import lejos.nxt.NXTRegulatedMotor;
+import lejos.nxt.SensorPort;
 import lejos.nxt.UltrasonicSensor;
 import lejos.nxt.remote.RemoteMotor;
 
 public class Settings {
 
-	public static ColorSensor frontColorSensor;
-	public static ColorSensor rearLeftColorSensor;
-	public static ColorSensor rearRightColorSensor;
+	
+	
+	public static ColorSensor frontColorSensor = new ColorSensor(SensorPort.S1);
+	public static ColorSensor rearLeftColorSensor = new ColorSensor(SensorPort.S2);
+	public static ColorSensor rearRightColorSensor = new ColorSensor(SensorPort.S3);
 	
 	public static UltrasonicSensor leftUltrasonic;
 	public static UltrasonicSensor centerUltrasonic;
 	public static UltrasonicSensor rightUltrasonic;
 	
-	public static NXTRegulatedMotor leftDriveMotor;
-	public static NXTRegulatedMotor rightDriveMotor;
+	public static NXTRegulatedMotor leftDriveMotor = Motor.B;
+	public static NXTRegulatedMotor rightDriveMotor = Motor.C;
 	
 	public static RemoteMotor forkliftMotor;
 	public static RemoteMotor ultrasonicMotor;
@@ -25,5 +29,6 @@ public class Settings {
 	public static final String NXTSlaveName = "NXT";
 	
 	public static StartingCorner startingCorner;
+	public static final double LS_OFFSET = 15.0;
 	
 }

commit a10c3762f7890412801f10ed7c2fc0dc069df8ab
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Fri Nov 8 22:08:52 2013 -0500

    Created the RS485 connection and Responder. Settings had to be changed
    to account for the RemoteMotors (changed from NXTRegulatedMotor). The
    ports used on the slave are all UltrasonicSensors as the code for a
    remote ColorSensor is not supported.

diff --git a/src/utilities/Communicator.java b/src/utilities/Communicator.java
index 82a4f33..e9ccab8 100644
--- a/src/utilities/Communicator.java
+++ b/src/utilities/Communicator.java
@@ -1,8 +1,62 @@
 package utilities;
 
+import java.io.IOException;
+
+import lejos.nxt.LCD;
+import lejos.nxt.UltrasonicSensor;
+import lejos.nxt.comm.RS485;
+import lejos.nxt.remote.RemoteNXT;
+
+/**
+ * This class will communicate with the slave NXT and initialize the ports on
+ * it. Only uses the motor and the ultrasonicSensors on the other NXT as it is
+ * impossible to initialize a ColorSensor on the remote NXT.
+ * <p>
+ * @author danielle
+ * 
+ */
 public class Communicator {
 
+	/**
+	 * The Communicator object that will just connect to the slaveNXT. Uses exclusively RS485 for a reliable connection. It initializes the motors from the remote brick.
+	 * @param slaveNXT	A String with the name of the remoteNXT connected via RS485. 
+	 */
 	public Communicator(String slaveNXT) {
-		
+		RemoteNXT nxt = null;
+		try {
+			nxt = new RemoteNXT(slaveNXT, RS485.getConnector());
+		} catch (IOException ioe) {
+			catchBug("RS485 Connection has Failed. See error: "
+					+ ioe.getMessage());
+		}
+
+		LCD.clear();
+
+		Settings.forkliftMotor = nxt.A;
+		Settings.clawMotor = nxt.B;
+		Settings.ultrasonicMotor = nxt.C;
+
+		Settings.rightUltrasonic = new UltrasonicSensor(nxt.S3);
+		Settings.centerUltrasonic = new UltrasonicSensor(nxt.S2);
+		Settings.rightUltrasonic = new UltrasonicSensor(nxt.S1);
+	}
+
+	/**
+	 * The static helper method here just exits the system when commanded. It
+	 * displays a message on the NXT for the user.
+	 * <p>
+	 * @param bug
+	 *            A String object with the message on screen.
+	 */
+	public static void catchBug(String bug) {
+		LCD.clear();
+		LCD.drawString(bug, 0, 0);
+		try {
+			Thread.sleep(5000);
+		} catch (InterruptedException e) {
+			// No bug expected here ever.
+		}
+		LCD.clear();
+		System.exit(1);
 	}
-}
+}
\ No newline at end of file
diff --git a/src/utilities/Responder.java b/src/utilities/Responder.java
new file mode 100644
index 0000000..3cc079a
--- /dev/null
+++ b/src/utilities/Responder.java
@@ -0,0 +1,49 @@
+package utilities;
+
+import lejos.nxt.comm.LCPResponder;
+import lejos.nxt.comm.NXTCommConnector;
+import lejos.nxt.comm.RS485;
+
+/**
+ * The responder class responds to the LCP requests sent by the Communicator.java class. 
+ * Uses by default RS485 without exception for a reliable, stable connection.
+ * <p> 
+ * @author danielle
+ * 
+ */
+public class Responder {
+	/**
+	 * The subclass that handles the LCP connections. In particular, it is modified version of the LCPResponder to shutdown the connection once the program disconnects.
+	 * @author danielle
+	 *
+	 */
+	public static class ResponderTool extends LCPResponder {
+		ResponderTool(NXTCommConnector con) {
+            super(con);
+        }
+
+         protected void disconnect() {
+            super.disconnect();
+            super.shutdown();
+        }
+	}
+	
+	/**
+	 * This program has a main as it is to be loaded on the slaveNXT brick. Has
+	 * almost no functionality otherwise.
+	 * <p>
+	 * @param args
+	 *            This is the default constructor, not needed.
+	 */
+	
+	public static void main(String[] args) {
+		ResponderTool resp = new ResponderTool(RS485.getConnector());
+		resp.start();
+		try {
+			resp.join();
+		} catch (InterruptedException e) {
+			Communicator.catchBug("The responder failed in the Responder.java class " + e.getMessage());
+		}
+    }
+	
+}
\ No newline at end of file
diff --git a/src/utilities/Settings.java b/src/utilities/Settings.java
index e2dd8da..a9c7f58 100644
--- a/src/utilities/Settings.java
+++ b/src/utilities/Settings.java
@@ -3,6 +3,7 @@ package utilities;
 import lejos.nxt.ColorSensor;
 import lejos.nxt.NXTRegulatedMotor;
 import lejos.nxt.UltrasonicSensor;
+import lejos.nxt.remote.RemoteMotor;
 
 public class Settings {
 
@@ -16,9 +17,10 @@ public class Settings {
 	
 	public static NXTRegulatedMotor leftDriveMotor;
 	public static NXTRegulatedMotor rightDriveMotor;
-	public static NXTRegulatedMotor forkliftMotor;
-	public static NXTRegulatedMotor ultrasonicMotor;
-	public static NXTRegulatedMotor clawMotor;
+	
+	public static RemoteMotor forkliftMotor;
+	public static RemoteMotor ultrasonicMotor;
+	public static RemoteMotor clawMotor;
 	
 	public static final String NXTSlaveName = "NXT";
 	

commit 5b3c6b98b5808d38a3c2f32ec996e1bcaa802044
Author: RileyvanRyswyk <rileyvan@gmail.com>
Date:   Fri Nov 8 13:17:13 2013 -0500

    Mostly Localization

diff --git a/src/hardwareAbstraction/LinePoller.java b/src/hardwareAbstraction/LinePoller.java
index dcee143..1691318 100644
--- a/src/hardwareAbstraction/LinePoller.java
+++ b/src/hardwareAbstraction/LinePoller.java
@@ -2,4 +2,19 @@ package hardwareAbstraction;
 
 public class LinePoller {
 
+	private boolean rightSensorOnLine;
+	private boolean leftSensorOnLine;
+	
+	public int getFilteredData(boolean rightSensor) {
+		return 1;
+	}
+	
+	public boolean onLine(boolean rightSensor) {
+		return (rightSensor) ? rightSensorOnLine : leftSensorOnLine;
+	}
+	
+	public boolean enteringLine(boolean rightSensor) {
+		return true;
+	}
+	
 }
diff --git a/src/hardwareAbstraction/UltrasonicPoller.java b/src/hardwareAbstraction/UltrasonicPoller.java
index 529f20a..2a0355e 100644
--- a/src/hardwareAbstraction/UltrasonicPoller.java
+++ b/src/hardwareAbstraction/UltrasonicPoller.java
@@ -13,10 +13,11 @@ import lejos.util.TimerListener;
  * @author danielle
  */
 public class UltrasonicPoller implements TimerListener {
-	private UltrasonicSensor[] us = {utilities.Settings.leftUltrasonic, utilities.Settings.leftUltrasonic, utilities.Settings.leftUltrasonic};
+	private UltrasonicSensor[] us = {utilities.Settings.leftUltrasonic, utilities.Settings.centerUltrasonic, utilities.Settings.rightUltrasonic};
 	public int pollRate;
 	private Timer poller;
 	private int readings[][];
+	private boolean running = false;
 
 	// TODO figure out what exactly this constructor should be.
 	public UltrasonicPoller() {
@@ -47,6 +48,7 @@ public class UltrasonicPoller implements TimerListener {
 	public void start() {
 		this.poller = new Timer(pollRate, this);
 		this.poller.start();
+		running = true;
 	}
 
 	/**
@@ -55,7 +57,13 @@ public class UltrasonicPoller implements TimerListener {
 	 */
 	public void stop() {
 		this.poller = null;
+		running = false;
 	}
+	
+	public int getUSReading(int sensor) {
+		return 20;
+	}
+	
 
 	/**
 	 * gets the lowest reading in the ultrasonicPoller at that time. Readings
diff --git a/src/manager/UtilityManager.java b/src/manager/UtilityManager.java
index f3f08bd..bd08521 100644
--- a/src/manager/UtilityManager.java
+++ b/src/manager/UtilityManager.java
@@ -16,4 +16,15 @@ public class UtilityManager {
 		this.comLink = new Communicator(Settings.NXTSlaveName);
 		this.map = new Map();
 	}
+	
+	/** Helper method to avoid large try/catch blocks. Sleeps the current thread. 
+	 * @param time int value which represents the sleep time
+	 */
+	public void nap(int time) {
+		try {
+			Thread.sleep(time);
+		} catch (InterruptedException e) {
+			e.printStackTrace();
+		}
+	}
 }
diff --git a/src/services/Localization.java b/src/services/Localization.java
index bacb2c4..82e2403 100644
--- a/src/services/Localization.java
+++ b/src/services/Localization.java
@@ -1,10 +1,184 @@
 package services;
 
+import lejos.util.Timer;
+import lejos.util.TimerListener;
 import manager.*;
 
-public class Localization {
+public class Localization implements TimerListener {
+	
+	private Manager manager;
+	private Timer timer;
+	
+	
+	//Speed in deg/sec of which to rotate during localization
+	private double ROTATION_SPEED = 30;
+	
+	//period to check ultrasonic sensor in ms
+	private final int UPDATE_PERIOD = 20;
+	
+	//threshold distance in cm, to determine if we are at a critical angle
+	private final int THRESHOLD = 30;
+	
+	private boolean rising;
+	private double angleA;
+	private double angleB;
+	
+	
+	private boolean lightLocalization;
+	private int rightLineCount;
+	private int leftLineCount;
+	private double[] lineDetectedHeadings = new double[8]; 
 	
 	public Localization(Manager manager) {
+		this.manager = manager;
+		this.timer = new Timer(UPDATE_PERIOD, this);
+	}
+	
+	/**
+	 * Starts the localization process
+	 */
+	public void start() {
+		//Retrieves center Ultrasonic reading
+		int usReading = updateUltrasonic() ;
+		
+		//Currently facing a wall, use rising edge detection for both angles
+		if(usReading < THRESHOLD) {
+			rising = true;
+		} 
+		//currently not facing a wall, use falling edge, then rising edge
+		else if (usReading > THRESHOLD) {
+			rising = false;
+		} 
+		//on the threshold, so start moving then try to start again
+		else {
+			manager.hm.drive.setSpeeds(0, ROTATION_SPEED);
+			manager.um.nap(50);
+			start();
+			return;
+		}
 		
+		angleA = Double.NaN;
+		angleB = Double.NaN;
+		lineDetectedHeadings[7] = Double.NaN;
+		timer.start();
+		
+	}
+	
+	public void stop() {
+		timer.stop();
+	}
+	
+	public void timedOut() {
+		if(angleB == Double.NaN) {
+			ultrasonicLocalization();
+		} else if(lineDetectedHeadings[7] == Double.NaN) {
+			
+			if(!lightLocalization) {
+				if(manager.sm.odo.getTheta() > 50) {
+					manager.hm.drive.setSpeeds(0, ROTATION_SPEED);
+				} else if(manager.sm.odo.getTheta() < 40) {
+					manager.hm.drive.setSpeeds(0, -ROTATION_SPEED);
+				} else {
+					manager.hm.drive.setSpeeds(0, ROTATION_SPEED);
+					lightLocalization = true;
+					rightLineCount = 0;
+					leftLineCount = 4;					
+				}
+			} else {
+				lineLocalization();
+			}
+		} else {
+			updatePosition();
+			stop();
+		}
 	}
+	
+	/**
+	 * If the robot starts facing the fall the robot will do rising, rising edge detection (angleA, angleB)
+	 * if the robot starts facing the field the robot will do falling edge, rising edge (angleA, angleB) 
+	 */
+	public void ultrasonicLocalization() {
+		int distance = updateUltrasonic();
+		
+		if(angleA == Double.NaN) {
+			if(rising) {
+				manager.hm.drive.setSpeeds(0, -ROTATION_SPEED);
+				if(distance > THRESHOLD) {
+					angleA = manager.sm.odo.getTheta();
+					manager.hm.drive.setSpeeds(0, ROTATION_SPEED);
+				}
+			} else {
+				manager.hm.drive.setSpeeds(0, ROTATION_SPEED);
+				if(distance < THRESHOLD) {
+					manager.hm.drive.stop();
+					angleA = manager.sm.odo.getTheta();
+				}
+			}
+		} else {
+			manager.hm.drive.setSpeeds(0, ROTATION_SPEED);
+			if(distance > THRESHOLD && Math.abs(angleA-manager.sm.odo.getTheta()) > 50) {
+				angleB = manager.sm.odo.getTheta();
+				updateTheta();
+			}
+		}
+	}
+	
+	/**
+	 * Updates theta based on the results of ultrasonic sensor localization
+	 */
+	public void updateTheta() {
+		double deltaTheta = -(angleA + angleB) / 2;
+		if(rising) {
+			//Depending on what angle is bigger, offset deltaTheta to the correct amount
+			if(angleA > angleB) {
+				deltaTheta += 225;
+			} else {
+				deltaTheta += 45;
+			}
+		} else {
+			//Depending on what angle is bigger, offset deltaTheta to the correct amount
+			if(angleA > angleB) {
+				deltaTheta += 225;
+			} else {
+				deltaTheta += 45;
+			}
+		}
+		
+		//update the odometer
+		manager.sm.odo.adjustPosition(0, 0, deltaTheta);
+	}
+	
+	/**
+	 * calls checkLineSensor for each lineSensor
+	 */
+	public void lineLocalization() {
+		checkLineSensor(true);
+		checkLineSensor(false);
+	}
+	
+	public void updatePosition() {
+		
+	}
+
+	
+	public int updateUltrasonic() {
+		return manager.hm.ultrasonicPoller.getUSReading(1);
+	}
+	
+	/**
+	 * Updates the lineDetectedHeadings[] based on whether a new line has been detected
+	 * @param rightSensor -> true if the right sensor is to be checked, false if the left sensor is to be checked
+	 */
+	public void checkLineSensor(boolean rightSensor) {
+		if(manager.hm.linePoller.enteringLine(rightSensor)) {
+			if(rightSensor && rightLineCount < 4) {
+				lineDetectedHeadings[rightLineCount] = manager.sm.odo.getTheta();
+				rightLineCount++;
+			} else if (leftLineCount < 8) {
+				lineDetectedHeadings[leftLineCount] = manager.sm.odo.getTheta();
+				leftLineCount++;
+			}
+		}
+	}
+	
 }
diff --git a/src/services/Navigation.java b/src/services/Navigation.java
index b0f1d35..f9a64c5 100644
--- a/src/services/Navigation.java
+++ b/src/services/Navigation.java
@@ -103,14 +103,11 @@ public class Navigation implements TimerListener {
 		// the required theta to travel to our destination
 		double theta = Math.atan2(dY, dX);
 		
-		// adjust to [0, 360]
+		// adjust to [0, 2PI]
 		theta = Angle.principleAngle(theta);
-
-		// error in theta
-		dH = theta - currentPos.theta;
 		
-		// adjust to [0, 360]
-		dH = Angle.principleAngle(dH);
+		// set dH to the difference of theta and currentTheta adjust to [-PI, PI]
+		dH = Angle.minimumAngle(currentPos.theta, theta);
 	}
 
 	public void travelTo() {
diff --git a/src/services/Odometer.java b/src/services/Odometer.java
index 2c46fbb..85ea9c6 100644
--- a/src/services/Odometer.java
+++ b/src/services/Odometer.java
@@ -1,6 +1,5 @@
 package services;
 
-import lejos.nxt.NXTRegulatedMotor;
 import lejos.util.Timer;
 import lejos.util.TimerListener;
 import manager.*;
@@ -127,7 +126,7 @@ public class Odometer implements TimerListener {
 		synchronized (lock) {
 			x = pos.x;
 			y = pos.y;
-			theta = pos.theta;
+			theta = Angle.principleAngle(pos.theta);
 		}
 	}
 	
@@ -141,7 +140,7 @@ public class Odometer implements TimerListener {
 		synchronized (lock) {
 			x += dx;
 			y += dy;
-			theta += dTheta;
+			theta = Angle.principleAngle(theta+dTheta);
 		}
 	}
 	
diff --git a/src/utilities/Settings.java b/src/utilities/Settings.java
index 4a3e2c9..e2dd8da 100644
--- a/src/utilities/Settings.java
+++ b/src/utilities/Settings.java
@@ -22,4 +22,6 @@ public class Settings {
 	
 	public static final String NXTSlaveName = "NXT";
 	
+	public static StartingCorner startingCorner;
+	
 }
diff --git a/src/utilities/StartingCorner.java b/src/utilities/StartingCorner.java
new file mode 100644
index 0000000..a5834cd
--- /dev/null
+++ b/src/utilities/StartingCorner.java
@@ -0,0 +1,5 @@
+package utilities;
+
+public enum StartingCorner {
+	BOTTOM_RIGHT, BOTTOM_LEFT, TOP_RIGHT, TOP_LEFT;
+}

commit 10f87688261b2c05669c82b7727f5cbb9dc74afb
Author: RileyvanRyswyk <rileyvan@gmail.com>
Date:   Thu Nov 7 14:54:17 2013 -0500

    Updated Navigation

diff --git a/src/hardwareAbstraction/Drive.java b/src/hardwareAbstraction/Drive.java
index 10647ea..c2ddc49 100644
--- a/src/hardwareAbstraction/Drive.java
+++ b/src/hardwareAbstraction/Drive.java
@@ -3,6 +3,11 @@ package hardwareAbstraction;
 import lejos.nxt.NXTRegulatedMotor;
 import utilities.Settings;
 
+/**
+ * This class handles the driving motors, it is a modified version of the TwoWheeledRobot class from Lab4 
+ * @author Riley
+ *
+ */
 public class Drive {
 
 	private NXTRegulatedMotor leftMotor;
@@ -29,4 +34,54 @@ public class Drive {
 		data[0] = (leftTacho * LEFT_RADIUS + rightTacho * RIGHT_RADIUS) *	Math.PI / 360.0;
 		data[1] = (leftTacho * LEFT_RADIUS - rightTacho * RIGHT_RADIUS) / WIDTH * Math.PI / 180.0;
 	}
+	
+	/**
+	 * Sets both forward and rotational speed (cm/s, deg/s)
+	 * @param forwardSpeed
+	 * @param rotationalSpeed
+	 */
+	public void setSpeeds(double forwardSpeed, double rotationalSpeed) {
+		double leftSpeed, rightSpeed;
+
+		leftSpeed = (forwardSpeed + rotationalSpeed * WIDTH * Math.PI / 360.0) *
+				180.0 / (LEFT_RADIUS * Math.PI);
+		rightSpeed = (forwardSpeed - rotationalSpeed * WIDTH * Math.PI / 360.0) *
+				180.0 / (RIGHT_RADIUS * Math.PI);
+
+		
+		// set motor directions
+		if (leftSpeed > 0.0)
+			leftMotor.forward();
+		else {
+			leftMotor.backward();
+			leftSpeed = -leftSpeed;
+		}
+		
+		if (rightSpeed > 0.0)
+			rightMotor.forward();
+		else {
+			rightMotor.backward();
+			rightSpeed = -rightSpeed;
+		}
+		
+		// set motor speeds
+		if (leftSpeed > 900.0)
+			leftMotor.setSpeed(900);
+		else
+			leftMotor.setSpeed((int)leftSpeed);
+		
+		if (rightSpeed > 900.0)
+			rightMotor.setSpeed(900);
+		else
+			rightMotor.setSpeed((int)rightSpeed);
+	}
+	
+	/**
+	 * Stops robot
+	 */
+	public void stop() {
+		rightMotor.stop(true);
+		leftMotor.stop();
+	}
+	
 }
diff --git a/src/services/Navigation.java b/src/services/Navigation.java
index 2f9f2ef..b0f1d35 100644
--- a/src/services/Navigation.java
+++ b/src/services/Navigation.java
@@ -10,26 +10,24 @@ import manager.*;
 
 /**
  * 
- * needs to implement timerlistener stack<Point> route timedOut (calls turnTo or
- * travelTo + obstacleAvoidance scan() depending on what one is needed) && only
- * be called while state is State.SEARCH || State.DROP_OFF turnTo travelTo
+ * Navigates the robot along a route, which is contained in this class
+ * the route is set by the search and drop off controllers.
  * 
- * Once turn to face the direction to a new point, confer with obstacle
- * avoidance to scanAhead()
+ * Further work required with scanAhead()
  * 
- * 
- * 
- * @author
+ * @author Danielle, Riley
  * 
  */
 public class Navigation implements TimerListener {
-	private Stack<Point> route;
 	private Manager manager;
-	private Odometer odo;
 	private Point nextDestination;
 	private Timer time;
+	private final int UPDATE_PERIOD = 100;
+	private final int MAX_FORWARD_SPEED = 8;
+	private final int MAX_ROTATE_SPEED = 45;
 
-	private Position pos;
+	private Stack<Point> route;
+	private Position currentPos;
 	private double dX;
 	private double dY;
 	private double dH;
@@ -39,9 +37,8 @@ public class Navigation implements TimerListener {
 	public Navigation(Manager manager) {
 		this.manager = manager;
 		this.route = initializeRoute();
-		this.odo = manager.sm.odo;
-		this.pos = new Position();
-		this.time = new Timer(100, this);
+		this.currentPos = new Position();
+		this.time = new Timer(UPDATE_PERIOD, this);
 		//start navigation right away
 		this.time.start();
 	}
@@ -63,16 +60,16 @@ public class Navigation implements TimerListener {
 				// update the new headings to travel to
 				setupDeltaPositonAndHeading();
 				// see if we need to make a big turn
-				if (Math.abs(dH) > 5) {
+				if (Math.abs(dH) > 0.1) {
 					// if we need to turn more than 0.2 rads or 0.1 for
 					// completing a turn, call the turnTo method
 					// otherwise we can adjust small angle errors by slowing
-					// one
-					// wheel down slightly
+					// one wheel down slightly
 					turnTo();
 				} else if (Math.abs(dX) > 1 || Math.abs(dY) > 1) {
 					//scan ahead only once facing the correct orientation, then travelTo that destination.
 					if (!scannedAhead) {
+						manager.hm.drive.stop();
 						pause();
 						manager.sm.obstacleAvoidance.scanAhead();
 						start();
@@ -80,7 +77,7 @@ public class Navigation implements TimerListener {
 					travelTo();
 				} else {
 					//stop the motors, reset scanning state and get next destination. 
-					robot.stop();
+					manager.hm.drive.stop();
 					scannedAhead = false;
 					route.pop();
 				}
@@ -97,111 +94,86 @@ public class Navigation implements TimerListener {
 	}
 	
 	private void setupDeltaPositonAndHeading() {
-		pos = odo.getPosition();
-
-		double currentX = pos.x;
-		double currentY = pos.y;
-		double currentTheta = pos.theta;
+		currentPos = manager.sm.odo.getPosition();
 
 		// Distance between where we are and where we need to travel to
-		dX = nextDestination.x- currentX;
-		dY = nextDestination.y - currentY;
+		dX = nextDestination.x - currentPos.x;
+		dY = nextDestination.y - currentPos.y;
 
 		// the required theta to travel to our destination
-		double theta = Math.atan2(dY, dX) * 180.0 / Math.PI;
+		double theta = Math.atan2(dY, dX);
+		
 		// adjust to [0, 360]
-		theta = (theta < 0) ? 360 + theta : theta;
+		theta = Angle.principleAngle(theta);
 
 		// error in theta
-		dH = theta - currentTheta;
-
-		// Change deltaTheta to [0,360)
-		if (dH > 180) {
-			dH -= 360;
-		} else if (dH < -180) {
-			dH += 360;
-		}
+		dH = theta - currentPos.theta;
+		
+		// adjust to [0, 360]
+		dH = Angle.principleAngle(dH);
 	}
 
 	public void travelTo() {
 		/*
 		 * For minor angle corrections
 		 */
-
-		// amount to change right wheel speed by
-		int dL = 0;
-
-		// If angle error is greater than 3 deg, make adjustment
-		if (Math.abs(dH) > 0.5) {
-
-			// if we are facing to the left of where we should
-			// be,
-			// slight right
-			if (dH > 0) {
-
-				dL = -5;
-			}
-
-			// if we are facing to the right of where we should
-			// be,
-			// slight left
-			else if (dH < 0) {
-
-				dL = 5;
-			}
-		}
-
-		/*
-		 * End minor angle corrections
-		 */
+		int dL = calculateRotationSpeed(dH);
 
 		// Distance to destination
-		double currentTheta = pos[2];
-		double distanceToTravel = (dX * Math.cos(Math.toRadians(currentTheta)))
-				+ (dY * Math.sin(Math.toRadians(currentTheta)));
+		double distanceToTravel = (dX * Math.cos(currentPos.theta))
+								+ (dY * Math.sin(currentPos.theta));
 		// high speed
-		if (distanceToTravel > 3) {
-			robot.setSpeeds(MAX_FORWARD_SPEED, dL);
-		}
-		// start to slow down
-		else if (distanceToTravel > 1) {
-			robot.setSpeeds(MAX_FORWARD_SPEED / 2, dL);
+		if (distanceToTravel > 1) {
+			manager.hm.drive.setSpeeds(MAX_FORWARD_SPEED, dL);
 		}
-		// go really slow, so that we don't overshoot
+		// close to target so go really slow, so that we don't overshoot
 		else {
-			robot.setSpeeds(MAX_FORWARD_SPEED / 5, dL / 3);
+			manager.hm.drive.setSpeeds(MAX_FORWARD_SPEED / 5, dL / 3);
 		}
 
 	}
 
 	public void turnTo() {
 
-		// if angle error greater than 1 deg
-		if (Math.abs(dH) >= 1) {
-			// if error positive and greater than 5 deg -> max speed CCW
-			if (dH > 8) {
-				robot.setSpeeds(0, -MAX_ROTATE_SPEED);
+		// if angle error greater than 0.6 deg
+		if (Math.abs(dH) >= 0.01) {
+			manager.hm.drive.setSpeeds(0, calculateRotationSpeed(dH));
+		} else {
+			// we have finished turning
+			manager.hm.drive.stop();
+		}
+	}
+	
+	public int calculateRotationSpeed(double dH) {
+		if (Math.abs(dH) > 0.01) {
+			// if error positive and greater than 0.2 rad -> max speed CCW
+			if (dH > 0.15) {
+				return -MAX_ROTATE_SPEED;
+			}
+			// positive error, between .05 and .15 , so turn slow CCW to prevent overshoot
+			else if (dH > .05) {
+				return -MAX_ROTATE_SPEED / 4;
 			}
-			// positive error, but close to 0, so turn slow CCW to
-			// prevent
-			// overshoot
+			// positive error, but close to 0, so turn slow CCW to prevent overshoot
 			else if (dH > 0) {
-				robot.setSpeeds(0, -MAX_ROTATE_SPEED / 4);
+				return -MAX_ROTATE_SPEED / 8;
 			}
-			// error negative and less than 5deg -> max speed CW
-			else if (dH < -8) {
-				robot.setSpeeds(0, MAX_ROTATE_SPEED);
+			
+			// if error negative and greater than 0.2 rad -> max speed CW
+			if (dH < 0.15) {
+				return MAX_ROTATE_SPEED;
 			}
-			// negative error, but close to 0, so turn slow CW to
-			// prevent
-			// overshoot
+			// negative error, between .05 and .15 , so turn slow CW to prevent overshoot
+			else if (dH < .05) {
+				return MAX_ROTATE_SPEED / 4;
+			}
+			// negative error, but close to 0, so turn slow CW to prevent overshoot
 			else if (dH < 0) {
-				robot.setSpeeds(0, MAX_ROTATE_SPEED / 4);
+				return MAX_ROTATE_SPEED / 8;
 			}
-		} else {
-			// we have finished turning
-			robot.stop();
 		}
+		//if this point is reached, dH is basically zero (<0.6deg)
+		return 0;
 	}
 
 }
diff --git a/src/services/Odometer.java b/src/services/Odometer.java
index 010b464..2c46fbb 100644
--- a/src/services/Odometer.java
+++ b/src/services/Odometer.java
@@ -28,7 +28,7 @@ public class Odometer implements TimerListener {
 	public Odometer(Manager manager) {		
 		x = 0.0;
 		y = 0.0;
-		theta = Math.PI/2;
+		theta = 0.0;
 		oldDH = new double [2];
 		dDH = new double [2];
 		lock = new Object();

commit f9ea3e79fa94b4508ff5b29a90e77e93d6792660
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Thu Nov 7 14:30:38 2013 -0500

    Created the ultrasonic poller and obstacle avoidance. Many things left
    undone in obstacle avoidance. The API documents may have to be changed.

diff --git a/src/hardwareAbstraction/UltrasonicPoller.java b/src/hardwareAbstraction/UltrasonicPoller.java
index 4c4e8ee..529f20a 100644
--- a/src/hardwareAbstraction/UltrasonicPoller.java
+++ b/src/hardwareAbstraction/UltrasonicPoller.java
@@ -1,5 +1,100 @@
 package hardwareAbstraction;
 
-public class UltrasonicPoller {
+import java.util.Arrays;
 
+import lejos.nxt.UltrasonicSensor;
+import lejos.util.Timer;
+import lejos.util.TimerListener;
+
+/**This class serves as a higher level abstraction of a ultrasonic sensor. It is
+ * wrapped in a poller class which will now handle the returned values and the
+ * polling of that sensor
+ * <p>
+ * @author danielle
+ */
+public class UltrasonicPoller implements TimerListener {
+	private UltrasonicSensor[] us = {utilities.Settings.leftUltrasonic, utilities.Settings.leftUltrasonic, utilities.Settings.leftUltrasonic};
+	public int pollRate;
+	private Timer poller;
+	private int readings[][];
+
+	// TODO figure out what exactly this constructor should be.
+	public UltrasonicPoller() {
+		this.pollRate = 250;
+		this.readings = new int[3][5];
+		start();
+	}
+
+	/**Pings all three ultrasonic sensors and gets their values. Puts them into the readings array
+	 */
+	@Override
+	public void timedOut() {
+		//ping left sensor
+		us[0].ping();
+		addReading(us[0].getDistance(), 0);
+		// ping center sensor
+		us[1].ping();
+		addReading(us[1].getDistance(), 1);
+		//ping right sensor
+		us[2].ping();
+		addReading(us[2].getDistance(), 2);
+	}
+
+	/**
+	 * Starts this instance of the ultrasonic poller Stop must be called to stop
+	 * the reading again.
+	 */
+	public void start() {
+		this.poller = new Timer(pollRate, this);
+		this.poller.start();
+	}
+
+	/**
+	 * Stops this instance of the ultrasonic poller Start must be called to
+	 * start reading again.
+	 */
+	public void stop() {
+		this.poller = null;
+	}
+
+	/**
+	 * gets the lowest reading in the ultrasonicPoller at that time. Readings
+	 * are not taken temporarily as they are not needed;
+	 * <p>
+	 * @return The smallest reading of the last 5 polls.
+	 */
+	public int getLowestReading() {
+		// stop reading if the robot was taking readings.
+		boolean takingReadings = false;
+		if (this.poller != null) {
+			stop();
+			takingReadings = true;
+		}
+
+		// calculate median value by sorting the readings
+		int minValue = readings[0][0]; //get a value to start
+		for (int usReadings[] : readings) {
+			int i = 0;
+			for(int reading : usReadings) {
+				if(minValue > reading)
+					minValue = reading;
+				++i;
+				}
+		}
+
+		// start the readings again if the robot was taking readings before.
+		if (takingReadings)
+			start();
+		return minValue;
+
+	}
+
+	//helper method. 
+	private void addReading(int reading, int sensor) {
+		readings[sensor][4] = readings[sensor][3];
+		readings[sensor][3] = readings[sensor][2];
+		readings[sensor][2] = readings[sensor][1];
+		readings[sensor][1] = readings[sensor][0];
+		readings[sensor][0] = reading;
+	}
 }
diff --git a/src/services/ObstacleAvoidance.java b/src/services/ObstacleAvoidance.java
index fbe7cb6..3719a3e 100644
--- a/src/services/ObstacleAvoidance.java
+++ b/src/services/ObstacleAvoidance.java
@@ -21,13 +21,50 @@ import manager.*;
  *
  */
 public class ObstacleAvoidance {
-
+	private hardwareAbstraction.UltrasonicPoller poller;
+	private int threshold;
+	private int safetyThreshold;
+	
 	public ObstacleAvoidance(Manager manager) {
-		
+		poller = manager.hm.ultrasonicPoller;
+		this.threshold=20;
+		this.safetyThreshold=5;
 	}
 	
 	//TODO complete this stub.
-	public void scanAhead() {
+	public boolean scanAhead() {
+		// TODO somehow move all the three ultrasonic sensors forward with slave brick. Waiting for feedback from RS485 to do this. 
+		
+		//reset pollers. 
+		poller.stop();
+		poller.start();
+		
+		// let the current heading readings propogate through the poller.
+		nap(poller.pollRate * 6);
 		
+		int smallestReading = poller.getLowestReading();
+		if(smallestReading < threshold) {
+			// TODO set the state
+			return false;
+		}
+		else if(smallestReading > threshold + safetyThreshold)
+			return true;
+		else {
+			//TODO add point in navigation class. 
+			return true;
+		}
+	}
+	
+	
+	
+	/** Helper method to avoid large try/catch blocks. Sleeps the current thread. 
+	 * @param time	int value which represents the sleep time
+	 */
+	private void nap(int time) {
+		try {
+			Thread.sleep(time);
+		} catch (InterruptedException e) {
+			e.printStackTrace();
+		}
 	}
 }

commit 9bdd4c111bc6c8b5475a4c1ed03c0d3a370e0b8b
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Thu Nov 7 13:05:08 2013 -0500

    CollerPoller updated to reflect Settings.frontColorSensor

diff --git a/src/hardwareAbstraction/ColorPoller.java b/src/hardwareAbstraction/ColorPoller.java
index 5d847af..8db08ca 100644
--- a/src/hardwareAbstraction/ColorPoller.java
+++ b/src/hardwareAbstraction/ColorPoller.java
@@ -1,5 +1,6 @@
 package hardwareAbstraction;
 
+import utilities.Settings;
 import lejos.nxt.ColorSensor;
 import lejos.robotics.Color;
 import lejos.util.Timer;
@@ -12,7 +13,7 @@ public class ColorPoller implements TimerListener {
 	private int[] readings;
 
 	public ColorPoller() {
-		this.cs = cs;
+		this.cs = Settings.frontColorSensor;
 		this.readings = new int[5];
 		this.poller = new Timer(poleRate, this);
 	}

commit ba74248c654eb3e3c60506c789aa044a00cac4cf
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Thu Nov 7 12:56:35 2013 -0500

    Small changes in Navigation. Ignore changes in odometer and position.

diff --git a/src/services/Navigation.java b/src/services/Navigation.java
index 8a3cfdf..2f9f2ef 100644
--- a/src/services/Navigation.java
+++ b/src/services/Navigation.java
@@ -29,7 +29,7 @@ public class Navigation implements TimerListener {
 	private Point nextDestination;
 	private Timer time;
 
-	private double[] pos;
+	private Position pos;
 	private double dX;
 	private double dY;
 	private double dH;
@@ -40,7 +40,7 @@ public class Navigation implements TimerListener {
 		this.manager = manager;
 		this.route = initializeRoute();
 		this.odo = manager.sm.odo;
-		this.pos = new double[3];
+		this.pos = new Position();
 		this.time = new Timer(100, this);
 		//start navigation right away
 		this.time.start();
@@ -97,15 +97,15 @@ public class Navigation implements TimerListener {
 	}
 	
 	private void setupDeltaPositonAndHeading() {
-		odo.getPosition(pos);
+		pos = odo.getPosition();
 
-		double currentX = pos[0];
-		double currentY = pos[1];
-		double currentTheta = pos[2];
+		double currentX = pos.x;
+		double currentY = pos.y;
+		double currentTheta = pos.theta;
 
 		// Distance between where we are and where we need to travel to
-		dX = nextDestination.getX() - currentX;
-		dY = nextDestination.getY() - currentY;
+		dX = nextDestination.x- currentX;
+		dY = nextDestination.y - currentY;
 
 		// the required theta to travel to our destination
 		double theta = Math.atan2(dY, dX) * 180.0 / Math.PI;
diff --git a/src/services/Odometer.java b/src/services/Odometer.java
index f6d0887..010b464 100644
--- a/src/services/Odometer.java
+++ b/src/services/Odometer.java
@@ -76,11 +76,6 @@ public class Odometer implements TimerListener {
 		return pos;
 	}
 	
-	//TODO complete this stub.
-	public double[] getPosition(double[] pos) {
-		return pos;
-	}
-	
 	/**
 	 * returns the current heading of the robot
 	 * @return
diff --git a/src/utilities/Position.java b/src/utilities/Position.java
index 66f913d..093b5ab 100644
--- a/src/utilities/Position.java
+++ b/src/utilities/Position.java
@@ -15,7 +15,7 @@ public class Position extends Point {
 		this.y = Double.NaN;
 		this.theta = Double.NaN;
 	}
-	
+
 	public String toString() {
 		return "{x:" + x + ", y:" + y + ", theta:" + theta + "}";
 	}

commit 006954167585a0e55f361980012c482c2c970dfa
Merge: 7f645c9 00f63a7
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Thu Nov 7 12:30:55 2013 -0500

    Merge branch 'master' of
    https://github.com/danielle-mustillo/ECSE-211-Team-5.git
    
    Conflicts:
    	src/services/Odometer.java
    	src/utilities/Point.java

commit 00f63a774bb59f27bc911cecf817d52380ef14fb
Author: RileyvanRyswyk <rileyvan@gmail.com>
Date:   Thu Nov 7 11:53:01 2013 -0500

    Updates
    
    Mostly Odometer and some of the helper methods

diff --git a/.gitignore b/.gitignore
index 5e56e04..bde72a7 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1 +1,4 @@
 /bin
+*.class
+*.classpath
+*.gitignore
\ No newline at end of file
diff --git a/src/hardwareAbstraction/ColorPoller.java b/src/hardwareAbstraction/ColorPoller.java
index ccd4d2a..5d847af 100644
--- a/src/hardwareAbstraction/ColorPoller.java
+++ b/src/hardwareAbstraction/ColorPoller.java
@@ -8,10 +8,10 @@ import lejos.util.TimerListener;
 public class ColorPoller implements TimerListener {
 	private ColorSensor cs;
 	private Timer poller;
-	private int poleRate;
+	private int poleRate = 30;
 	private int[] readings;
 
-	public ColorPoller(ColorSensor cs, int poleRate) {
+	public ColorPoller() {
 		this.cs = cs;
 		this.readings = new int[5];
 		this.poller = new Timer(poleRate, this);
diff --git a/src/hardwareAbstraction/Drive.java b/src/hardwareAbstraction/Drive.java
index 0d1a206..10647ea 100644
--- a/src/hardwareAbstraction/Drive.java
+++ b/src/hardwareAbstraction/Drive.java
@@ -1,5 +1,32 @@
 package hardwareAbstraction;
 
+import lejos.nxt.NXTRegulatedMotor;
+import utilities.Settings;
+
 public class Drive {
 
+	private NXTRegulatedMotor leftMotor;
+	private NXTRegulatedMotor rightMotor;
+	
+	public static final double LEFT_RADIUS = 2.11;
+	public static final double RIGHT_RADIUS = 2.11;
+	public static final double WIDTH = 14.92;
+	
+	public Drive() {
+		leftMotor = Settings.leftDriveMotor;
+		rightMotor = Settings.rightDriveMotor;
+	}
+	
+	/**
+	 * returns displacement and heading based on tacho counts -> passed through the data array pointer
+	 * @param data
+	 */
+	public void getDisplacementAndHeading(double [] data) {
+		int leftTacho, rightTacho;
+		leftTacho = leftMotor.getTachoCount();
+		rightTacho = rightMotor.getTachoCount();
+		
+		data[0] = (leftTacho * LEFT_RADIUS + rightTacho * RIGHT_RADIUS) *	Math.PI / 360.0;
+		data[1] = (leftTacho * LEFT_RADIUS - rightTacho * RIGHT_RADIUS) / WIDTH * Math.PI / 180.0;
+	}
 }
diff --git a/src/manager/HardwareManager.java b/src/manager/HardwareManager.java
index 2805d4e..6ecb659 100644
--- a/src/manager/HardwareManager.java
+++ b/src/manager/HardwareManager.java
@@ -1,5 +1,8 @@
 package manager;
 
+import lejos.nxt.ColorSensor;
+import lejos.nxt.NXTRegulatedMotor;
+import lejos.nxt.UltrasonicSensor;
 import hardwareAbstraction.*;
 
 public class HardwareManager {
@@ -11,7 +14,7 @@ public class HardwareManager {
 	public UltrasonicMotor ultrasonicMotor;
 	public ColorPoller colorPoller;
 	public LinePoller linePoller;
-	public UltrasonicPoller ultrasonicPoller;
+	public UltrasonicPoller ultrasonicPoller;	
 	
 	public HardwareManager(Manager manager) {
 		this.manager = manager;
diff --git a/src/manager/UtilityManager.java b/src/manager/UtilityManager.java
index abdf7c0..f3f08bd 100644
--- a/src/manager/UtilityManager.java
+++ b/src/manager/UtilityManager.java
@@ -13,7 +13,7 @@ public class UtilityManager {
 	public UtilityManager(Manager manager) {
 		this.manager = manager;
 		this.bt = new BluetoothTransmission();
-		this.comLink = new Communicator();
+		this.comLink = new Communicator(Settings.NXTSlaveName);
 		this.map = new Map();
 	}
 }
diff --git a/src/services/Odometer.java b/src/services/Odometer.java
index aa47923..010b464 100644
--- a/src/services/Odometer.java
+++ b/src/services/Odometer.java
@@ -1,10 +1,151 @@
 package services;
 
+import lejos.nxt.NXTRegulatedMotor;
+import lejos.util.Timer;
+import lejos.util.TimerListener;
 import manager.*;
+import utilities.*;
+import hardwareAbstraction.Drive;
 
-public class Odometer {
+/**
+ * Odometer -> keeps track of the robot's current position
+ * modified from the odometer code given in Lab 4
+ * 
+ * @author Riley
+ *
+ */
 
-	public Odometer(Manager manager) {
+public class Odometer implements TimerListener {
+	private Timer timer;
+	private Drive drive;
+	
+	private final int UPDATE_PERIOD = 25;
+	
+	private Object lock;
+	private double x, y, theta;
+	private double [] oldDH, dDH;
+
+	public Odometer(Manager manager) {		
+		x = 0.0;
+		y = 0.0;
+		theta = Math.PI/2;
+		oldDH = new double [2];
+		dDH = new double [2];
+		lock = new Object();
+		drive = manager.hm.drive;
+		timer = new Timer(UPDATE_PERIOD, this);
+		timer.start();
+	}
+	
+	/**
+	 * Updates the odometer every UPDATE_PERIOD
+	 */
+	public void timedOut() {
+		drive.getDisplacementAndHeading(dDH);
+		//change in displacement and heading
+		dDH[0] -= oldDH[0];
+		dDH[1] -= oldDH[1];
+		
+		// update the position in a critical region
+		synchronized (lock) {
+			theta -= dDH[1];
+			theta = Angle.principleAngle(theta);
+			
+			x += dDH[0] * Math.cos(theta);
+			y += dDH[0] * Math.sin(theta);
+		}
 		
+		//update old displacement and heading
+		oldDH[0] += dDH[0];
+		oldDH[1] += dDH[1];
+		
+	}
+	
+	/**
+	 * returns current position of the robot
+	 * @param pos
+	 */
+	public Position getPosition() {
+		Position pos = new Position();
+		synchronized (lock) {
+			pos.x = x;
+			pos.y = y;
+			pos.theta = theta;
+		}
+		
+		return pos;
+	}
+	
+	/**
+	 * returns the current heading of the robot
+	 * @return
+	 */
+	public double getTheta() {
+		double result;
+
+		synchronized (lock) {
+			result = theta;
+		}
+
+		return result;
+	}
+	
+	/**
+	 * returns current y coordinate of the robot
+	 * @return
+	 */
+	public double getY() {
+		double result;
+
+		synchronized (lock) {
+			result = y;
+		}
+
+		return result;
+	}
+	
+	/**
+	 * returns current x coordinate of the robot
+	 * @return
+	 */
+	public double getX() {
+		double result;
+
+		synchronized (lock) {
+			result = x;
+		}
+
+		return result;
+	}
+	
+	/**
+	 * set the current position
+	 * @param pos
+	 * @param update
+	 */
+	public void setPosition(Position pos) {
+		synchronized (lock) {
+			x = pos.x;
+			y = pos.y;
+			theta = pos.theta;
+		}
+	}
+	
+	/**
+	 * Adjust the current position by:
+	 * @param dx
+	 * @param dy
+	 * @param dTheta
+	 */
+	public void adjustPosition(double dx, double dy, double dTheta) {
+		synchronized (lock) {
+			x += dx;
+			y += dy;
+			theta += dTheta;
+		}
 	}
+	
+	
+	
+	
 }
diff --git a/src/utilities/Angle.java b/src/utilities/Angle.java
index d9d0097..882f2a9 100644
--- a/src/utilities/Angle.java
+++ b/src/utilities/Angle.java
@@ -1,5 +1,38 @@
 package utilities;
 
+/**
+ * 
+ * The class contains helper methods for finding the principle angle & the minimum Angle
+ * The code is modified from the Odometer given in Lab 4
+ * 
+ * @author Riley
+ *
+ */
 public class Angle {
 
+	/**
+	 * Ensures angle is always in [0, 2PI)
+	 * @param angle to convert
+	 * @return
+	 */
+	public static double principleAngle(double angle) {		
+		if (angle < 0.0)
+			angle = 2*Math.PI + (angle % Math.PI);
+		
+		return angle % Math.PI;
+	}
+	/**
+	 * Returns the minimum angle
+	 * @param a Angle 1
+	 * @param b Angle 2
+	 * @return
+	 */
+	public static double minimumAngle(double a, double b) {
+		double d = principleAngle(b - a);
+		
+		if (d < Math.PI)
+			return d;
+		else
+			return d - 2*Math.PI;
+	}
 }
diff --git a/src/utilities/Communicator.java b/src/utilities/Communicator.java
index 4c12a7d..82a4f33 100644
--- a/src/utilities/Communicator.java
+++ b/src/utilities/Communicator.java
@@ -2,4 +2,7 @@ package utilities;
 
 public class Communicator {
 
+	public Communicator(String slaveNXT) {
+		
+	}
 }
diff --git a/src/utilities/Point.java b/src/utilities/Point.java
index f8c7468..c75fb48 100644
--- a/src/utilities/Point.java
+++ b/src/utilities/Point.java
@@ -1,5 +1,20 @@
 package utilities;
 
 public class Point  {
-
+	public double x;
+	public double y;
+	
+	public Point(double x, double y) {
+		this.x = x;
+		this.y = y;
+	}
+	
+	public Point() {
+		this.x = Double.NaN;
+		this.y = Double.NaN;
+	}
+	
+	public String toString() {
+		return "{x:" + x + ", y:" + y + "}";
+	}
 }
diff --git a/src/utilities/Position.java b/src/utilities/Position.java
index 8255714..66f913d 100644
--- a/src/utilities/Position.java
+++ b/src/utilities/Position.java
@@ -2,4 +2,21 @@ package utilities;
 
 public class Position extends Point {
 
+	public double theta;
+	
+	public Position (double x, double y, double theta) {
+		this.x = x;
+		this.y = y;
+		this.theta = theta;
+	}
+	
+	public Position() {
+		this.x = Double.NaN;
+		this.y = Double.NaN;
+		this.theta = Double.NaN;
+	}
+	
+	public String toString() {
+		return "{x:" + x + ", y:" + y + ", theta:" + theta + "}";
+	}
 }
diff --git a/src/utilities/Settings.java b/src/utilities/Settings.java
index 54bfa96..4a3e2c9 100644
--- a/src/utilities/Settings.java
+++ b/src/utilities/Settings.java
@@ -1,5 +1,25 @@
 package utilities;
 
+import lejos.nxt.ColorSensor;
+import lejos.nxt.NXTRegulatedMotor;
+import lejos.nxt.UltrasonicSensor;
+
 public class Settings {
 
+	public static ColorSensor frontColorSensor;
+	public static ColorSensor rearLeftColorSensor;
+	public static ColorSensor rearRightColorSensor;
+	
+	public static UltrasonicSensor leftUltrasonic;
+	public static UltrasonicSensor centerUltrasonic;
+	public static UltrasonicSensor rightUltrasonic;
+	
+	public static NXTRegulatedMotor leftDriveMotor;
+	public static NXTRegulatedMotor rightDriveMotor;
+	public static NXTRegulatedMotor forkliftMotor;
+	public static NXTRegulatedMotor ultrasonicMotor;
+	public static NXTRegulatedMotor clawMotor;
+	
+	public static final String NXTSlaveName = "NXT";
+	
 }

commit 7f645c9cab7a7e8eff3355287b2a126888002215
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Thu Nov 7 10:56:26 2013 -0500

    Small edits to pause Navigation when executing scanAhead.

diff --git a/src/services/Navigation.java b/src/services/Navigation.java
index cdbb513..8a3cfdf 100644
--- a/src/services/Navigation.java
+++ b/src/services/Navigation.java
@@ -4,6 +4,7 @@ import java.util.Stack;
 
 import utilities.*;
 import controllers.State;
+import lejos.util.Timer;
 import lejos.util.TimerListener;
 import manager.*;
 
@@ -26,6 +27,7 @@ public class Navigation implements TimerListener {
 	private Manager manager;
 	private Odometer odo;
 	private Point nextDestination;
+	private Timer time;
 
 	private double[] pos;
 	private double dX;
@@ -39,6 +41,9 @@ public class Navigation implements TimerListener {
 		this.route = initializeRoute();
 		this.odo = manager.sm.odo;
 		this.pos = new double[3];
+		this.time = new Timer(100, this);
+		//start navigation right away
+		this.time.start();
 	}
 
 	// TODO an initializer of default points should be constructed here.
@@ -55,7 +60,7 @@ public class Navigation implements TimerListener {
 			// if navigation must be done
 			if (manager.cm.getState() == State.SEARCH
 					|| manager.cm.getState() == State.DROP_OFF) {
-				// update the changes in heading
+				// update the new headings to travel to
 				setupDeltaPositonAndHeading();
 				// see if we need to make a big turn
 				if (Math.abs(dH) > 5) {
@@ -67,8 +72,11 @@ public class Navigation implements TimerListener {
 					turnTo();
 				} else if (Math.abs(dX) > 1 || Math.abs(dY) > 1) {
 					//scan ahead only once facing the correct orientation, then travelTo that destination.
-					if (!scannedAhead)
+					if (!scannedAhead) {
+						pause();
 						manager.sm.obstacleAvoidance.scanAhead();
+						start();
+					}
 					travelTo();
 				} else {
 					//stop the motors, reset scanning state and get next destination. 
@@ -80,6 +88,14 @@ public class Navigation implements TimerListener {
 		}
 	}
 	
+	private void pause() {
+		this.time.stop();
+	}
+	
+	private void start() {
+		this.time.start();
+	}
+	
 	private void setupDeltaPositonAndHeading() {
 		odo.getPosition(pos);
 

commit 60469c55d31f3223d3eff80893c2202f0280d879
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Thu Nov 7 10:41:00 2013 -0500

    Made navigation based upon previous code of Team 15. Created method
    stubs for the moment.

diff --git a/src/services/Navigation.java b/src/services/Navigation.java
index 1260075..cdbb513 100644
--- a/src/services/Navigation.java
+++ b/src/services/Navigation.java
@@ -24,17 +24,21 @@ import manager.*;
 public class Navigation implements TimerListener {
 	private Stack<Point> route;
 	private Manager manager;
-	private Point nextDestination;
 	private Odometer odo;
+	private Point nextDestination;
 
-	private static boolean navigating = false;
-	private static boolean turning = false;
-	private boolean paused = false;
+	private double[] pos;
+	private double dX;
+	private double dY;
+	private double dH;
+
+	private boolean scannedAhead;
 
 	public Navigation(Manager manager) {
 		this.manager = manager;
 		this.route = initializeRoute();
 		this.odo = manager.sm.odo;
+		this.pos = new double[3];
 	}
 
 	// TODO an initializer of default points should be constructed here.
@@ -44,237 +48,144 @@ public class Navigation implements TimerListener {
 
 	@Override
 	public void timedOut() {
-		//for the moment, I am not sure why this is timed out. Why is this not in search algorithm and used as a utility. I obviously did not get the memo.
-		//
-//		if (!navigating) {
+		nextDestination = route.peek();
+		if (nextDestination == null) {
+			// nothing is done
+		} else {
+			// if navigation must be done
 			if (manager.cm.getState() == State.SEARCH
 					|| manager.cm.getState() == State.DROP_OFF) {
-//				navigating = true;
-				if (nextDestination == null)
-					nextDestination = route.pop();
-				turnTo(nextDestination.angleTo(odo.getPosition()));
-				travelTo(nextDestination);
-//			}
-		}
-	}
-
-	public void travelTo(Point xy) {
-		double x = xy.getX();
-		double y = xy.getY();
-
-		// we're navigating
-		navigating = true;
-
-		long correctionStart, correctionEnd;
-
-		// main loop
-		travelLoop: while (navigating) {
-			correctionStart = System.currentTimeMillis();
-
-			if (!paused) {
-
-				/*
-				 * retrieve current position and calculate dX and dY
-				 */
-				double[] pos = new double[3];
-
-				odo.getPosition(pos);
-
-				double currentX = pos[0];
-				double currentY = pos[1];
-				double currentTheta = pos[2];
-
-				// Distance between where we are and where we need to travel to
-				double dX = x - currentX;
-				double dY = y - currentY;
-
-				/*
-				 * if within 0.5cm (x&y) of the destination x,y stop otherwise
-				 * continuing traveling
-				 */
-				if (Math.abs(dX) < 1 && Math.abs(dY) < 1) {
-					navigating = false;
+				// update the changes in heading
+				setupDeltaPositonAndHeading();
+				// see if we need to make a big turn
+				if (Math.abs(dH) > 5) {
+					// if we need to turn more than 0.2 rads or 0.1 for
+					// completing a turn, call the turnTo method
+					// otherwise we can adjust small angle errors by slowing
+					// one
+					// wheel down slightly
+					turnTo();
+				} else if (Math.abs(dX) > 1 || Math.abs(dY) > 1) {
+					//scan ahead only once facing the correct orientation, then travelTo that destination.
+					if (!scannedAhead)
+						manager.sm.obstacleAvoidance.scanAhead();
+					travelTo();
+				} else {
+					//stop the motors, reset scanning state and get next destination. 
 					robot.stop();
-					break travelLoop;
+					scannedAhead = false;
+					route.pop();
 				}
-				/*
-				 * We are not at our destination and the path is clear
-				 */
-				else {
-
-					// the required theta to travel to our destination
-					double theta = Math.atan2(dY, dX) * 180.0 / Math.PI;
-					// adjust to [0, 360]
-					theta = (theta < 0) ? 360 + theta : theta;
-
-					// error in theta
-					double deltaTheta = theta - currentTheta;
-
-					// Change deltaTheta to [0,360)
-					if (deltaTheta > 180) {
-						deltaTheta -= 360;
-					} else if (deltaTheta < -180) {
-						deltaTheta += 360;
-					}
-
-					// see if we need to make a big turn
-					if (Math.abs(deltaTheta) > 5) {
-						// if we need to turn more than 0.2 rads or 0.1 for
-						// completing a turn, call the turnTo method
-						// otherwise we can adjust small angle errors by slowing
-						// one
-						// wheel down slightly
-						turnTo(theta);
-
-					}
-					// We need to go straight (or relatively straight)
-					else {
-
-						/*
-						 * For minor angle corrections
-						 */
-
-						// amount to change right wheel speed by
-						int dL = 0;
-
-						// If angle error is greater than 3 deg, make adjustment
-						if (Math.abs(deltaTheta) > 0.5) {
-
-							// if we are facing to the left of where we should
-							// be,
-							// slight right
-							if (deltaTheta > 0) {
-
-								dL = -5;
-							}
+			}
+		}
+	}
+	
+	private void setupDeltaPositonAndHeading() {
+		odo.getPosition(pos);
+
+		double currentX = pos[0];
+		double currentY = pos[1];
+		double currentTheta = pos[2];
+
+		// Distance between where we are and where we need to travel to
+		dX = nextDestination.getX() - currentX;
+		dY = nextDestination.getY() - currentY;
+
+		// the required theta to travel to our destination
+		double theta = Math.atan2(dY, dX) * 180.0 / Math.PI;
+		// adjust to [0, 360]
+		theta = (theta < 0) ? 360 + theta : theta;
+
+		// error in theta
+		dH = theta - currentTheta;
+
+		// Change deltaTheta to [0,360)
+		if (dH > 180) {
+			dH -= 360;
+		} else if (dH < -180) {
+			dH += 360;
+		}
+	}
 
-							// if we are facing to the right of where we should
-							// be,
-							// slight left
-							else if (deltaTheta < 0) {
+	public void travelTo() {
+		/*
+		 * For minor angle corrections
+		 */
 
-								dL = 5;
-							}
-						}
+		// amount to change right wheel speed by
+		int dL = 0;
 
-						/*
-						 * End minor angle corrections
-						 */
+		// If angle error is greater than 3 deg, make adjustment
+		if (Math.abs(dH) > 0.5) {
 
-						// Distance to destination
-						double distanceToTravel = (dX * Math.cos(Math
-								.toRadians(currentTheta)))
-								+ (dY * Math.sin(Math.toRadians(currentTheta)));
-						// high speed
-						if (distanceToTravel > 3) {
-							robot.setSpeeds(MAX_FORWARD_SPEED, dL);
-						}
-						// start to slow down
-						else if (distanceToTravel > 1) {
-							robot.setSpeeds(MAX_FORWARD_SPEED / 2, dL);
-						}
-						// go really slow, so that we don't overshoot
-						else {
-							robot.setSpeeds(MAX_FORWARD_SPEED / 5, dL / 3);
-						}
+			// if we are facing to the left of where we should
+			// be,
+			// slight right
+			if (dH > 0) {
 
-					}
-				}
-			}
-			// paused
-			else {
-				robot.setSpeeds(0, 0);
+				dL = -5;
 			}
 
-			// this ensure the odometry correction occurs only once every
-			// period
+			// if we are facing to the right of where we should
+			// be,
+			// slight left
+			else if (dH < 0) {
 
-			correctionEnd = System.currentTimeMillis();
-
-			if (correctionEnd - correctionStart < UPDATE_PERIOD) {
-				try {
-					Thread.sleep(UPDATE_PERIOD
-							- (correctionEnd - correctionStart));
-				} catch (InterruptedException e) {
-					// there is nothing to be done here because it is not
-					// expected that the odometry correction will be
-					// interrupted by another thread
-				}
+				dL = 5;
 			}
 		}
-	}
-
-	public void turnTo(double angle) {
-
-		// we are turning
-		if (!turning)
-			turning = true;
-
-		long correctionStart, correctionEnd;
 
-		// main loop
-		while (turning) {
-			correctionStart = System.currentTimeMillis();
-
-			if (!paused) {
+		/*
+		 * End minor angle corrections
+		 */
+
+		// Distance to destination
+		double currentTheta = pos[2];
+		double distanceToTravel = (dX * Math.cos(Math.toRadians(currentTheta)))
+				+ (dY * Math.sin(Math.toRadians(currentTheta)));
+		// high speed
+		if (distanceToTravel > 3) {
+			robot.setSpeeds(MAX_FORWARD_SPEED, dL);
+		}
+		// start to slow down
+		else if (distanceToTravel > 1) {
+			robot.setSpeeds(MAX_FORWARD_SPEED / 2, dL);
+		}
+		// go really slow, so that we don't overshoot
+		else {
+			robot.setSpeeds(MAX_FORWARD_SPEED / 5, dL / 3);
+		}
 
-				// error in angle
-				double deltaTheta = angle - odometer.getTheta();
+	}
 
-				// convert to [-180,180] for minimal angle
-				if (deltaTheta > 180) {
-					deltaTheta -= 360;
-				} else if (deltaTheta < -180) {
-					deltaTheta += 360;
-				}
+	public void turnTo() {
 
-				// if angle error greater than 1 deg
-				if (Math.abs(deltaTheta) >= 1) {
-					// if error positive and greater than 5 deg -> max speed CCW
-					if (deltaTheta > 8) {
-						robot.setSpeeds(0, -MAX_ROTATE_SPEED);
-					}
-					// positive error, but close to 0, so turn slow CCW to
-					// prevent
-					// overshoot
-					else if (deltaTheta > 0) {
-						robot.setSpeeds(0, -MAX_ROTATE_SPEED / 4);
-					}
-					// error negative and less than 5deg -> max speed CW
-					else if (deltaTheta < -8) {
-						robot.setSpeeds(0, MAX_ROTATE_SPEED);
-					}
-					// negative error, but close to 0, so turn slow CW to
-					// prevent
-					// overshoot
-					else if (deltaTheta < 0) {
-						robot.setSpeeds(0, MAX_ROTATE_SPEED / 4);
-					}
-				} else {
-					// we have finished turning
-					turning = false;
-					robot.stop();
-				}
+		// if angle error greater than 1 deg
+		if (Math.abs(dH) >= 1) {
+			// if error positive and greater than 5 deg -> max speed CCW
+			if (dH > 8) {
+				robot.setSpeeds(0, -MAX_ROTATE_SPEED);
 			}
-			// paused
-			else {
-				robot.setSpeeds(0, 0);
+			// positive error, but close to 0, so turn slow CCW to
+			// prevent
+			// overshoot
+			else if (dH > 0) {
+				robot.setSpeeds(0, -MAX_ROTATE_SPEED / 4);
 			}
-			// this ensure the odometry correction occurs only once every period
-			correctionEnd = System.currentTimeMillis();
-
-			if (correctionEnd - correctionStart < UPDATE_PERIOD) {
-				try {
-					Thread.sleep(UPDATE_PERIOD
-							- (correctionEnd - correctionStart));
-				} catch (InterruptedException e) {
-					// there is nothing to be done here because it is not
-					// expected that the odometry correction will be
-					// interrupted by another thread
-				}
+			// error negative and less than 5deg -> max speed CW
+			else if (dH < -8) {
+				robot.setSpeeds(0, MAX_ROTATE_SPEED);
+			}
+			// negative error, but close to 0, so turn slow CW to
+			// prevent
+			// overshoot
+			else if (dH < 0) {
+				robot.setSpeeds(0, MAX_ROTATE_SPEED / 4);
 			}
+		} else {
+			// we have finished turning
+			robot.stop();
 		}
-
 	}
 
 }
diff --git a/src/services/ObstacleAvoidance.java b/src/services/ObstacleAvoidance.java
index 1bad4a5..fbe7cb6 100644
--- a/src/services/ObstacleAvoidance.java
+++ b/src/services/ObstacleAvoidance.java
@@ -25,4 +25,9 @@ public class ObstacleAvoidance {
 	public ObstacleAvoidance(Manager manager) {
 		
 	}
+	
+	//TODO complete this stub.
+	public void scanAhead() {
+		
+	}
 }
diff --git a/src/services/Odometer.java b/src/services/Odometer.java
index aa47923..8f3acbd 100644
--- a/src/services/Odometer.java
+++ b/src/services/Odometer.java
@@ -7,4 +7,9 @@ public class Odometer {
 	public Odometer(Manager manager) {
 		
 	}
+	
+	//TODO complete this stub.
+	public double[] getPosition(double[] pos) {
+		return pos;
+	}
 }

commit 869d8a54c0c531f0e34b611c370a9ab17293c9eb
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Wed Nov 6 15:38:43 2013 -0500

    Created getter and setter.

diff --git a/src/manager/ControllerManager.java b/src/manager/ControllerManager.java
index 8578e1c..4e8f0a5 100644
--- a/src/manager/ControllerManager.java
+++ b/src/manager/ControllerManager.java
@@ -47,4 +47,13 @@ public class ControllerManager implements TimerListener {
 	public void stop() {
 		timer.stop();
 	}
+
+	public State getState() {
+		return state;
+	}
+
+	public void setState(State state) {
+		this.state = state;
+	}
+	
 }

commit 1fe602bbcdd3fc97a843e17ce7fe6c13b3459bef
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Wed Nov 6 15:38:28 2013 -0500

    Point class was created. Please note the X and Y values and their
    orientation. Programming Guide Specifications contains a quick note on
    the orientation definitions.

diff --git a/src/utilities/Point.java b/src/utilities/Point.java
index f8c7468..a34d0b3 100644
--- a/src/utilities/Point.java
+++ b/src/utilities/Point.java
@@ -1,5 +1,35 @@
 package utilities;
 
 public class Point  {
+	private double x;
+	private double y;
+	
+	public Point(double x, double y) {
+		this.x = x;
+		this.y = y;
+	}
+	
+	public double angleTo(Point xy) {
+		double dx = this.getX() - xy.getX();
+		double dy = this.getY() - xy.getY();
+		return Math.tan(dx/dy);
+	}
+
+	public double getX() {
+		return x;
+	}
+
+	public void setX(double x) {
+		this.x = x;
+	}
+
+	public double getY() {
+		return y;
+	}
+
+	public void setY(double y) {
+		this.y = y;
+	}
+	
 
 }

commit 1e9a46596d38d7a50eff19bdf5b32cee5deb3e2a
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Wed Nov 6 15:37:30 2013 -0500

    Copied over the code from Team 15, began writing the timedOut() method.
    Questions will be noted.

diff --git a/src/services/Navigation.java b/src/services/Navigation.java
index 8cd94a9..1260075 100644
--- a/src/services/Navigation.java
+++ b/src/services/Navigation.java
@@ -1,30 +1,280 @@
 package services;
 
+import java.util.Stack;
+
+import utilities.*;
+import controllers.State;
+import lejos.util.TimerListener;
 import manager.*;
 
 /**
  * 
- * needs to implement 
- * timerlistener 
- * stack<Point> route
- * timedOut (calls turnTo or travelTo + obstacleAvoidance scan() depending on what one is needed) && only be called while state is State.SEARCH || State.DROP_OFF
- * turnTo
- * travelTo
+ * needs to implement timerlistener stack<Point> route timedOut (calls turnTo or
+ * travelTo + obstacleAvoidance scan() depending on what one is needed) && only
+ * be called while state is State.SEARCH || State.DROP_OFF turnTo travelTo
+ * 
+ * Once turn to face the direction to a new point, confer with obstacle
+ * avoidance to scanAhead()
  * 
- * Once turn to face the direction to a new point, confer with obstacle avoidance to scanAhead()
  * 
  * 
+ * @author
  * 
- * @author 
- *
  */
-public class Navigation {
+public class Navigation implements TimerListener {
+	private Stack<Point> route;
+	private Manager manager;
+	private Point nextDestination;
+	private Odometer odo;
+
+	private static boolean navigating = false;
+	private static boolean turning = false;
+	private boolean paused = false;
 
 	public Navigation(Manager manager) {
-		
+		this.manager = manager;
+		this.route = initializeRoute();
+		this.odo = manager.sm.odo;
+	}
+
+	// TODO an initializer of default points should be constructed here.
+	private Stack<Point> initializeRoute() {
+		return new Stack<Point>();
+	}
+
+	@Override
+	public void timedOut() {
+		//for the moment, I am not sure why this is timed out. Why is this not in search algorithm and used as a utility. I obviously did not get the memo.
+		//
+//		if (!navigating) {
+			if (manager.cm.getState() == State.SEARCH
+					|| manager.cm.getState() == State.DROP_OFF) {
+//				navigating = true;
+				if (nextDestination == null)
+					nextDestination = route.pop();
+				turnTo(nextDestination.angleTo(odo.getPosition()));
+				travelTo(nextDestination);
+//			}
+		}
+	}
+
+	public void travelTo(Point xy) {
+		double x = xy.getX();
+		double y = xy.getY();
+
+		// we're navigating
+		navigating = true;
+
+		long correctionStart, correctionEnd;
+
+		// main loop
+		travelLoop: while (navigating) {
+			correctionStart = System.currentTimeMillis();
+
+			if (!paused) {
+
+				/*
+				 * retrieve current position and calculate dX and dY
+				 */
+				double[] pos = new double[3];
+
+				odo.getPosition(pos);
+
+				double currentX = pos[0];
+				double currentY = pos[1];
+				double currentTheta = pos[2];
+
+				// Distance between where we are and where we need to travel to
+				double dX = x - currentX;
+				double dY = y - currentY;
+
+				/*
+				 * if within 0.5cm (x&y) of the destination x,y stop otherwise
+				 * continuing traveling
+				 */
+				if (Math.abs(dX) < 1 && Math.abs(dY) < 1) {
+					navigating = false;
+					robot.stop();
+					break travelLoop;
+				}
+				/*
+				 * We are not at our destination and the path is clear
+				 */
+				else {
+
+					// the required theta to travel to our destination
+					double theta = Math.atan2(dY, dX) * 180.0 / Math.PI;
+					// adjust to [0, 360]
+					theta = (theta < 0) ? 360 + theta : theta;
+
+					// error in theta
+					double deltaTheta = theta - currentTheta;
+
+					// Change deltaTheta to [0,360)
+					if (deltaTheta > 180) {
+						deltaTheta -= 360;
+					} else if (deltaTheta < -180) {
+						deltaTheta += 360;
+					}
+
+					// see if we need to make a big turn
+					if (Math.abs(deltaTheta) > 5) {
+						// if we need to turn more than 0.2 rads or 0.1 for
+						// completing a turn, call the turnTo method
+						// otherwise we can adjust small angle errors by slowing
+						// one
+						// wheel down slightly
+						turnTo(theta);
+
+					}
+					// We need to go straight (or relatively straight)
+					else {
+
+						/*
+						 * For minor angle corrections
+						 */
+
+						// amount to change right wheel speed by
+						int dL = 0;
+
+						// If angle error is greater than 3 deg, make adjustment
+						if (Math.abs(deltaTheta) > 0.5) {
+
+							// if we are facing to the left of where we should
+							// be,
+							// slight right
+							if (deltaTheta > 0) {
+
+								dL = -5;
+							}
+
+							// if we are facing to the right of where we should
+							// be,
+							// slight left
+							else if (deltaTheta < 0) {
+
+								dL = 5;
+							}
+						}
+
+						/*
+						 * End minor angle corrections
+						 */
+
+						// Distance to destination
+						double distanceToTravel = (dX * Math.cos(Math
+								.toRadians(currentTheta)))
+								+ (dY * Math.sin(Math.toRadians(currentTheta)));
+						// high speed
+						if (distanceToTravel > 3) {
+							robot.setSpeeds(MAX_FORWARD_SPEED, dL);
+						}
+						// start to slow down
+						else if (distanceToTravel > 1) {
+							robot.setSpeeds(MAX_FORWARD_SPEED / 2, dL);
+						}
+						// go really slow, so that we don't overshoot
+						else {
+							robot.setSpeeds(MAX_FORWARD_SPEED / 5, dL / 3);
+						}
+
+					}
+				}
+			}
+			// paused
+			else {
+				robot.setSpeeds(0, 0);
+			}
+
+			// this ensure the odometry correction occurs only once every
+			// period
+
+			correctionEnd = System.currentTimeMillis();
+
+			if (correctionEnd - correctionStart < UPDATE_PERIOD) {
+				try {
+					Thread.sleep(UPDATE_PERIOD
+							- (correctionEnd - correctionStart));
+				} catch (InterruptedException e) {
+					// there is nothing to be done here because it is not
+					// expected that the odometry correction will be
+					// interrupted by another thread
+				}
+			}
+		}
 	}
-	
-	
-	
-	
+
+	public void turnTo(double angle) {
+
+		// we are turning
+		if (!turning)
+			turning = true;
+
+		long correctionStart, correctionEnd;
+
+		// main loop
+		while (turning) {
+			correctionStart = System.currentTimeMillis();
+
+			if (!paused) {
+
+				// error in angle
+				double deltaTheta = angle - odometer.getTheta();
+
+				// convert to [-180,180] for minimal angle
+				if (deltaTheta > 180) {
+					deltaTheta -= 360;
+				} else if (deltaTheta < -180) {
+					deltaTheta += 360;
+				}
+
+				// if angle error greater than 1 deg
+				if (Math.abs(deltaTheta) >= 1) {
+					// if error positive and greater than 5 deg -> max speed CCW
+					if (deltaTheta > 8) {
+						robot.setSpeeds(0, -MAX_ROTATE_SPEED);
+					}
+					// positive error, but close to 0, so turn slow CCW to
+					// prevent
+					// overshoot
+					else if (deltaTheta > 0) {
+						robot.setSpeeds(0, -MAX_ROTATE_SPEED / 4);
+					}
+					// error negative and less than 5deg -> max speed CW
+					else if (deltaTheta < -8) {
+						robot.setSpeeds(0, MAX_ROTATE_SPEED);
+					}
+					// negative error, but close to 0, so turn slow CW to
+					// prevent
+					// overshoot
+					else if (deltaTheta < 0) {
+						robot.setSpeeds(0, MAX_ROTATE_SPEED / 4);
+					}
+				} else {
+					// we have finished turning
+					turning = false;
+					robot.stop();
+				}
+			}
+			// paused
+			else {
+				robot.setSpeeds(0, 0);
+			}
+			// this ensure the odometry correction occurs only once every period
+			correctionEnd = System.currentTimeMillis();
+
+			if (correctionEnd - correctionStart < UPDATE_PERIOD) {
+				try {
+					Thread.sleep(UPDATE_PERIOD
+							- (correctionEnd - correctionStart));
+				} catch (InterruptedException e) {
+					// there is nothing to be done here because it is not
+					// expected that the odometry correction will be
+					// interrupted by another thread
+				}
+			}
+		}
+
+	}
+
 }

commit cecd59756a6b5975885c3cce968a022371544227
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Wed Nov 6 14:13:01 2013 -0500

    Begun a ColorPoller class based on code that already exists.

diff --git a/src/hardwareAbstraction/ColorPoller.java b/src/hardwareAbstraction/ColorPoller.java
index e6f58a3..ccd4d2a 100644
--- a/src/hardwareAbstraction/ColorPoller.java
+++ b/src/hardwareAbstraction/ColorPoller.java
@@ -1,5 +1,47 @@
 package hardwareAbstraction;
 
-public class ColorPoller {
+import lejos.nxt.ColorSensor;
+import lejos.robotics.Color;
+import lejos.util.Timer;
+import lejos.util.TimerListener;
 
-}
+public class ColorPoller implements TimerListener {
+	private ColorSensor cs;
+	private Timer poller;
+	private int poleRate;
+	private int[] readings;
+
+	public ColorPoller(ColorSensor cs, int poleRate) {
+		this.cs = cs;
+		this.readings = new int[5];
+		this.poller = new Timer(poleRate, this);
+	}
+	
+	public void start() {
+		this.poller = new Timer(poleRate, this);
+		this.poller.start();
+	}
+	
+	public void stop() {
+		this.poller = null;
+	}
+
+	@Override
+	public void timedOut() {
+		int red, blue;
+		Color color = cs.getColor();
+		red = color.getRed();
+		blue = color.getBlue();
+		double proportion = (double)red/blue;
+		proportion *= 100;
+		addReading((int) proportion);
+	}
+	
+	private void addReading(int shiftedProportion) {
+		readings[4] = readings[3];
+		readings[3] = readings[2];
+		readings[2] = readings[1];
+		readings[1] = readings[0];
+		readings[0] = shiftedProportion;
+	}
+}
\ No newline at end of file

commit 98c378ac8f29352d75b1394a876fff6af7692026
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Wed Nov 6 13:20:59 2013 -0500

    Should now be compilable as a Lejos project.

diff --git a/.classpath b/.classpath
index 2c8e260..3dbabe6 100644
--- a/.classpath
+++ b/.classpath
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <classpath>
 	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.launching.macosx.MacOSXType/Java SE 6 [1.6.0_51-b11-457]"/>
+	<classpathentry kind="con" path="org.lejos.nxt.ldt.LEJOS_LIBRARY_CONTAINER/nxt"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>
diff --git a/.project b/.project
index c3c3cd2..331712e 100644
--- a/.project
+++ b/.project
@@ -10,8 +10,14 @@
 			<arguments>
 			</arguments>
 		</buildCommand>
+		<buildCommand>
+			<name>org.lejos.nxt.ldt.leJOSBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
 	</buildSpec>
 	<natures>
+		<nature>org.lejos.nxt.ldt.leJOSNature</nature>
 		<nature>org.eclipse.jdt.core.javanature</nature>
 	</natures>
 </projectDescription>

commit 4c2b7834d20fcaa917f93a292a283b1b90df2bf7
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Wed Nov 6 13:11:17 2013 -0500

    Configured .project/.classpath file to be compilable in eclipse. Master
    branch should now be compilable on your local machine.

diff --git a/.classpath b/.classpath
new file mode 100644
index 0000000..2c8e260
--- /dev/null
+++ b/.classpath
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.launching.macosx.MacOSXType/Java SE 6 [1.6.0_51-b11-457]"/>
+	<classpathentry kind="output" path="bin"/>
+</classpath>
diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..5e56e04
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1 @@
+/bin
diff --git a/.project b/.project
new file mode 100644
index 0000000..c3c3cd2
--- /dev/null
+++ b/.project
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>ECSE-211-Team-5</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>

commit 4bac7e9c33e651c188dfca451b310c07805b23a2
Author: RileyvanRyswyk <rileyvan@gmail.com>
Date:   Wed Nov 6 00:31:29 2013 -0500

    A start, but much more work required

diff --git a/src/controllers/Collect.java b/src/controllers/Collect.java
new file mode 100644
index 0000000..b0702ab
--- /dev/null
+++ b/src/controllers/Collect.java
@@ -0,0 +1,15 @@
+package controllers;
+
+import manager.Manager;
+
+public class Collect extends Controller {
+
+private Manager manager;
+	
+	public Collect(Manager manager) {
+		this.manager = manager;
+	}
+	
+	public void run() {
+	}
+}
diff --git a/src/controllers/Controller.java b/src/controllers/Controller.java
new file mode 100644
index 0000000..bfe4128
--- /dev/null
+++ b/src/controllers/Controller.java
@@ -0,0 +1,5 @@
+package controllers;
+
+public abstract class Controller implements ControllerInterface {
+
+}
diff --git a/src/controllers/ControllerInterface.java b/src/controllers/ControllerInterface.java
new file mode 100644
index 0000000..98938d0
--- /dev/null
+++ b/src/controllers/ControllerInterface.java
@@ -0,0 +1,6 @@
+package controllers;
+
+public interface ControllerInterface {
+
+	public void run();
+}
diff --git a/src/controllers/DropOff.java b/src/controllers/DropOff.java
new file mode 100644
index 0000000..2291a3f
--- /dev/null
+++ b/src/controllers/DropOff.java
@@ -0,0 +1,15 @@
+package controllers;
+
+import manager.Manager;
+
+public class DropOff extends Controller {
+
+private Manager manager;
+	
+	public DropOff(Manager manager) {
+		this.manager = manager;
+	}
+	
+	public void run() {
+	}
+}
diff --git a/src/controllers/Recognize.java b/src/controllers/Recognize.java
new file mode 100644
index 0000000..99e1bcd
--- /dev/null
+++ b/src/controllers/Recognize.java
@@ -0,0 +1,15 @@
+package controllers;
+
+import manager.Manager;
+
+public class Recognize extends Controller {
+
+private Manager manager;
+	
+	public Recognize(Manager manager) {
+		this.manager = manager;
+	}
+	
+	public void run() {
+	}
+}
diff --git a/src/controllers/Search.java b/src/controllers/Search.java
new file mode 100644
index 0000000..e528253
--- /dev/null
+++ b/src/controllers/Search.java
@@ -0,0 +1,16 @@
+package controllers;
+
+import manager.Manager;
+
+public class Search extends Controller  {
+
+	private Manager manager;
+	
+	public Search(Manager manager) {
+		this.manager = manager;
+	}
+	
+	public void run() {
+	}
+
+}
diff --git a/src/controllers/State.java b/src/controllers/State.java
new file mode 100644
index 0000000..af5c4c3
--- /dev/null
+++ b/src/controllers/State.java
@@ -0,0 +1,5 @@
+package controllers;
+
+public enum State {
+	SEARCH, RECOGNIZE, COLLECT, DROP_OFF, WALL_FOLLOWER
+}
diff --git a/src/controllers/WallFollower.java b/src/controllers/WallFollower.java
new file mode 100644
index 0000000..f65d540
--- /dev/null
+++ b/src/controllers/WallFollower.java
@@ -0,0 +1,15 @@
+package controllers;
+
+import manager.Manager;
+
+public class WallFollower extends Controller {
+
+private Manager manager;
+	
+	public WallFollower(Manager manager) {
+		this.manager = manager;
+	}
+	
+	public void run() {
+	}
+}
diff --git a/src/hardwareAbstraction/Claw.java b/src/hardwareAbstraction/Claw.java
new file mode 100644
index 0000000..3dcadad
--- /dev/null
+++ b/src/hardwareAbstraction/Claw.java
@@ -0,0 +1,5 @@
+package hardwareAbstraction;
+
+public class Claw {
+
+}
diff --git a/src/hardwareAbstraction/ColorPoller.java b/src/hardwareAbstraction/ColorPoller.java
new file mode 100644
index 0000000..e6f58a3
--- /dev/null
+++ b/src/hardwareAbstraction/ColorPoller.java
@@ -0,0 +1,5 @@
+package hardwareAbstraction;
+
+public class ColorPoller {
+
+}
diff --git a/src/hardwareAbstraction/Drive.java b/src/hardwareAbstraction/Drive.java
new file mode 100644
index 0000000..0d1a206
--- /dev/null
+++ b/src/hardwareAbstraction/Drive.java
@@ -0,0 +1,5 @@
+package hardwareAbstraction;
+
+public class Drive {
+
+}
diff --git a/src/hardwareAbstraction/Forklift.java b/src/hardwareAbstraction/Forklift.java
new file mode 100644
index 0000000..38f5152
--- /dev/null
+++ b/src/hardwareAbstraction/Forklift.java
@@ -0,0 +1,5 @@
+package hardwareAbstraction;
+
+public class Forklift {
+
+}
diff --git a/src/hardwareAbstraction/LinePoller.java b/src/hardwareAbstraction/LinePoller.java
new file mode 100644
index 0000000..dcee143
--- /dev/null
+++ b/src/hardwareAbstraction/LinePoller.java
@@ -0,0 +1,5 @@
+package hardwareAbstraction;
+
+public class LinePoller {
+
+}
diff --git a/src/hardwareAbstraction/UltrasonicMotor.java b/src/hardwareAbstraction/UltrasonicMotor.java
new file mode 100644
index 0000000..261af7e
--- /dev/null
+++ b/src/hardwareAbstraction/UltrasonicMotor.java
@@ -0,0 +1,5 @@
+package hardwareAbstraction;
+
+public class UltrasonicMotor {
+
+}
diff --git a/src/hardwareAbstraction/UltrasonicPoller.java b/src/hardwareAbstraction/UltrasonicPoller.java
new file mode 100644
index 0000000..4c4e8ee
--- /dev/null
+++ b/src/hardwareAbstraction/UltrasonicPoller.java
@@ -0,0 +1,5 @@
+package hardwareAbstraction;
+
+public class UltrasonicPoller {
+
+}
diff --git a/src/launcher/Launcher.java b/src/launcher/Launcher.java
new file mode 100644
index 0000000..e54bf4e
--- /dev/null
+++ b/src/launcher/Launcher.java
@@ -0,0 +1,28 @@
+/**
+ * 
+ */
+package launcher;
+
+import manager.Manager;
+
+/**
+ * 
+ * Main Entry
+ * 
+ * @author Riley
+ *
+ */
+public class Launcher {
+
+	/**
+	 * 
+	 * Robot ignition
+	 * 
+	 * @param args
+	 */
+	public static void main(String[] args) {
+		
+		Manager manager = new Manager();
+	}
+
+}
diff --git a/src/manager/ControllerManager.java b/src/manager/ControllerManager.java
new file mode 100644
index 0000000..8578e1c
--- /dev/null
+++ b/src/manager/ControllerManager.java
@@ -0,0 +1,50 @@
+package manager;
+
+import lejos.util.Timer;
+import lejos.util.TimerListener;
+import controllers.*;
+
+
+/**
+ * 
+ * Manages the controllers.  Throughout the life of the program, the controller corresponding to the current state will be run
+ * It is up to each controller to change the state of a controller.
+ * Additionally, the obstacle avoidance service may change the state
+ * 
+ * @author Riley
+ *
+ */
+public class ControllerManager implements TimerListener {
+
+	public Manager manager;
+	private State state; 
+	private Controller[] controllers; 
+	private Timer timer;
+	
+	private final int UPDATE_PERIOD = 50;
+	
+	public ControllerManager(Manager manager) {
+		this.manager = manager;
+		this.timer = new Timer(UPDATE_PERIOD, this);
+		this.controllers = new Controller[]{new Search(manager), new Recognize(manager), new Collect(manager), new DropOff(manager), new WallFollower(manager)};
+	}
+	
+	public void start() {
+		state = State.SEARCH;
+		timer.start();
+	}
+	
+	public void timedOut() {
+		
+		if(state == State.SEARCH) controllers[0].run();
+		else if(state == State.RECOGNIZE) controllers[1].run();
+		else if(state == State.COLLECT) controllers[2].run();
+		else if(state == State.DROP_OFF) controllers[3].run();
+		else if(state == State.WALL_FOLLOWER) controllers[4].run();
+		
+	}
+	
+	public void stop() {
+		timer.stop();
+	}
+}
diff --git a/src/manager/HardwareManager.java b/src/manager/HardwareManager.java
new file mode 100644
index 0000000..2805d4e
--- /dev/null
+++ b/src/manager/HardwareManager.java
@@ -0,0 +1,26 @@
+package manager;
+
+import hardwareAbstraction.*;
+
+public class HardwareManager {
+
+	public Manager manager;
+	public Drive drive;
+	public Forklift forklift;
+	public Claw claw;
+	public UltrasonicMotor ultrasonicMotor;
+	public ColorPoller colorPoller;
+	public LinePoller linePoller;
+	public UltrasonicPoller ultrasonicPoller;
+	
+	public HardwareManager(Manager manager) {
+		this.manager = manager;
+		this.drive = new Drive();
+		this.forklift = new Forklift();
+		this.claw = new Claw();
+		this.ultrasonicMotor = new UltrasonicMotor();
+		this.colorPoller = new ColorPoller();
+		this.linePoller = new LinePoller();
+		this.ultrasonicPoller = new UltrasonicPoller();
+	}
+}
diff --git a/src/manager/Manager.java b/src/manager/Manager.java
new file mode 100644
index 0000000..18a88c2
--- /dev/null
+++ b/src/manager/Manager.java
@@ -0,0 +1,16 @@
+package manager;
+
+public class Manager {
+	
+	public UtilityManager um;
+	public ControllerManager cm;
+	public ServiceManager sm;
+	public HardwareManager hm;	
+
+	public Manager() {
+		this.um = new UtilityManager(this);
+		this.cm = new ControllerManager(this);
+		this.sm = new ServiceManager(this);
+		this.hm = new HardwareManager(this);
+	}
+}
diff --git a/src/manager/ServiceManager.java b/src/manager/ServiceManager.java
new file mode 100644
index 0000000..2585e2a
--- /dev/null
+++ b/src/manager/ServiceManager.java
@@ -0,0 +1,24 @@
+package manager;
+
+import services.*;
+
+public class ServiceManager {
+
+	public Manager manager;
+	public Odometer odo;
+	public Navigation nav;
+	public OdometryCorrection odoCorrection;
+	public ObstacleAvoidance obstacleAvoidance;
+	public Mapper mapper;
+	public Localization localization;
+	
+	public ServiceManager(Manager manager) {
+		this.manager = manager;
+		this.odo = new Odometer(manager);
+		this.nav = new Navigation(manager);
+		this.odoCorrection = new OdometryCorrection(manager);
+		this.obstacleAvoidance = new ObstacleAvoidance(manager);
+		this.mapper = new Mapper(manager);
+		this.localization = new Localization(manager);
+	}
+}
diff --git a/src/manager/UtilityManager.java b/src/manager/UtilityManager.java
new file mode 100644
index 0000000..abdf7c0
--- /dev/null
+++ b/src/manager/UtilityManager.java
@@ -0,0 +1,19 @@
+package manager;
+
+import utilities.*;
+
+public class UtilityManager {
+	
+	public Manager manager;
+	public BluetoothTransmission bt;
+	public Communicator comLink; 
+	public Map map;
+	
+	
+	public UtilityManager(Manager manager) {
+		this.manager = manager;
+		this.bt = new BluetoothTransmission();
+		this.comLink = new Communicator();
+		this.map = new Map();
+	}
+}
diff --git a/src/services/Localization.java b/src/services/Localization.java
new file mode 100644
index 0000000..bacb2c4
--- /dev/null
+++ b/src/services/Localization.java
@@ -0,0 +1,10 @@
+package services;
+
+import manager.*;
+
+public class Localization {
+	
+	public Localization(Manager manager) {
+		
+	}
+}
diff --git a/src/services/Mapper.java b/src/services/Mapper.java
new file mode 100644
index 0000000..3a43c75
--- /dev/null
+++ b/src/services/Mapper.java
@@ -0,0 +1,10 @@
+package services;
+
+import manager.*;
+
+public class Mapper {
+
+	public Mapper(Manager manager) {
+		
+	}
+}
diff --git a/src/services/Navigation.java b/src/services/Navigation.java
new file mode 100644
index 0000000..8cd94a9
--- /dev/null
+++ b/src/services/Navigation.java
@@ -0,0 +1,30 @@
+package services;
+
+import manager.*;
+
+/**
+ * 
+ * needs to implement 
+ * timerlistener 
+ * stack<Point> route
+ * timedOut (calls turnTo or travelTo + obstacleAvoidance scan() depending on what one is needed) && only be called while state is State.SEARCH || State.DROP_OFF
+ * turnTo
+ * travelTo
+ * 
+ * Once turn to face the direction to a new point, confer with obstacle avoidance to scanAhead()
+ * 
+ * 
+ * 
+ * @author 
+ *
+ */
+public class Navigation {
+
+	public Navigation(Manager manager) {
+		
+	}
+	
+	
+	
+	
+}
diff --git a/src/services/ObstacleAvoidance.java b/src/services/ObstacleAvoidance.java
new file mode 100644
index 0000000..1bad4a5
--- /dev/null
+++ b/src/services/ObstacleAvoidance.java
@@ -0,0 +1,28 @@
+package services;
+
+import manager.*;
+
+/**
+ * 
+ * implement scanAhead(int maxDistance)
+ * scans forward with all 3 us sensors (5 pings each for filtering purposes)
+ * taking the closest reading:
+ * if nothing closer than distance do nothing -> return true
+ * if closer than distance but > 20cm ->add an intermediate point in route (at closest reading - safety margin) return true
+ * if distance less than 20cm return false, change state to recognize controller
+ * 
+ * implement scan()
+ * uses center ultrasonic to make sure the path ahead is clear (>20cm)
+ * 
+ * NOTE: 20cm is estimated value, will need to tweak
+ * 
+ * 
+ * @author 
+ *
+ */
+public class ObstacleAvoidance {
+
+	public ObstacleAvoidance(Manager manager) {
+		
+	}
+}
diff --git a/src/services/Odometer.java b/src/services/Odometer.java
new file mode 100644
index 0000000..aa47923
--- /dev/null
+++ b/src/services/Odometer.java
@@ -0,0 +1,10 @@
+package services;
+
+import manager.*;
+
+public class Odometer {
+
+	public Odometer(Manager manager) {
+		
+	}
+}
diff --git a/src/services/OdometryCorrection.java b/src/services/OdometryCorrection.java
new file mode 100644
index 0000000..96bf8b7
--- /dev/null
+++ b/src/services/OdometryCorrection.java
@@ -0,0 +1,10 @@
+package services;
+
+import manager.*;
+
+public class OdometryCorrection {
+	
+	public OdometryCorrection(Manager manager) {
+		
+	}
+}
diff --git a/src/utilities/Angle.java b/src/utilities/Angle.java
new file mode 100644
index 0000000..d9d0097
--- /dev/null
+++ b/src/utilities/Angle.java
@@ -0,0 +1,5 @@
+package utilities;
+
+public class Angle {
+
+}
diff --git a/src/utilities/BluetoothTransmission.java b/src/utilities/BluetoothTransmission.java
new file mode 100644
index 0000000..0572a19
--- /dev/null
+++ b/src/utilities/BluetoothTransmission.java
@@ -0,0 +1,12 @@
+/**
+ * 
+ */
+package utilities;
+
+/**
+ * @author Riley
+ *
+ */
+public class BluetoothTransmission {
+
+}
diff --git a/src/utilities/Communicator.java b/src/utilities/Communicator.java
new file mode 100644
index 0000000..4c12a7d
--- /dev/null
+++ b/src/utilities/Communicator.java
@@ -0,0 +1,5 @@
+package utilities;
+
+public class Communicator {
+
+}
diff --git a/src/utilities/Map.java b/src/utilities/Map.java
new file mode 100644
index 0000000..eae6572
--- /dev/null
+++ b/src/utilities/Map.java
@@ -0,0 +1,5 @@
+package utilities;
+
+public class Map {
+
+}
diff --git a/src/utilities/Point.java b/src/utilities/Point.java
new file mode 100644
index 0000000..f8c7468
--- /dev/null
+++ b/src/utilities/Point.java
@@ -0,0 +1,5 @@
+package utilities;
+
+public class Point  {
+
+}
diff --git a/src/utilities/Position.java b/src/utilities/Position.java
new file mode 100644
index 0000000..8255714
--- /dev/null
+++ b/src/utilities/Position.java
@@ -0,0 +1,5 @@
+package utilities;
+
+public class Position extends Point {
+
+}
diff --git a/src/utilities/Settings.java b/src/utilities/Settings.java
new file mode 100644
index 0000000..54bfa96
--- /dev/null
+++ b/src/utilities/Settings.java
@@ -0,0 +1,5 @@
+package utilities;
+
+public class Settings {
+
+}
diff --git a/src/utilities/Tile.java b/src/utilities/Tile.java
new file mode 100644
index 0000000..3483341
--- /dev/null
+++ b/src/utilities/Tile.java
@@ -0,0 +1,5 @@
+package utilities;
+
+public class Tile {
+
+}

commit b07e8bd71635bbc4f4772467dea10ec834353db1
Author: RileyvanRyswyk <rileyvan@gmail.com>
Date:   Sat Nov 2 18:54:59 2013 -0400

    Revert "Group 15 Lab 2,4,5"
    
    This reverts commit fb0fee606bcb5dabcf70f1ae49cddcf12ff3c17b.

diff --git a/Group-15/Lab2-15/Lab2.java b/Group-15/Lab2-15/Lab2.java
deleted file mode 100644
index 90ca385..0000000
--- a/Group-15/Lab2-15/Lab2.java
+++ /dev/null
@@ -1,58 +0,0 @@
-/*
- * Lab2.java
- */
-import lejos.nxt.*;
-
-public class Lab2 {
-	public static void main(String[] args) {
-		int buttonChoice;
-
-		// some objects that need to be instantiated
-		Odometer odometer = new Odometer();
-		
-		OdometryCorrection odometryCorrection = new OdometryCorrection(odometer);
-		OdometryDisplay odometryDisplay = new OdometryDisplay(odometer, odometryCorrection);
-
-		do {
-			// clear the display
-			LCD.clear();
-
-			// ask the user whether the motors should drive in a square or float
-			LCD.drawString("< Left | Right >", 0, 0);
-			LCD.drawString("       |        ", 0, 1);
-			LCD.drawString(" Float | Drive  ", 0, 2);
-			LCD.drawString("motors | in a   ", 0, 3);
-			LCD.drawString("       | square ", 0, 4);
-
-			buttonChoice = Button.waitForPress();
-		} while (buttonChoice != Button.ID_LEFT
-				&& buttonChoice != Button.ID_RIGHT);
-
-		if (buttonChoice == Button.ID_LEFT) {
-			for (NXTRegulatedMotor motor : new NXTRegulatedMotor[] { Motor.A, Motor.B, Motor.C }) {
-				motor.forward();
-				motor.flt();
-			}
-
-			// start only the odometer and the odometry display
-			odometer.start();
-			odometryDisplay.start();
-		} else {
-			// start the odometer, the odometry display and (possibly) the
-			// odometry correction
-			odometer.start();
-			odometryDisplay.start();
-			odometryCorrection.start();
-
-			// spawn a new Thread to avoid SquareDriver.drive() from blocking
-			(new Thread() {
-				public void run() {
-					SquareDriver.drive(Motor.A, Motor.B, 2.12, 2.12, 14.74);
-				}
-			}).start();
-		}
-		
-		while (Button.waitForPress() != Button.ID_ESCAPE);
-		System.exit(0);
-	}
-}
\ No newline at end of file
diff --git a/Group-15/Lab2-15/Odometer.java b/Group-15/Lab2-15/Odometer.java
deleted file mode 100644
index 4e68b6b..0000000
--- a/Group-15/Lab2-15/Odometer.java
+++ /dev/null
@@ -1,163 +0,0 @@
-import lejos.nxt.Motor;
-import lejos.nxt.NXTRegulatedMotor;
-
-/*
- * Odometer.java
- */
-
-public class Odometer extends Thread {
-	// robot position
-	private double x, y, theta;
-
-	// odometer update period, in ms
-	private static final long ODOMETER_PERIOD = 25;
-
-	// lock object for mutual exclusion
-	private Object lock;
-	
-	// robot wheel parameters
-	private final double radius = 2.12, base = 14.74;
-	
-	// robot wheel tacho parameters
-	private int lTacho, rTacho;
-	
-	// motor reassignment
-	private final NXTRegulatedMotor leftMotor = Motor.A, rightMotor = Motor.B;
-	
-	private final double degToDist = (radius * Math.PI) / 180;
-	
-	// default constructor
-	public Odometer() {
-		//initalize to x=0, y=0, theta = 90deg
-		x = 0.0;
-		y = 0.0;
-		theta = Math.PI/2;
-		lock = new Object();
-		//Reset motor tacho counts to zero
-		leftMotor.resetTachoCount();
-		rightMotor.resetTachoCount();		
-	}
-
-	// run method (required for Thread)
-	public void run() {
-		long updateStart, updateEnd;
-
-		while (true) {
-			updateStart = System.currentTimeMillis();
-
-			//save last tacho counts
-			int lastLTacho = lTacho, lastRTacho = rTacho;
-			
-			//update tacho counts
-			lTacho = leftMotor.getTachoCount();
-			rTacho = rightMotor.getTachoCount();
-			
-			// calc distance traveled for each wheel since last update
-			double dL = (lTacho - lastLTacho) * degToDist;
-			double dR = (rTacho - lastRTacho) * degToDist;
-			
-			//cal dTheta and displacement of the center of the robot
-			double dTheta = (dL-dR) / base;
-			double displacement = (dR + dL) / 2.0;
-			
-			
-			synchronized (lock) {
-				//update theta
-				theta += dTheta;
-				//if going past 2pi offset theta to angle close to zero
-				if(theta > 6.27) {
-					theta -= 2*Math.PI;
-				}
-				//update x and y
-				x += displacement * Math.cos(theta);
-				y += displacement * Math.sin(theta);
-			}
-
-			// this ensures that the odometer only runs once every period
-			updateEnd = System.currentTimeMillis();
-			if (updateEnd - updateStart < ODOMETER_PERIOD) {
-				try {
-					Thread.sleep(ODOMETER_PERIOD - (updateEnd - updateStart));
-				} catch (InterruptedException e) {
-					// there is nothing to be done here because it is not
-					// expected that the odometer will be interrupted by
-					// another thread
-				}
-			}
-		}
-	}
-
-	// accessors
-	public void getPosition(double[] position, boolean[] update) {
-		// ensure that the values don't change while the odometer is running
-		synchronized (lock) {
-			if (update[0])
-				position[0] = x;
-			if (update[1])
-				position[1] = y;
-			if (update[2])
-				position[2] = theta;
-		}
-	}
-
-	public double getX() {
-		double result;
-
-		synchronized (lock) {
-			result = x;
-		}
-
-		return result;
-	}
-
-	public double getY() {
-		double result;
-
-		synchronized (lock) {
-			result = y;
-		}
-
-		return result;
-	}
-
-	public double getTheta() {
-		double result;
-
-		synchronized (lock) {
-			result = theta;
-		}
-
-		return result;
-	}
-
-	// mutators
-	public void setPosition(double[] position, boolean[] update) {
-		// ensure that the values don't change while the odometer is running
-		synchronized (lock) {
-			if (update[0])
-				x = position[0];
-			if (update[1])
-				y = position[1];
-			if (update[2])
-				theta = position[2];
-		}
-	}
-
-	public void setX(double x) {
-		synchronized (lock) {
-			this.x = x;
-		}
-	}
-
-	public void setY(double y) {
-		synchronized (lock) {
-			this.y = y;
-		}
-	}
-
-	public void setTheta(double theta) {
-		synchronized (lock) {
-			this.theta = theta;
-		}
-	}
-}
\ No newline at end of file
diff --git a/Group-15/Lab2-15/OdometryCorrection.java b/Group-15/Lab2-15/OdometryCorrection.java
deleted file mode 100644
index ca3997d..0000000
--- a/Group-15/Lab2-15/OdometryCorrection.java
+++ /dev/null
@@ -1,212 +0,0 @@
-import java.util.ArrayList;
-import java.util.List;
-import lejos.nxt.ColorSensor;
-import lejos.nxt.SensorPort;
-import lejos.nxt.Sound;
-
-/* 
- * OdometryCorrection.java
- * 
- * Detects black grid lines on wooden floor, then corrects the position of the odometer
- * based on the position reported when the line was detected
- * 
- */
-
-public class OdometryCorrection extends Thread {
-	private static final long CORRECTION_PERIOD = 10;
-	private Odometer odometer;
-	private static final SensorPort lsPort = SensorPort.S1;
-	private ColorSensor lightSensor = new ColorSensor(lsPort);
-	private List<Double> lsValues = new ArrayList<Double>();
-	private int runFilter = -3;
-	private boolean onLine = false;
-	
-	// distance to next most positive x line, distance to next most positive y line, tile size, light sensor offset
-	private double tileSize = 30.48, r = 12.8;
-	private double xOffset = -tileSize/2, yOffset = tileSize/2;
-	
-	
-	// constructor
-	public OdometryCorrection(Odometer odometer) {
-		this.odometer = odometer;
-		//reduce volume
-		Sound.setVolume(35);
-		//set flood light to Red, red gives most accurate results for us
-		lightSensor.setFloodlight(0);
-		
-	}
-
-	// run method (required for Thread)
-	public void run() {
-		long correctionStart, correctionEnd;
-
-		while (true) {
-			correctionStart = System.currentTimeMillis();
-			
-			//update light sensor return value
-			try { 
-				lsValues.set(3, (double) lightSensor.getRawLightValue() / 2.0);			
-			} catch(IndexOutOfBoundsException e) {
-				lsValues.add((double) lightSensor.getRawLightValue() / 2.0);	
-			}
-			
-			
-			if(runFilter == 0) {
-				filterLightSensor();
-				runFilter = -1;				
-			} else {
-				runFilter++;
-			}
-			
-
-			// this ensure the odometry correction occurs only once every period
-			correctionEnd = System.currentTimeMillis();
-			
-			if (correctionEnd - correctionStart < CORRECTION_PERIOD) {
-				try {
-					Thread.sleep(CORRECTION_PERIOD
-							- (correctionEnd - correctionStart));
-				} catch (InterruptedException e) {
-					// there is nothing to be done here because it is not
-					// expected that the odometry correction will be
-					// interrupted by another thread
-				}
-			}
-		}
-	}
-	
-	public void filterLightSensor() {
-		
-		double result;
-		
-		result = -lsValues.get(0) - lsValues.get(1) + lsValues.get(2) + lsValues.get(3);
-		
-		lsValues.remove(0);
-				
-		if(!onLine && result < -45) {
-			//go to line detection logic
-			lineDetected();
-			
-			// We are on the line
-			onLine = true;
-			
-			//alert us with a beep that a line was detected
-			Sound.beep();
-			
-		} else if(onLine && result > 45) {
-			onLine = false;
-		}		
-	}
-	
-	/**
-	 * retrieves last light sensor reading
-	 * @return lastLSValue
-	 */
-	public String lightSensorValue() {
-		return Double.toString(lsValues.get(0));
-	}
-	
-	public void lineDetected() {
-		
-		//for getting the current x, y, theta
-		double[] pos = new double[3];
-		boolean[] update = {true, true, true};
-		
-		odometer.getPosition(pos, update);
-		
-		double x = pos[0];
-		double y= pos[1];
-		double theta = pos[2];
-		
-		/**
-		 * sets orientation
-		 * ~= 1 if going in Y direction
-		 * ~= 0 if going in X direction
-		 */
-		double orientation = Math.abs(Math.sin(theta));	
-		
-		/**
-		 * Update the Y position as we are going in the Y direction
-		 */
-		if(orientation > 0.99) {
-			
-			/**
-			 * getClosestY returns the closest line plus the offset for the light Sensor	
-			 */
-			double line = getClosestY(y, theta);
-			
-			//if we are within 10cm of the line, update our position
-			if(Math.abs(line - y) < 10) {
-				
-				odometer.setY(line);
-			}
-			
-		}
-		/**
-		 * Update the X position, going in X direction
-		 */
-		else if(Math.abs(Math.cos(theta)) > 0.99) {
-			
-				
-			/**
-			 * We have already detected a x line, so get the closest line
-			 * getClosestX returns the closest line plus the offset for the light Sensor
-			 */
-			double line = getClosestX(x, theta);
-			
-			//if we are within 10cm of the line, update our position
-			if(Math.abs(line - x) < 10) {
-				
-				odometer.setX(line);
-				
-			}
-			
-		}
-		
-		/**
-		 * Update theta as we are turning
-		 */
-		else {
-			
-			/*// for the second last corner, if we have enough seperation between the y straight and y angled line
-			if(x<-45 && y<15 && y>(yOffset-r+2) && x > (xOffset-3*tileSize+r)) {
-				
-				//the yLine detected during turning
-				double yPrime =  (Math.round((y+r-yOffset)/tileSize)*tileSize + yOffset);
-				
-				// new Theta
-				double newTheta = 3*Math.PI/2 + Math.acos((yPrime-y)/r);
-				
-				// if Theta is a real number, udpate
-				if(newTheta != Double.NaN) { 
-					odometer.setTheta(newTheta);
-					
-				}
-			}*/
-		}
-	}
-	
-	/**
-	 * Returns the closest y line plus the offset for the light sensor
-	 * @param y
-	 * @param theta
-	 * @return
-	 */
-	public double getClosestY(double y, double theta) {
-		//adjust light sensor offset for direction of robot
-		double R = (Math.sin(theta) < 0) ? -1*r : r;
-		return (Math.round((y-R-yOffset)/tileSize)*tileSize + yOffset + R);
-	}
-	
-	/**
-	 * Returns the closest x line plus the offset for the light sensor
-	 * @param x
-	 * @param theta
-	 * @return
-	 */
-	public double getClosestX(double x, double theta) {
-		//adjust light sensor offset for direction of robot
-		double R = (Math.cos(theta) < 0) ? -1*r : r;
-		return (Math.round((x-R-xOffset)/tileSize)*tileSize + xOffset + R);
-	}
-}
\ No newline at end of file
diff --git a/Group-15/Lab2-15/OdometryDisplay.java b/Group-15/Lab2-15/OdometryDisplay.java
deleted file mode 100644
index 93b8ff4..0000000
--- a/Group-15/Lab2-15/OdometryDisplay.java
+++ /dev/null
@@ -1,101 +0,0 @@
-/*
- * OdometryDisplay.java
- */
-import lejos.nxt.LCD;
-
-public class OdometryDisplay extends Thread {
-	private static final long DISPLAY_PERIOD = 250;
-	private Odometer odometer;
-	private OdometryCorrection light;
-
-	// constructor
-	public OdometryDisplay(Odometer odometer, OdometryCorrection light) {
-		this.odometer = odometer;
-		this.light = light;
-	}
-
-	// run method (required for Thread)
-	public void run() {
-		long displayStart, displayEnd;
-		double[] position = new double[3];
-
-		// clear the display once
-		LCD.clearDisplay();
-
-		while (true) {
-			displayStart = System.currentTimeMillis();
-
-			// clear the lines for displaying odometry information
-			LCD.drawString("X:              ", 0, 0);
-			LCD.drawString("Y:              ", 0, 1);
-			LCD.drawString("T:              ", 0, 2);
-			LCD.drawString("S:              ", 0, 3);
-			
-
-			// get the odometry information
-			odometer.getPosition(position, new boolean[] { true, true, true });
-
-			// display odometry information
-			for (int i = 0; i < 3; i++) {
-				LCD.drawString(formattedDoubleToString(position[i], 2), 3, i);
-			}
-			
-			// Show light sensor value
-			LCD.drawString(light.lightSensorValue(), 3, 3);
-
-			// throttle the OdometryDisplay
-			displayEnd = System.currentTimeMillis();
-			if (displayEnd - displayStart < DISPLAY_PERIOD) {
-				try {
-					Thread.sleep(DISPLAY_PERIOD - (displayEnd - displayStart));
-				} catch (InterruptedException e) {
-					// there is nothing to be done here because it is not
-					// expected that OdometryDisplay will be interrupted
-					// by another thread
-				}
-			}
-		}
-	}
-	
-	private static String formattedDoubleToString(double x, int places) {
-		String result = "";
-		String stack = "";
-		long t;
-		
-		// put in a minus sign as needed
-		if (x < 0.0)
-			result += "-";
-		
-		// put in a leading 0
-		if (-1.0 < x && x < 1.0)
-			result += "0";
-		else {
-			t = (long)x;
-			if (t < 0)
-				t = -t;
-			
-			while (t > 0) {
-				stack = Long.toString(t % 10) + stack;
-				t /= 10;
-			}
-			
-			result += stack;
-		}
-		
-		// put the decimal, if needed
-		if (places > 0) {
-			result += ".";
-		
-			// put the appropriate number of decimals
-			for (int i = 0; i < places; i++) {
-				x = Math.abs(x);
-				x = x - Math.floor(x);
-				x *= 10.0;
-				result += Long.toString((long)x);
-			}
-		}
-		
-		return result;
-	}
-
-}
diff --git a/Group-15/Lab2-15/SquareDriver.java b/Group-15/Lab2-15/SquareDriver.java
deleted file mode 100644
index 18dd303..0000000
--- a/Group-15/Lab2-15/SquareDriver.java
+++ /dev/null
@@ -1,66 +0,0 @@
-/*
- * SquareDriver.java
- */
-import lejos.nxt.*;
-
-public class SquareDriver {
-	private static final int FORWARD_SPEED = 300;
-	private static final int ROTATE_SPEED = 150;
-
-	public static void drive(NXTRegulatedMotor leftMotor, NXTRegulatedMotor rightMotor,
-			double leftRadius, double rightRadius, double width) {
-		// reset the motors
-		for (NXTRegulatedMotor motor : new NXTRegulatedMotor[] { leftMotor, rightMotor }) {
-			motor.stop();
-			motor.setAcceleration(2000);
-		}
-
-		// wait 5 seconds
-		try {
-			Thread.sleep(2000);
-		} catch (InterruptedException e) {
-			// there is nothing to be done here because it is not expected that
-			// the odometer will be interrupted by another thread
-		}
-
-		for (int i = 0; i < 4; i++) {
-			// drive forward two tiles
-			leftMotor.setSpeed(FORWARD_SPEED);
-			rightMotor.setSpeed(FORWARD_SPEED);
-			
-			(new Thread() {
-				public void run() {
-					try {
-						Thread.sleep(1000);
-					} catch (InterruptedException e) {
-						
-					}
-					Motor.A.stop();
-				}
-			}).start();
-			
-			leftMotor.rotate(convertDistance(leftRadius, 60), true);
-			rightMotor.rotate(convertDistance(rightRadius, 60), false);
-			
-			
-
-			// turn 90 degrees clockwise
-			leftMotor.setSpeed(ROTATE_SPEED);
-			rightMotor.setSpeed(ROTATE_SPEED);
-
-			leftMotor.rotate(convertAngle(leftRadius, width, 90.0), true);
-			rightMotor.rotate(-convertAngle(rightRadius, width, 90.0), false);
-			
-		
-		}
-	}
-
-	private static int convertDistance(double radius, double distance) {
-		return (int) ((180.0 * distance) / (Math.PI * radius));
-	}
-
-	private static int convertAngle(double radius, double width, double angle) {
-		return convertDistance(radius, Math.PI * width * angle / 360.0);
-	}
-	
-}
\ No newline at end of file
diff --git a/Group-15/Lab4-15/LCDInfo.java b/Group-15/Lab4-15/LCDInfo.java
deleted file mode 100644
index a9da62f..0000000
--- a/Group-15/Lab4-15/LCDInfo.java
+++ /dev/null
@@ -1,53 +0,0 @@
-import lejos.nxt.LCD;
-import lejos.util.Timer;
-import lejos.util.TimerListener;
-
-/**
- * 
- * @project Lab 4 Localization 
- * @names Riley van Ryswyk & Aditya Saha
- * @studentID 260447357 & 260453165
- * @group 15
- * @course ECSE 211 
- * @date 06/10/2013
- * 
- * LCD display (provided)
- */
-
-public class LCDInfo implements TimerListener{
-	public static final int LCD_REFRESH = 100;
-	private Odometer odo;
-	private Timer lcdTimer;
-	
-	// arrays for displaying data
-	private double [] pos;
-	
-	/**
-	 * LCDInfo constructor
-	 * @param odo
-	 */
-	public LCDInfo(Odometer odo) {
-		this.odo = odo;
-		this.lcdTimer = new Timer(LCD_REFRESH, this);
-		
-		// initialise the arrays for displaying data
-		pos = new double [3];
-		
-		// start the timer
-		lcdTimer.start();
-	}
-	
-	/**
-	 * main update loop
-	 */
-	public void timedOut() { 
-		odo.getPosition(pos);
-		LCD.clear();
-		LCD.drawString("X: ", 0, 0);
-		LCD.drawString("Y: ", 0, 1);
-		LCD.drawString("H: ", 0, 2);
-		LCD.drawInt((int)(pos[0] * 10), 3, 0);
-		LCD.drawInt((int)(pos[1] * 10), 3, 1);
-		LCD.drawInt((int)pos[2], 3, 2);
-	}
-}
diff --git a/Group-15/Lab4-15/Lab4.java b/Group-15/Lab4-15/Lab4.java
deleted file mode 100644
index d414911..0000000
--- a/Group-15/Lab4-15/Lab4.java
+++ /dev/null
@@ -1,68 +0,0 @@
-import lejos.nxt.*;
-import lejos.nxt.comm.RConsole;
-
-/**
- * 
- * @project Lab 4 Localization 
- * @names Riley van Ryswyk & Aditya Saha
- * @studentID 260447357 & 260453165
- * @group 15
- * @course ECSE 211 
- * @date 06/10/2013
- * 
- */
-
-public class Lab4 {
-
-	public static void main(String[] args) {
-		
-		// setup the odometer, and ultrasonic and light sensors
-		TwoWheeledRobot patBot = new TwoWheeledRobot(Motor.B, Motor.A);
-		Odometer odo = new Odometer(patBot, true);
-		UltrasonicSensor us = new UltrasonicSensor(SensorPort.S2);
-		ColorSensor ls = new ColorSensor(SensorPort.S1);
-		
-		//choose method of Ultrasonic localization
-		int buttonChoice;
-		
-		do {
-			// clear the display
-			LCD.clear();
-
-			// ask the user whether rising or falling localization
-			LCD.drawString("< Left | Right >", 0, 0);
-			LCD.drawString("       |        ", 0, 1);
-			LCD.drawString("  Rise | Fall   ", 0, 2);
-
-			buttonChoice = Button.waitForPress();
-		} while (buttonChoice != Button.ID_LEFT
-				&& buttonChoice != Button.ID_RIGHT);
-		
-		//setup display
-		LCDInfo lcd = new LCDInfo(odo);
-		
-		//Rising Edge Ultrasonic Localization
-		if (buttonChoice == Button.ID_LEFT) {
-			USLocalizer usl = new USLocalizer(odo, us, USLocalizer.LocalizationType.RISING_EDGE);
-			usl.doLocalization();
-		} 
-		//Falling edge Ultrasonic Localization
-		else {
-			USLocalizer usl = new USLocalizer(odo, us, USLocalizer.LocalizationType.FALLING_EDGE);
-			usl.doLocalization();
-		}
-		
-		// Turn to 0 degrees to display the accuracy of the ultrasonic localization
-		odo.getNavigation().turnTo(0);
-		
-		// perform the light sensor localization
-		LightLocalizer lsl = new LightLocalizer(odo, ls);
-		lsl.doLocalization();
-		
-		odo.getNavigation().travelTo(0, 0);
-		odo.getNavigation().turnTo(0);
-		
-		Button.waitForPress();
-	}
-
-}
diff --git a/Group-15/Lab4-15/LightLocalizer.java b/Group-15/Lab4-15/LightLocalizer.java
deleted file mode 100644
index b42036f..0000000
--- a/Group-15/Lab4-15/LightLocalizer.java
+++ /dev/null
@@ -1,193 +0,0 @@
-import java.util.ArrayList;
-import java.util.List;
-
-import lejos.nxt.ColorSensor;
-import lejos.nxt.Sound;
-import lejos.nxt.comm.RConsole;
-
-/**
- * 
- * @project Lab 4 Localization 
- * @names Riley van Ryswyk & Aditya Saha
- * @studentID 260447357 & 260453165
- * @group 15
- * @course ECSE 211 
- * @date 06/10/2013
- * 
- * Light sensor localization
- */
-
-public class LightLocalizer {
-	
-	private static final long CORRECTION_PERIOD = 10;
-	private Odometer odo;
-	private TwoWheeledRobot robot;
-	private ColorSensor lightSensor;
-	
-	//store light sensor values (for filtering purposes)
-	private List<Double> lsValues = new ArrayList<Double>();
-	
-	//the headings when a line is detected
-	private List<Double> angles = new ArrayList<Double>();
-	
-	// Keep track of whether we are on a line on not
-	private boolean onLine = false;
-	private int lineCount = 0;
-	
-	// tile size, light sensor offset
-	private final double TILE_SIZE = 30.48, LS_OFFSET = 12.8;
-	
-	/**
-	 * Light sensor localization constructor
-	 * @param odo
-	 * @param ls
-	 */
-	public LightLocalizer(Odometer odo, ColorSensor ls) {
-		this.odo = odo;
-		this.robot = odo.getTwoWheeledRobot();
-		this.lightSensor = ls;
-		
-		//for line detection
-		Sound.setVolume(50);
-		// turn on the light to red
-		ls.setFloodlight(0);
-		
-	}
-	
-	/**
-	 * do light sensor localization
-	 * finds x, y, theta to within 0.2cm, 1 deg
-	 */
-	public void doLocalization() {
-		// drive to location listed in tutorial
-		// start rotating and clock all 4 gridlines
-		// do trig to compute (0,0) and 0 degrees
-		// when done travel to (0,0) and turn to 0 degrees
-		
-		// travel to roughly -4cm, -4cm
-		odo.getNavigation().travelTo(-4.0,-4.0);
-		
-		//Initialize line count to 0
-		lineCount = 0;
-		
-		//clear angles array
-		angles.clear();
-		
-		//populate light sensor array with a sufficient amount of values
-		lsValues.add((double) lightSensor.getRawLightValue() / 2.0);
-		lsValues.add((double) lightSensor.getRawLightValue() / 2.0);
-		lsValues.add((double) lightSensor.getRawLightValue() / 2.0);
-		
-		//ensures that we pass the lines in the same order every time | could be avoided with a more sophisticated calculation of thetaX and thetaY
-		if(odo.getTheta() > 80) {
-			odo.getNavigation().turnTo(45);
-		}
-				
-		//to mantain the correct CORRECTION_PERIOD
-		long correctionStart, correctionEnd;
-		
-		//line detection loop
-		while (lineCount < 4) {
-			correctionStart = System.currentTimeMillis();
-			
-			//sets robot to rotate at 35 deg/s
-			robot.setSpeeds(0, 35);
-			
-			//adds light sensor value to array of values
-			lsValues.add((double) lightSensor.getRawLightValue() / 2.0);
-				
-			//filters the light sensor information, and determines if a line was detected or not
-			filterLightSensor();
-			
-			// this ensure the odometry correction occurs only once every period
-			correctionEnd = System.currentTimeMillis();
-			
-			if (correctionEnd - correctionStart < CORRECTION_PERIOD) {
-				try {
-					Thread.sleep(CORRECTION_PERIOD
-							- (correctionEnd - correctionStart));
-				} catch (InterruptedException e) {
-					// there is nothing to be done here because it is not
-					// expected that the odometry correction will be
-					// interrupted by another thread
-				}
-			}
-		}
-		
-		//stop robot
-		robot.setSpeeds(0, 0);
-		
-		//resets onLine
-		onLine = false;
-		
-		// calculates the angle spanned between the headings of the robot when the lines on the X and Y axes were detected respectively
-		double thetaX = angles.get(0) - angles.get(2);
-		double thetaY = angles.get(1) - angles.get(3);
-		
-		// Based on the above angles, the current x, y coordinates are calculated (assuming 0,0 is the closest intersection)
-		double x = -LS_OFFSET * Math.cos(Math.toRadians(thetaY/2.0));
-		double y = -LS_OFFSET * Math.cos(Math.toRadians(thetaX/2.0));
-		
-		// if the first detection was at a heading of between [0,60], we are not in the negative x,y region
-		// so invert y | x will be correctly inverted
-		if(angles.get(0) < 60) {
-			y = -y;
-		} 
-		
-		// we are not in the right stop to determine theta -> update current position (x,y) and then redo localization
-		if(x > 0 || y > 0) {
-			odo.setPosition(new double [] {x, y, odo.getTheta() }, new boolean [] {true, true, true});
-			doLocalization();
-		}
-		//localization was successful
-		else {
-			// calculate amount to adjust theta by, achieved through averaging the values for dTheta calculated on both the x and y axes
-			double dTheta = (439-thetaX/2.0-thetaY/2.0-angles.get(3)-angles.get(2))/2.0;
-			
-			//update our current position 
-			odo.setPosition(new double [] {x, y, odo.getTheta()+dTheta }, new boolean [] {true, true, true});
-		}
-		
-	}
-	
-	/**
-	 * Applys smoothing and differencing to the recorded values
-	 * detects when black line is detected and when the regular floor is detected again 
-	 */
-	public void filterLightSensor() {
-		
-		double result;
-		
-		// Smooth and difference
-		result = -lsValues.get(0) - lsValues.get(1) + lsValues.get(2) + lsValues.get(3);
-		
-		//if not currently on a line and filter result is less than -45 we just enter a line			
-		if(!onLine && result < -45) {
-			onLine = true;
-			
-			//go to line detection logic
-			lineDetected();
-			
-			//alert us with a beep that a line was detected
-			Sound.beep();
-			
-			lineCount++;
-			
-		} 
-		//if we are on a line and filter result > 45 we have now left the line
-		else if(onLine && result > 45) {
-			onLine = false;
-		}
-		
-		//shift values left by 1 for next iteration
-		lsValues.remove(0);
-	}
-	
-	/**
-	 * when a line is detected, add it to the array of line detected angles
-	 */
-	public void lineDetected() {
-		angles.add(odo.getTheta());
-	}
-
-}
diff --git a/Group-15/Lab4-15/Navigation.java b/Group-15/Lab4-15/Navigation.java
deleted file mode 100644
index 391af2a..0000000
--- a/Group-15/Lab4-15/Navigation.java
+++ /dev/null
@@ -1,246 +0,0 @@
-
-/**
- * 
- * @project Lab 4 Localization 
- * @names Riley van Ryswyk & Aditya Saha
- * @studentID 260447357 & 260453165
- * @group 15
- * @course ECSE 211 
- * @date 06/10/2013
- * 
- * Navigation 
- * 
- */
-public class Navigation {
-
-	private Odometer odometer;
-	private TwoWheeledRobot robot;
-
-	// Update every 50ms
-	private static final long UPDATE_PERIOD = 50;
-
-	// Max speeds in cm/sec, deg/sec
-	private final int MAX_FORWARD_SPEED = 8;
-	private final int MAX_ROTATE_SPEED = 40;
-
-	// navigation variables
-	private boolean navigating = false;
-	private boolean turning = false;
-
-	// for synchronization
-	private Object lock;
-
-	public Navigation(Odometer odo) {
-		this.odometer = odo;
-		this.robot = odo.getTwoWheeledRobot();
-	}
-
-	/**
-	 * Method to travel to a set of Cartesian coordinates
-	 * @param x
-	 * @param y
-	 */
-	public void travelTo(double x, double y) {
-
-		// we're navigating
-		navigating = true;
-
-		long correctionStart, correctionEnd;
-
-		// main loop
-		travelLoop: while (navigating) {
-			correctionStart = System.currentTimeMillis();
-
-			/*
-			 * retrieve current position and calculate dX and dY
-			 */
-			double[] pos = new double[3];
-
-			odometer.getPosition(pos);
-
-			double currentX = pos[0];
-			double currentY = pos[1];
-			double currentTheta = pos[2];
-
-			// Distance between where we are and where we need to travel to
-			double dX = x - currentX;
-			double dY = y - currentY;
-
-			/*
-			 * if within 0.2cm (x&y) of the destination x,y stop otherwise
-			 * continuing traveling
-			 */
-			if (Math.abs(dX) < 0.2 && Math.abs(dY) < 0.2) {
-				navigating = false;
-				robot.stop();
-				break travelLoop;
-			}
-			/*
-			 * We are not at our destination and the path is clear
-			 */
-			else {
-
-				// the required theta to travel to our destination
-				double theta = Math.atan2(dY, dX) * 180.0 / Math.PI;
-				// adjust to [0, 360]
-				theta = (theta < 0) ? 360 + theta : theta;
-
-				// see if we need to make a big turn
-				if ((Math.abs(theta - currentTheta) > 1 && turning)
-						|| Math.abs(theta - currentTheta) > 5) {
-
-					// if we need to turn more than 0.2 rads or 0.1 for
-					// completing a turn, call the turnTo method
-					// otherwise we can adjust small angle errors by slowing one
-					// wheel down slightly
-					turnTo(theta);
-
-				}
-				// We need to go straight (or relatively straight)
-				else {
-
-					/*
-					 * For minor angle corrections
-					 */
-
-					// error in theta
-					double deltaTheta = theta - currentTheta;
-					// amount to change right wheel speed by
-					int dL = 0;
-
-					// Change deltaTheta to [0,360)
-					if (deltaTheta > 180) {
-						deltaTheta -= 360;
-					} else if (deltaTheta < -180) {
-						deltaTheta += 360;
-					}
-
-					// If angle error is greater than 0.01 rad, make adjustment
-					if (Math.abs(deltaTheta) > 0.5) {
-
-						// if we are facing to the left of where we should be,
-						// slight right
-						if (deltaTheta > 0) {
-
-							dL = -1;
-						}
-
-						// if we are facing to the right of where we should be,
-						// slight left
-						else if (deltaTheta < 0) {
-
-							dL = 1;
-						}
-					}
-
-					/*
-					 * End minor angle corrections
-					 */
-
-					// Distance to destination
-					double distanceToTravel = (dX * Math.cos(Math
-							.toRadians(currentTheta)))
-							+ (dY * Math.sin(Math.toRadians(currentTheta)));
-
-					// high speed
-					if (distanceToTravel > 3) {
-						robot.setSpeeds(MAX_FORWARD_SPEED, dL);
-					}
-					// start to slow down
-					else if (distanceToTravel > 1) {
-						robot.setSpeeds(MAX_FORWARD_SPEED / 2, dL);
-					}
-					// go really slow, so that we don't overshoot
-					else {
-						robot.setSpeeds(MAX_FORWARD_SPEED / 5, dL / 3);
-					}
-				}
-
-				// this ensure the odometry correction occurs only once every
-				// period
-				correctionEnd = System.currentTimeMillis();
-
-				if (correctionEnd - correctionStart < UPDATE_PERIOD) {
-					try {
-						Thread.sleep(UPDATE_PERIOD
-								- (correctionEnd - correctionStart));
-					} catch (InterruptedException e) {
-						// there is nothing to be done here because it is not
-						// expected that the odometry correction will be
-						// interrupted by another thread
-					}
-				}
-			}
-		}
-
-	}
-
-	/**
-	 * Orientents the robot to the specified angle
-	 * @param angle
-	 */
-	public void turnTo(double angle) {
-
-		// we are turning
-		if (!turning)
-			turning = true;
-
-		long correctionStart, correctionEnd;
-
-		// main loop
-		while (turning) {
-			correctionStart = System.currentTimeMillis();
-
-			// error in angle
-			double deltaTheta = angle - odometer.getTheta();
-
-			// convert to [-180,180] for minimal angle
-			if (deltaTheta > 180) {
-				deltaTheta -= 360;
-			} else if (deltaTheta < -180) {
-				deltaTheta += 360;
-			}
-
-			// if angle error greater than 1 deg
-			if (Math.abs(deltaTheta) >= 1) {
-				// if error positive and greater than 5 deg -> max speed CCW
-				if (deltaTheta > 8) {
-					robot.setSpeeds(0, -MAX_ROTATE_SPEED);
-				}
-				// positive error, but close to 0, so turn slow CCW to prevent
-				// overshoot
-				else if (deltaTheta > 0) {
-					robot.setSpeeds(0, -MAX_ROTATE_SPEED / 4);
-				}
-				// error negative and less than 5deg -> max speed CW
-				else if (deltaTheta < -8) {
-					robot.setSpeeds(0, MAX_ROTATE_SPEED);
-				}
-				// negative error, but close to 0, so turn slow CW to prevent
-				// overshoot
-				else if (deltaTheta < 0) {
-					robot.setSpeeds(0, MAX_ROTATE_SPEED / 4);
-				}
-			} else {
-				// we have finished turning
-				turning = false;
-				robot.stop();
-			}
-
-			// this ensure the odometry correction occurs only once every period
-			correctionEnd = System.currentTimeMillis();
-
-			if (correctionEnd - correctionStart < UPDATE_PERIOD) {
-				try {
-					Thread.sleep(UPDATE_PERIOD
-							- (correctionEnd - correctionStart));
-				} catch (InterruptedException e) {
-					// there is nothing to be done here because it is not
-					// expected that the odometry correction will be
-					// interrupted by another thread
-				}
-			}
-		}
-
-	}
-}
diff --git a/Group-15/Lab4-15/Odometer.java b/Group-15/Lab4-15/Odometer.java
deleted file mode 100644
index e1b9ef8..0000000
--- a/Group-15/Lab4-15/Odometer.java
+++ /dev/null
@@ -1,176 +0,0 @@
-import lejos.util.Timer;
-import lejos.util.TimerListener;
-/**
- * 
- * @project Lab 4 Localization 
- * @names Riley van Ryswyk & Aditya Saha
- * @studentID 260447357 & 260453165
- * @group 15
- * @course ECSE 211 
- * @date 06/10/2013
- * 
- * Odometer (provided)
- * changed the way theta is defined (now 0 along +x axis and increases CCW)
- */
-public class Odometer implements TimerListener {
-	public static final int DEFAULT_PERIOD = 25;
-	private TwoWheeledRobot robot;
-	private Timer odometerTimer;
-	private Navigation nav;
-	// position data
-	private Object lock;
-	private double x, y, theta;
-	private double [] oldDH, dDH;
-	
-	/**
-	 * Odometer constructor
-	 * @param robot
-	 * @param period
-	 * @param start
-	 */
-	public Odometer(TwoWheeledRobot robot, int period, boolean start) {
-		// initialise variables
-		this.robot = robot;
-		this.nav = new Navigation(this);
-		odometerTimer = new Timer(period, this);
-		x = 0.0;
-		y = 0.0;
-		theta = 90.0;
-		oldDH = new double [2];
-		dDH = new double [2];
-		lock = new Object();
-		
-		// start the odometer immediately, if necessary
-		if (start)
-			odometerTimer.start();
-	}
-	/**
-	 * Odometer constructor
-	 * @param robot
-	 */
-	public Odometer(TwoWheeledRobot robot) {
-		this(robot, DEFAULT_PERIOD, false);
-	}
-	/**
-	 * Odometer constructor
-	 * @param robot
-	 * @param start
-	 */
-	public Odometer(TwoWheeledRobot robot, boolean start) {
-		this(robot, DEFAULT_PERIOD, start);
-	}
-	/**
-	 * Odometer Constructor
-	 * @param robot
-	 * @param period
-	 */
-	public Odometer(TwoWheeledRobot robot, int period) {
-		this(robot, period, false);
-	}
-	
-	/**
-	 * Update loop
-	 * 
-	 * Finds change in motors tacho count and then updates x,y,theta correspondingly 
-	 */
-	public void timedOut() {
-		robot.getDisplacementAndHeading(dDH);
-		//change in displacement and heading
-		dDH[0] -= oldDH[0];
-		dDH[1] -= oldDH[1];
-		
-		// update the position in a critical region
-		synchronized (lock) {
-			theta -= dDH[1];
-			theta = fixDegAngle(theta);
-			
-			x += dDH[0] * Math.cos(Math.toRadians(theta));
-			y += dDH[0] * Math.sin(Math.toRadians(theta));
-		}
-		
-		//update old displacement and heading
-		oldDH[0] += dDH[0];
-		oldDH[1] += dDH[1];
-	}
-	
-	/**
-	 * returns position
-	 * @param pos
-	 */
-	public void getPosition(double [] pos) {
-		synchronized (lock) {
-			pos[0] = x;
-			pos[1] = y;
-			pos[2] = theta;
-		}
-	}
-	
-	/**
-	 * returns theta
-	 * @return
-	 */
-	public double getTheta() {
-		double result;
-
-		synchronized (lock) {
-			result = theta;
-		}
-
-		return result;
-	}
-	
-	/**
-	 * returns TwoWheeledRobot
-	 * @return
-	 */
-	public TwoWheeledRobot getTwoWheeledRobot() {
-		return robot;
-	}
-	
-	/**
-	 * returns navigation object
-	 * @return
-	 */
-	public Navigation getNavigation() {
-		return this.nav;
-	}
-	
-	/**
-	 * set the current position
-	 * @param pos
-	 * @param update
-	 */
-	public void setPosition(double [] pos, boolean [] update) {
-		synchronized (lock) {
-			if (update[0]) x = pos[0];
-			if (update[1]) y = pos[1];
-			if (update[2]) theta = pos[2];
-		}
-	}
-	
-	/**
-	 * Ensures angle is always in [0,360)
-	 * @param angle
-	 * @return
-	 */
-	public static double fixDegAngle(double angle) {		
-		if (angle < 0.0)
-			angle = 360.0 + (angle % 360.0);
-		
-		return angle % 360.0;
-	}
-	/**
-	 * returns the minimum angle
-	 * @param a
-	 * @param b
-	 * @return
-	 */
-	public static double minimumAngleFromTo(double a, double b) {
-		double d = fixDegAngle(b - a);
-		
-		if (d < 180.0)
-			return d;
-		else
-			return d - 360.0;
-	}
-}
diff --git a/Group-15/Lab4-15/TwoWheeledRobot.java b/Group-15/Lab4-15/TwoWheeledRobot.java
deleted file mode 100644
index 271e83b..0000000
--- a/Group-15/Lab4-15/TwoWheeledRobot.java
+++ /dev/null
@@ -1,161 +0,0 @@
-import lejos.nxt.NXTRegulatedMotor;
-/**
- * 
- * @project Lab 4 Localization 
- * @names Riley van Ryswyk & Aditya Saha
- * @studentID 260447357 & 260453165
- * @group 15
- * @course ECSE 211 
- * @date 06/10/2013
- * 
- * TwoWheeledRobot (provided)
- * added stop method
- * limited motor acceleration
- * and changed robot parameters
- */
-public class TwoWheeledRobot {
-	public static final double DEFAULT_LEFT_RADIUS = 2.11;
-	public static final double DEFAULT_RIGHT_RADIUS = 2.11;
-	public static final double DEFAULT_WIDTH = 14.92;
-	private NXTRegulatedMotor leftMotor, rightMotor;
-	private double leftRadius, rightRadius, width;
-	private double forwardSpeed, rotationSpeed;
-	
-	/**
-	 * Constructor
-	 * @param leftMotor
-	 * @param rightMotor
-	 * @param width
-	 * @param leftRadius
-	 * @param rightRadius
-	 */
-	public TwoWheeledRobot(NXTRegulatedMotor leftMotor,
-						   NXTRegulatedMotor rightMotor,
-						   double width,
-						   double leftRadius,
-						   double rightRadius) {
-		this.leftMotor = leftMotor;
-		this.rightMotor = rightMotor;
-		this.leftRadius = leftRadius;
-		this.rightRadius = rightRadius;
-		this.width = width;
-		leftMotor.setAcceleration(1000);
-		rightMotor.setAcceleration(1000);
-	}
-	/**
-	 * Constructor
-	 * @param leftMotor
-	 * @param rightMotor
-	 */
-	public TwoWheeledRobot(NXTRegulatedMotor leftMotor, NXTRegulatedMotor rightMotor) {
-		this(leftMotor, rightMotor, DEFAULT_WIDTH, DEFAULT_LEFT_RADIUS, DEFAULT_RIGHT_RADIUS);
-	}
-	/**
-	 * Constructor
-	 * @param leftMotor
-	 * @param rightMotor
-	 * @param width
-	 */
-	public TwoWheeledRobot(NXTRegulatedMotor leftMotor, NXTRegulatedMotor rightMotor, double width) {
-		this(leftMotor, rightMotor, width, DEFAULT_LEFT_RADIUS, DEFAULT_RIGHT_RADIUS);
-	}
-	
-	/**
-	 * Returns displacement based on TachoMeter count
-	 * @return
-	 */
-	public double getDisplacement() {
-		return (leftMotor.getTachoCount() * leftRadius +
-				rightMotor.getTachoCount() * rightRadius) *
-				Math.PI / 360.0;
-	}
-	/**
-	 *  returns heading based on tachoMeter count
-	 * @return
-	 */
-	public double getHeading() {
-		return (leftMotor.getTachoCount() * leftRadius -
-				rightMotor.getTachoCount() * rightRadius) / width;
-	}
-	/**
-	 * returns displacement and heading based on tacho counts -> passed through the data array pointer
-	 * @param data
-	 */
-	public void getDisplacementAndHeading(double [] data) {
-		int leftTacho, rightTacho;
-		leftTacho = leftMotor.getTachoCount();
-		rightTacho = rightMotor.getTachoCount();
-		
-		data[0] = (leftTacho * leftRadius + rightTacho * rightRadius) *	Math.PI / 360.0;
-		data[1] = (leftTacho * leftRadius - rightTacho * rightRadius) / width;
-	}
-	
-	/**
-	 * Sets forward robot speed (cm/s)
-	 * @param speed
-	 */
-	public void setForwardSpeed(double speed) {
-		forwardSpeed = speed;
-		setSpeeds(forwardSpeed, rotationSpeed);
-	}
-	
-	/**
-	 * sets rotational speed (deg/s)
-	 * @param speed
-	 */
-	public void setRotationSpeed(double speed) {
-		rotationSpeed = speed;
-		setSpeeds(forwardSpeed, rotationSpeed);
-	}
-	
-	/**
-	 * Sets both forward and rotational speed (cm/s, deg/s)
-	 * @param forwardSpeed
-	 * @param rotationalSpeed
-	 */
-	public void setSpeeds(double forwardSpeed, double rotationalSpeed) {
-		double leftSpeed, rightSpeed;
-
-		this.forwardSpeed = forwardSpeed;
-		this.rotationSpeed = rotationalSpeed; 
-
-		leftSpeed = (forwardSpeed + rotationalSpeed * width * Math.PI / 360.0) *
-				180.0 / (leftRadius * Math.PI);
-		rightSpeed = (forwardSpeed - rotationalSpeed * width * Math.PI / 360.0) *
-				180.0 / (rightRadius * Math.PI);
-
-		// set motor directions
-		if (leftSpeed > 0.0)
-			leftMotor.forward();
-		else {
-			leftMotor.backward();
-			leftSpeed = -leftSpeed;
-		}
-		
-		if (rightSpeed > 0.0)
-			rightMotor.forward();
-		else {
-			rightMotor.backward();
-			rightSpeed = -rightSpeed;
-		}
-		
-		// set motor speeds
-		if (leftSpeed > 900.0)
-			leftMotor.setSpeed(900);
-		else
-			leftMotor.setSpeed((int)leftSpeed);
-		
-		if (rightSpeed > 900.0)
-			rightMotor.setSpeed(900);
-		else
-			rightMotor.setSpeed((int)rightSpeed);
-	}
-	
-	/**
-	 * Stops robot
-	 */
-	public void stop() {
-		rightMotor.stop(true);
-		leftMotor.stop();
-	}
-}
diff --git a/Group-15/Lab4-15/USLocalizer.java b/Group-15/Lab4-15/USLocalizer.java
deleted file mode 100644
index b4e7d8a..0000000
--- a/Group-15/Lab4-15/USLocalizer.java
+++ /dev/null
@@ -1,325 +0,0 @@
-import java.util.ArrayList;
-import java.util.List;
-
-import lejos.nxt.Motor;
-import lejos.nxt.UltrasonicSensor;
-import lejos.nxt.comm.RConsole;
-
-/**
- * 
- * @project Lab 4 Localization 
- * @names Riley van Ryswyk & Aditya Saha
- * @studentID 260447357 & 260453165
- * @group 15
- * @course ECSE 211 
- * @date 06/10/2013
- * 
- * Ultrasonic Localization
- * Accurate to within ~3degs
- */
-
-public class USLocalizer {
-	
-	//Types of localization
-	public enum LocalizationType { FALLING_EDGE, RISING_EDGE };
-	
-	//Speed in deg/sec of which to rotate during localization
-	public static double ROTATION_SPEED = 30;
-	
-	//period to check ultrasonic sensor in ms
-	public final int UPDATE_PERIOD = 30;
-	
-	//threshold distance in cm, to determine if we are at a critical angle
-	public final int THRESHOLD = 30;
-	
-	//Objects for interaction with other classes
-	private Odometer odo;
-	private TwoWheeledRobot robot;
-	private UltrasonicSensor us;
-	private LocalizationType locType;
-	private Navigation nav;
-	
-	// Store list of previous ultrasonic sensor values for filtering
-	private List<Integer> usValues = new ArrayList<Integer>();
-	
-	/**
-	 * Ultrasonic sensor class constructor
-	 * @param odo
-	 * @param us
-	 * @param locType
-	 */
-	public USLocalizer(Odometer odo, UltrasonicSensor us, LocalizationType locType) {
-		this.odo = odo;
-		this.robot = odo.getTwoWheeledRobot();
-		this.us = us;
-		this.locType = locType;
-		this.nav = odo.getNavigation();
-		
-		// switch off the ultrasonic sensor
-		us.off();
-	}
-	
-	/**
-	 * Carrys out Ultrasonic localization
-	 */
-	public void doLocalization() {
-		
-		//to feed to odometer
-		double [] pos = new double [3];
-		
-		// Critical angles (when wall is detected/not detected
-		double angleA = -1, angleB = -1;
-		
-		//amount to adjust the heading by
-		double deltaTheta = 0;
-		
-		//to ensure we run only once an UPDATE_PERIOD
-		long correctionStart, correctionEnd;
-		
-		// to prevent errors when changing directions
-		int BDelay = 0; 
-		
-		//Fill the array of usValues with the current reading of the ultrasonic sensor
-		getFilteredData();
-		getFilteredData();
-		getFilteredData();
-		getFilteredData();
-		
-		/*
-		 * Falling edge detected (no wall -> wall)
-		 * 
-		 * 	rotate the robot until it sees no wall
-		 *  keep rotating until the robot sees a wall, then latch the angle
-		 *  switch direction and wait until it sees no wall
-		 *  keep rotating until the robot sees a wall, then latch the angle
-		 */
-		if (locType == LocalizationType.FALLING_EDGE) {
-			
-			//to keep track of whether we were facing a wall or not
-			boolean noWall = false;
-			
-			//Localization loop
-			locloop: 
-				while(true) {
-				
-				correctionStart = System.currentTimeMillis();
-				
-				//set the direction of rotation, once angleA is found it will be >0
-				if(angleA < 0) {
-					robot.setSpeeds(0, 40);
-				} else {
-					robot.setSpeeds(0, -40);
-					
-					//prevent detection of same wall/no wall barrier 
-					BDelay++;
-				}
-				
-				//retrieve the value of the filtered Ultrasonic data
-				int distance = getFilteredData();
-				
-				//We were seeing a wall and the distance is greater than the threshold -> we are not seeing a wall
-				if(!noWall && distance > THRESHOLD) {
-					
-					//update noWall
-					noWall = true;
-				} 
-				// we are not seeing a wall, haven't detected angleA and distance less than threshold -> we have found angleA
-				else if(noWall && angleA < 0 && distance < THRESHOLD) {
-					
-					//set angleA
-					angleA = odo.getTheta();
-					
-					//reset noWall
-					noWall = false;					
-				} 
-				//if we are not seeing a wall, and haven't detected angleB, the distance is less than the threshold and the delay since detecting angleA is greater than 50 iterations -> we have found angleB
-				else if(noWall && angleB < 0 && distance < THRESHOLD && BDelay > 50) {
-					
-					//set angleB
-					angleB = odo.getTheta();
-					
-					//Stop robot
-					robot.setSpeeds(0, 0);
-					
-					//break the us localization loop
-					break locloop;
-				}
-				
-				// this ensure the odometry correction occurs only once every period
-				correctionEnd = System.currentTimeMillis();
-				
-				if (correctionEnd - correctionStart < UPDATE_PERIOD) {
-					try {
-						Thread.sleep(UPDATE_PERIOD - (correctionEnd - correctionStart));
-					} catch (InterruptedException e) {
-						// there is nothing to be done here because it is not
-						// expected that the odometry correction will be
-						// interrupted by another thread
-					}
-				}
-				
-			}
-			
-			//first part of deltaTheta, the negative average of <A and <B
-			deltaTheta = -(angleA + angleB) / 2;
-			
-			//Depending on what angle is bigger, offset deltaTheta to the correct amount
-			if(angleA > angleB) {
-				deltaTheta += 226;
-			} else {
-				deltaTheta += 46;
-			}
-		} 
-		
-		/*
-		 * Rising Edge Detection
-		 * 
-		 * The robot should turn until it sees the wall, then look for the
-		 * "rising edges:" the points where it no longer sees the wall.
-		 * This is very similar to the FALLING_EDGE routine, but the robot
-		 * will face toward the wall for most of it.
-		 */
-		
-		else {
-			
-			// true if we are facing a wall
-			boolean wall = false;
-			
-			//localization loop
-			locloop: 
-				while(true) {
-				
-				correctionStart = System.currentTimeMillis();
-				
-				//Set speed of robot depending on whether we have detected angleA 
-				if(angleA < 0) {
-					robot.setSpeeds(0, 40);
-				} else {
-					robot.setSpeeds(0, -40);
-					//prevent incorrect detection of angleB (ie right after angleA has been detected)
-					BDelay++;
-				}
-				
-				//get filtered Ultrasonic data
-				int distance = getFilteredData();
-				
-				//if no wall and distance less than threshold -> we are seeing a wall
-				if(!wall && distance < THRESHOLD) {
-					wall = true;
-				} 
-				//if we were seeing a wall, angleA is not set and distance > threshold -> we have angleA
-				else if(wall && angleA < 0 && distance > THRESHOLD) {
-					
-					//set AngleA
-					angleA = odo.getTheta();
-					
-					//reset wall
-					wall = false;					
-					
-				} 
-				//if we were seeing a wall, angleB is not set, distance > threshold, and it has been more than 50 iterations since detecting angleA - > we have angleB
-				else if(wall && angleB < 0 && distance > THRESHOLD && BDelay > 50) {
-					
-					//set angleB
-					angleB = odo.getTheta();
-					
-					//stop robot
-					robot.setSpeeds(0, 0);
-					
-					//break the localization loop
-					break locloop;
-				}
-				
-				// this ensure the odometry correction occurs only once every period
-				correctionEnd = System.currentTimeMillis();
-				
-				if (correctionEnd - correctionStart < UPDATE_PERIOD) {
-					try {
-						Thread.sleep(UPDATE_PERIOD - (correctionEnd - correctionStart));
-					} catch (InterruptedException e) {
-						// there is nothing to be done here because it is not
-						// expected that the odometry correction will be
-						// interrupted by another thread
-					}
-				}
-				
-			}
-			
-			//first part of deltaTheta, the negative average of <A and <B
-			deltaTheta = -(angleA + angleB) / 2;
-			
-			//Depending on what angle is bigger, offset deltaTheta to the correct amount
-			if(angleB > angleA) {
-				deltaTheta += 228;
-			} else {
-				deltaTheta += 48;
-			}
-		}
-	
-		// initalize our position to x=-14, y=-14, theta += deltaTheta | we are roughly in the center of the square and deltaTheta was calculated by rising or falling edge detection
-		odo.setPosition(new double [] {-14.0, -14.0, odo.getTheta() + deltaTheta}, new boolean [] {true, true, true});
-		
-	}
-	
-	/**
-	 * Pings Ultrasonic sensor, waits for return and applys median filtering to the Ultrasonic data
-	 * @return
-	 */
-	private int getFilteredData() {
-		int distance;
-		
-		// do a ping
-		us.ping();
-		
-		// wait for the ping to complete
-		try { Thread.sleep(25); } catch (InterruptedException e) {}
-		
-		// there will be a delay here
-		distance = us.getDistance();
-		
-		//add the current value to array of values
-		usValues.add(distance);	
-		
-		//make sure we have sufficient number of samples
-		if(usValues.size() >= 5) {
-									
-			int result;
-			
-			//array of sorted values
-			List<Integer> usValuesSorted = new ArrayList<Integer>(usValues);
-			
-			//length of values (should be 5)
-			int size = usValuesSorted.size();
-			
-			//sort the values: lowest to highest
-			for(int i=0; i<size; i++) {
-				for(int j=i+1; j<size;j++) {
-					if(usValuesSorted.get(i) > usValuesSorted.get(j)) {
-						int temp = usValuesSorted.get(i);
-						usValuesSorted.set(i, usValuesSorted.get(j));
-						usValuesSorted.set(j, temp);					
-					}
-				}
-			}
-			
-			// if odd pick the middle value, else average the two middle values
-			if(size % 2 == 1 ) {
-				result = usValuesSorted.get(size/2);
-			} else {
-				result = ( usValuesSorted.get(size/2-1) + usValuesSorted.get(size/2) ) / 2;
-			}
-			
-			//shift values left by 1 for next iteration
-			usValues.remove(0);
-
-			//return result
-			return result;
-		} 
-		//not enough data for filtering yet, so return the current value
-		else {
-			return distance;
-		}		
-				
-	}
-
-}
diff --git a/Group-15/Lab5-15/Grid.java b/Group-15/Lab5-15/Grid.java
deleted file mode 100644
index 9b3e80a..0000000
--- a/Group-15/Lab5-15/Grid.java
+++ /dev/null
@@ -1,275 +0,0 @@
-import lejos.nxt.comm.RConsole;
-
-
-public class Grid {
-	
-	private final int FIELD_WIDTH = 4; 
-	private final int FIELD_LENGTH = 8;
-	private final int TILE_SIZE = 30;
-	
-	/*
-	 * Tiles array
-	 * indexed width,height
-	 * eg
-	 * 
-	 * 0,1 ; 1,1 ; 2,1 ; 3;1
-	 * 0,0 ; 1,0 ; 2,0 ; 3;0
-	 * 
-	 * such that (15,15) would be in title 1,1 
-	 * 
-	 * CODES:
-	 *  0 = empty
-	 *  1 = fully blocked
-	 *  2 = left 1/2 blocked (width direction)
-	 *  3 = right 1/2 blocked (width direction)
-	 *  4 = left 1/2 clear (width direction)
-	 *  5 = right 1/2 clear (width direction)
-	 *  6 = Unknown
-	 *  7 = inspection required
-	 *  8 = inspect object in tile
-	 * 
-	 */
-	private short[][] tiles = new short[FIELD_WIDTH][FIELD_LENGTH];
-	
-	public Grid() {
-		initalize();
-	}
-	
-	public void initalize() {
-		for(int i=0; i<tiles.length; i++) {
-			for(int j=0; j<tiles[0].length; j++) {
-				if(i < 3 && j < 3) {
-					//inital nine tiles are clear of any objects
-					tiles[i][j] = 0;
-				} else {
-					//tile is unknown to us
-					tiles[i][j] = 6;
-				}
-			}
-		}
-	}
-	
-	public void setTile(int w, int l, short state) {
-		RConsole.println("w;l" + String.valueOf(w) +";" + String.valueOf(l));
-		tiles[w][l] = state;
-	}
-	
-	public short getTitle(int w, int l) {
-		return tiles[w][l];
-	}
-	
-	public void setTilesScan(int start, int end, int scanPos, int distance, int heading) {
-		
-		int startTile = getTileIndexWidth(start);
-		int endTile = getTileIndexWidth(end);
-		
-		RConsole.println( "start;end " + String.valueOf(startTile) + ";" + String.valueOf(endTile) );
-		
-		if(distance == 255) {
-			RConsole.println("255");
-			for(int i = startTile; i<=endTile; i++) {
-				for(int j = getTileIndexLength(scanPos)+1; j<tiles[0].length; j++) {
-					if(tiles[i][j] != 1) { 
-						tiles[i][j] = 7;
-					}
-				}
-				
-			}
-			RConsole.println("/255");
-		} else {
-		
-			int freeTiles = ( (distance - ((scanPos+5) % TILE_SIZE)) / TILE_SIZE ) + 1;
-			
-			if(freeTiles + (scanPos / TILE_SIZE) > FIELD_LENGTH ) {
-				freeTiles = FIELD_LENGTH - (scanPos / TILE_SIZE);
-			}
-			
-			boolean startTileHalf;
-			
-			if(start > 0) {
-				startTileHalf= (start % TILE_SIZE > 15) ? true : false;
-			} else {
-				startTileHalf = ((start+30) % TILE_SIZE > 15) ? true : false;
-			}
-			boolean endTileHalf = (end % TILE_SIZE < 15) ? true : false;
-			int offset = (int) Math.floor(scanPos / TILE_SIZE) + 1;
-			
-			
-			RConsole.println( "free tiles " + String.valueOf(freeTiles) + "; offset " + String.valueOf(offset) );
-			RConsole.println( "distance to wall " + String.valueOf(distanceToWall(start, scanPos, heading)) );
-		
-			for(int j = offset; j<freeTiles+offset; j++) {
-				for(int i = startTile; i<=endTile; i++) {
-					RConsole.println(String.valueOf(i) + "," + String.valueOf(j));
-					if (startTileHalf && i == startTile ) {
-						if(tiles[i][j] != 2) {
-							tiles[i][j] = 0;
-						} 
-					} else if(endTileHalf && i == endTile) {
-						if(tiles[i][j] != 3) {
-							tiles[i][j] = 0;
-						} 
-					} else {
-						tiles[i][j] = 0;
-					}
-				}
-			}
-			
-			if( Math.abs(distance - distanceToWall(start, scanPos, heading)) > 10) {
-				//length is too long for styrofoam
-				boolean blocked = (Math.abs(start-end) > 40) ? true : false;
-				int j = getTileIndexLength(scanPos+distance);
-				for(int i = startTile; i<=endTile; i++) {
-					if(blocked) {
-						if(startTileHalf && i == startTile) {
-							if(tiles[i][j] == 2 || tiles[i][j] == 1) {
-								tiles[i][j] = 1;
-							} else {
-								tiles[i][j] = 3;
-							}
-						} else if(endTileHalf && i == endTile) {
-							if(tiles[i][j] == 3 || tiles[i][j] == 1) {
-								tiles[i][j] = 1;
-							} else {
-								tiles[i][j] = 2;
-							}
-						} else {
-							//block the tile
-							tiles[i][j] = 1;
-						}
-					} else {
-						//set it to inspect
-						tiles[i][j] = 8;
-					}
-					
-					
-				}
-			}
-		}
-		
-	}
-	
-	public int distanceToWall(int x, int y, int heading) {
-		if(Math.sin(Math.toRadians(heading)) > 0.95) {
-			return (int) ( (FIELD_LENGTH - 1) * TILE_SIZE - y );
-		} else {
-			return (int) ( (FIELD_WIDTH - 1) * TILE_SIZE - x );
-		}
-	}
-	
-	public int getTileIndexWidth(int x) {
-			
-		return  (int) Math.floor( (double) x / (double) TILE_SIZE) + 1;
-	}
-	
-	public int getTileIndexLength(int y) {
-		return (int) Math.floor( (double) y / (double) TILE_SIZE) + 1;
-	}
-	
-	public String printGrid() {
-		String result = "";
-		for(int i=0; i<tiles.length; i++) {
-			for(int j=0; j<tiles[0].length; j++) {
-				result += String.valueOf(tiles[i][j] + ",");
-			}
-			result += "\n";
-		}
-		
-		return result;
-	}
-	
-	public boolean contains(short value) {
-		for(int i=0; i<tiles.length; i++) {
-			for(int j=0; j<tiles[0].length; j++) {
-				if(tiles[i][j] == value) {
-					return true;
-				}
-			}
-		}
-		
-		return false;
-	}
-	
-	public boolean getClosestTile(int[] data, short value) {
-				
-		data[0] = getTileIndexWidth(data[0]);
-		data[1] = getTileIndexWidth(data[1]);
-		
-		double distance = 1000;
-		int w = -1;
-		int l = -1;
-		
-		for(int i=0; i<tiles.length; i++) {
-			for(int j=0; j<tiles[0].length; j++) {
-				if(tiles[i][j] == value) {
-					if ( Math.pow( (i - data[0]) , 2) + Math.pow( (i - data[0]) , 2) < distance) {
-						w = i;
-						l = j;
-						distance = Math.pow( (i - data[0]) , 2) + Math.pow( (i - data[0]) , 2);
-					}
-				}
-			}
-		}
-		
-		if(w == -1) {
-			return false;
-		} else {
-			
-			data[0] = w;
-			data[1] = l;
-			
-			return true;
-		}
-		
-	}
-	
-	public boolean getClosestTile2(int[] data, short value) {
-		
-		data[0] = getTileIndexWidth(data[0]);
-		data[1] = getTileIndexWidth(data[1]);
-		
-		double distance = 1000;
-		int l = -1;
-		int w = -1;
-		
-		for(int i=0; i<tiles.length; i++) {
-			for(int j=3; j<tiles[0].length; j++) {
-				if(tiles[i][j] == value) {
-					if ( j < distance) {
-						l = j;
-						w = i;
-						distance = j;
-					}
-				}
-			}
-		}
-		
-		if(l == -1) {
-			return false;
-		} else {
-			
-			data[0] = w;
-			data[1] = l;
-			
-			return true;
-		}
-		
-	}
-	
-	
-	
-	public int getX(int i) {
-		if(i==0) {
-			return i*30-10;
-		} else if (i == FIELD_WIDTH - 1) {
-			return i*30-20;
-		}
-		return i*30-15;
-	}
-	
-	public int getY(int j) {
-		return j*30-15;
-	}
-	
-
-}
diff --git a/Group-15/Lab5-15/LCDInfo.java b/Group-15/Lab5-15/LCDInfo.java
deleted file mode 100644
index 42d7982..0000000
--- a/Group-15/Lab5-15/LCDInfo.java
+++ /dev/null
@@ -1,77 +0,0 @@
-import lejos.nxt.LCD;
-import lejos.util.Timer;
-import lejos.util.TimerListener;
-
-/**
- * 
- * @project Lab 4 Localization 
- * @names Riley van Ryswyk & Aditya Saha
- * @studentID 260447357 & 260453165
- * @group 15
- * @course ECSE 211 
- * @date 06/10/2013
- * 
- * LCD display (from lab 4)
- */
-
-public class LCDInfo implements TimerListener{
-	public static final int LCD_REFRESH = 100;
-	private Odometer odo;
-	private Timer lcdTimer;
-	public enum BlockType { STYROFOAM, WOOD, NONE };
-	private BlockType type;
-	private boolean blockDetected = false;
-	
-	// arrays for displaying data
-	private double [] pos;
-	
-	/**
-	 * LCDInfo constructor
-	 * @param odo
-	 */
-	public LCDInfo(Odometer odo) {
-		this.odo = odo;
-		this.lcdTimer = new Timer(LCD_REFRESH, this);
-		
-		// initialise the arrays for displaying data
-		pos = new double [3];
-		
-		// start the timer
-		lcdTimer.start();
-	}
-	
-	/**
-	 * main update loop
-	 */
-	public void timedOut() { 
-		odo.getPosition(pos);
-		LCD.clear();
-		LCD.drawString("X: ", 0, 0);
-		LCD.drawString("Y: ", 0, 1);
-		LCD.drawString("H: ", 0, 2);
-		LCD.drawInt((int)(pos[0] * 10), 3, 0);
-		LCD.drawInt((int)(pos[1] * 10), 3, 1);
-		LCD.drawInt((int)pos[2], 3, 2);
-		
-		if(blockDetected) {
-			LCD.drawString(" Block Detected ", 0, 3);
-		}
-		
-		if(type == BlockType.STYROFOAM) {
-			LCD.drawString(" Styrofoam ", 0, 4);
-		} else if(type == BlockType.WOOD) {
-			LCD.drawString(" Wood ", 0, 4);
-		}
-	}
-	
-	public void type(BlockType type) {
-		this.type = type;
-	}
-	
-	public void blockDetected(boolean detected) {
-		blockDetected = detected;
-		if(detected = false) {
-			this.type = BlockType.NONE;
-		}
-	}
-}
diff --git a/Group-15/Lab5-15/Lab5.java b/Group-15/Lab5-15/Lab5.java
deleted file mode 100644
index a3eb28b..0000000
--- a/Group-15/Lab5-15/Lab5.java
+++ /dev/null
@@ -1,71 +0,0 @@
-import lejos.nxt.*;
-import lejos.nxt.comm.RConsole;
-
-/**
- * 
- * @project Lab 5 Object Recognition 
- * @names Riley van Ryswyk & Aditya Saha
- * @studentID 260447357 & 260453165
- * @group 15
- * @course ECSE 211 
- * @date 10/22/2013
- * 
- */
-
-public class Lab5 {
-
-	public static void main(String[] args) {
-		RConsole.openBluetooth(20000);
-		// setup the odometer, and ultrasonic and light sensors
-		TwoWheeledRobot patBot = new TwoWheeledRobot(Motor.B, Motor.A);
-		Odometer odo = new Odometer(patBot, true);
-		UltrasonicSensor us = new UltrasonicSensor(SensorPort.S2);
-		ColorSensor ls = new ColorSensor(SensorPort.S3);
-		UltrasonicPoller usPoller = new UltrasonicPoller(us, Motor.C, odo);
-				
-		//choose the lab part
-		int buttonChoice;
-		
-		do {
-			// clear the display
-			LCD.clear();
-
-			// ask the user whether rising or falling localization
-			LCD.drawString("< Left | Right >", 0, 0);
-			LCD.drawString("  Part | Part   ", 0, 1);
-			LCD.drawString("  One  | Two    ", 0, 2);
-
-			buttonChoice = Button.waitForPress();
-		} while (buttonChoice != Button.ID_LEFT
-				&& buttonChoice != Button.ID_RIGHT);
-		
-		//setup display
-		LCDInfo lcd = new LCDInfo(odo);
-		
-		//Object recognition
-		if (buttonChoice == Button.ID_LEFT) {
-			ObjectRecognitionOne one = new ObjectRecognitionOne(ls, usPoller, patBot, lcd);
-			one.start();
-			
-		} 
-		//Full lab 
-		else {
-			//initialize required classes
-			USLocalizer usl = new USLocalizer(odo, usPoller, USLocalizer.LocalizationType.FALLING_EDGE);
-			ObjectRecognitionTwo ort = new ObjectRecognitionTwo(ls, usPoller, patBot, odo);
-			ObjectFinding of = new ObjectFinding(usPoller, odo, ort);
-			//localize
-			usl.doLocalization();
-			
-			//Find the styrofoam
-			of.findStyrofoam();
-		}
- 		
-		
-		Button.waitForPress();
-	}
-	
-	
-	
-
-}
diff --git a/Group-15/Lab5-15/LightLocalizer.java b/Group-15/Lab5-15/LightLocalizer.java
deleted file mode 100644
index e7187a2..0000000
--- a/Group-15/Lab5-15/LightLocalizer.java
+++ /dev/null
@@ -1,199 +0,0 @@
-import java.util.ArrayList;
-import java.util.List;
-
-import lejos.nxt.ColorSensor;
-import lejos.nxt.Sound;
-import lejos.nxt.comm.RConsole;
-
-/**
- * 
- * @project Lab 4 Localization 
- * @names Riley van Ryswyk & Aditya Saha
- * @studentID 260447357 & 260453165
- * @group 15
- * @course ECSE 211 
- * @date 06/10/2013
- * 
- * Light sensor localization
- */
-
-public class LightLocalizer {
-	
-	private static final long CORRECTION_PERIOD = 10;
-	private Odometer odo;
-	private TwoWheeledRobot robot;
-	private ColorSensor lightSensor;
-	
-	//store light sensor values (for filtering purposes)
-	private List<Integer> lsValues = new ArrayList<Integer>();
-	
-	//the headings when a line is detected
-	private List<Double> angles = new ArrayList<Double>();
-	
-	// Keep track of whether we are on a line on not
-	private boolean onLine = false;
-	private int lineCount = 0;
-	
-	// tile size, light sensor offset
-	private final double TILE_SIZE = 30.48, LS_OFFSET = 12.8;
-	
-	/**
-	 * Light sensor localization constructor
-	 * @param odo
-	 * @param ls
-	 */
-	public LightLocalizer(Odometer odo, ColorSensor ls) {
-		this.odo = odo;
-		this.robot = odo.getTwoWheeledRobot();
-		this.lightSensor = ls;
-		
-		//for line detection
-		Sound.setVolume(50);
-		// turn on the light to red
-		ls.setFloodlight(0);
-		
-	}
-	
-	/**
-	 * do light sensor localization
-	 * finds x, y, theta to within 0.2cm, 1 deg
-	 */
-	public void doLocalization() {
-		// drive to location listed in tutorial
-		// start rotating and clock all 4 gridlines
-		// do trig to compute (0,0) and 0 degrees
-		// when done travel to (0,0) and turn to 0 degrees
-		
-		// travel to roughly -4cm, -4cm
-		odo.getNavigation().travelTo(-4.0,-4.0);
-		
-		//Initialize line count to 0
-		lineCount = 0;
-		
-		//clear angles array
-		angles.clear();
-		
-			
-		//ensures that we pass the lines in the same order every time | could be avoided with a more sophisticated calculation of thetaX and thetaY
-		if(odo.getTheta() > 80) {
-			odo.getNavigation().turnTo(45);
-		}
-				
-		//to mantain the correct CORRECTION_PERIOD
-		long correctionStart, correctionEnd;
-		
-		//line detection loop
-		while (lineCount < 4) {
-			correctionStart = System.currentTimeMillis();
-			
-			//sets robot to rotate at 35 deg/s
-			robot.setSpeeds(0, 35);
-			
-			//filters the light sensor information, and determines if a line was detected or not
-			detectLine(filterLightSensor());
-			
-			// this ensure the odometry correction occurs only once every period
-			correctionEnd = System.currentTimeMillis();
-			
-			if (correctionEnd - correctionStart < CORRECTION_PERIOD) {
-				try {
-					Thread.sleep(CORRECTION_PERIOD
-							- (correctionEnd - correctionStart));
-				} catch (InterruptedException e) {
-					// there is nothing to be done here because it is not
-					// expected that the odometry correction will be
-					// interrupted by another thread
-				}
-			}
-		}
-		
-		//stop robot
-		robot.setSpeeds(0, 0);
-		
-		//resets onLine
-		onLine = false;
-		
-		// calculates the angle spanned between the headings of the robot when the lines on the X and Y axes were detected respectively
-		double thetaX = angles.get(0) - angles.get(2);
-		double thetaY = angles.get(1) - angles.get(3);
-		
-		// Based on the above angles, the current x, y coordinates are calculated (assuming 0,0 is the closest intersection)
-		double x = -LS_OFFSET * Math.cos(Math.toRadians(thetaY/2.0));
-		double y = -LS_OFFSET * Math.cos(Math.toRadians(thetaX/2.0));
-		
-		// if the first detection was at a heading of between [0,60], we are not in the negative x,y region
-		// so invert y | x will be correctly inverted
-		if(angles.get(0) < 60) {
-			y = -y;
-		} 
-		
-		// we are not in the right stop to determine theta -> update current position (x,y) and then redo localization
-		if(x > 0 || y > 0) {
-			odo.setPosition(new double [] {x, y, odo.getTheta() }, new boolean [] {true, true, true});
-			doLocalization();
-		}
-		//localization was successful
-		else {
-			// calculate amount to adjust theta by, achieved through averaging the values for dTheta calculated on both the x and y axes
-			double dTheta = (439-thetaX/2.0-thetaY/2.0-angles.get(3)-angles.get(2))/2.0;
-			
-			//update our current position 
-			odo.setPosition(new double [] {x, y, odo.getTheta()+dTheta }, new boolean [] {true, true, true});
-		}
-		
-	}
-	
-	/**
-	 * Applys smoothing and differencing to the recorded values
-	 * detects when black line is detected and when the regular floor is detected again 
-	 */
-	public int filterLightSensor() {
-		
-		if(lsValues.size()<3) {
-			int value = lightSensor.getRawLightValue();
-			lsValues.add(value / 2);
-			return value;
-		} else {
-		
-			lsValues.add(lightSensor.getRawLightValue() / 2);
-			
-			int result;
-			
-			// Smooth and difference
-			result = /*-lsValues.get(0) - lsValues.get(1) +*/ lsValues.get(2) + lsValues.get(3);
-						
-			//shift values left by 1 for next iteration
-			lsValues.remove(0);
-			
-			return result;
-		}
-	}
-	
-	/**
-	 * when a line is detected, add it to the array of line detected angles
-	 */
-	public void lineDetected() {
-		angles.add(odo.getTheta());
-	}
-	
-	public void detectLine(int value) {
-		//if not currently on a line and filter result is less than -45 we just enter a line			
-			if(!onLine && value < -45) {
-				onLine = true;
-				
-				//go to line detection logic
-				lineDetected();
-				
-				//alert us with a beep that a line was detected
-				Sound.beep();
-				
-				lineCount++;
-				
-			} 
-			//if we are on a line and filter result > 45 we have now left the line
-			else if(onLine && value > 45) {
-				onLine = false;
-			}
-	}
-
-}
diff --git a/Group-15/Lab5-15/LightPoller.java b/Group-15/Lab5-15/LightPoller.java
deleted file mode 100644
index 1648902..0000000
--- a/Group-15/Lab5-15/LightPoller.java
+++ /dev/null
@@ -1,131 +0,0 @@
-import java.util.ArrayList;
-import java.util.List;
-
-import lejos.nxt.ColorSensor;
-import lejos.nxt.comm.RConsole;
-import lejos.util.Timer;
-import lejos.util.TimerListener;
-
-
-public class LightPoller implements TimerListener {
-
-	private static final int CORRECTION_PERIOD = 20;
-	
-	private ColorSensor ls;
-	
-	//store light sensor values (for filtering purposes)
-	private List<Integer> lsValues = new ArrayList<Integer>();
-	
-	private Timer lsTimer;
-	
-	private boolean started;
-	
-	private Object lock;
-	
-	private int floodLightColor = 0;
-
-	
-	public LightPoller(ColorSensor ls) {
-		this.ls = ls;
-		this.lsTimer = new Timer(CORRECTION_PERIOD, this);
-		this.lock = new Object();
-		ls.setFloodlight(floodLightColor);
-	}
-	
-	public void timedOut() {
-		
-		int value = ls.getRawLightValue();
-		RConsole.println(String.valueOf(value));
-		synchronized (lock) {
-			lsValues.add(value / 2);
-			
-			if(lsValues.size()>3) {	
-				lsValues.remove(0);
-			}
-		}
-	}
-	
-	public void start() {
-		if(!started) {
-			lsTimer.start();
-			started = true;
-		}		
-	}
-	
-	public void stop() {
-		if(started) {
-			lsTimer.stop();
-			started = false;
-		}
-	}
-	
-	public void setFloodLight(int color) {
-		//this.stop();
-		ls.setFloodlight(color);		
-		floodLightColor = color;
-		
-		while (ls.getRawLightValue() == -1) {
-			try {
-				Thread.sleep(250);
-			} catch (Exception e) {
-			}
-			RConsole.println(String.valueOf(ls.getFloodlight()));
-			ls.setFloodlight(color);
-		}
-		
-		synchronized (lock) {
-			lsValues.clear();
-		}
-		
-		//this.start();
-		
-	}
-	
-	public int differenceFilter() {
-		
-		int result;
-		
-		synchronized (lock) {
-			if(lsValues.size()<3) {
-				result =  lsValues.get(lsValues.size()-1);
-			} else {
-				// Smooth and difference
-				result =  -lsValues.get(0) - lsValues.get(1) + lsValues.get(2) + lsValues.get(3);
-			}
-		}
-		
-		return result;
-	}
-	
-	public int smoothingFilter() {
-		int result;
-		
-		synchronized (lock) {
-			if(lsValues.size() >= 4 ) {
-				// Smooth
-				result = lsValues.get(2) + lsValues.get(3);
-			} else if(lsValues.size() > 1) {
-				result =  lsValues.get(lsValues.size()-1) + lsValues.get(lsValues.size()-2);
-			} else if (lsValues.size() == 1) {
-				result = lsValues.get(0) * 2;
-			} else {
-				result = ls.getRawLightValue();
-			}
-		}
-		
-		return result;
-	}
-	
-	public int calibrateSensor() {
-		
-		setFloodLight(0);
-		
-		return smoothingFilter();		
-	}
-	
-	public int getLightValue() {
-		return ls.getRawLightValue();
-	}
-	
-	
-}
diff --git a/Group-15/Lab5-15/Navigation.java b/Group-15/Lab5-15/Navigation.java
deleted file mode 100644
index c2829b8..0000000
--- a/Group-15/Lab5-15/Navigation.java
+++ /dev/null
@@ -1,366 +0,0 @@
-import lejos.nxt.comm.RConsole;
-
-
-/**
- * 
- * @project Lab 4 Localization 
- * @names Riley van Ryswyk & Aditya Saha
- * @studentID 260447357 & 260453165
- * @group 15
- * @course ECSE 211 
- * @date 06/22/13
- * 
- * Navigation 
- * 
- */
-public class Navigation {
-
-	private Odometer odometer;
-	private TwoWheeledRobot robot;
-
-	// Update every 50ms
-	private static final long UPDATE_PERIOD = 50;
-
-	// Max speeds in cm/sec, deg/sec
-	private final int MAX_FORWARD_SPEED = 8;
-	private final int MAX_ROTATE_SPEED = 40;
-
-	// navigation variables
-	private static boolean navigating = false;
-	private static boolean turning = false;
-	private boolean paused = false;
-
-	public Navigation(Odometer odo) {
-		this.odometer = odo;
-		this.robot = odo.getTwoWheeledRobot();
-	}
-
-
-	/**
-	 * Method to travel to a set of Cartesian coordinates
-	 * @param x
-	 * @param y
-	 */
-	public void travelTo(double x, double y) {
-
-		// we're navigating
-		navigating = true;
-
-		long correctionStart, correctionEnd;
-
-		// main loop
-		travelLoop: while (navigating) {
-			correctionStart = System.currentTimeMillis();
-
-			if(!paused) {
-
-				/*
-				 * retrieve current position and calculate dX and dY
-				 */
-				double[] pos = new double[3];
-
-				odometer.getPosition(pos);
-
-				double currentX = pos[0];
-				double currentY = pos[1];
-				double currentTheta = pos[2];
-
-				// Distance between where we are and where we need to travel to
-				double dX = x - currentX;
-				double dY = y - currentY;
-
-				/*
-				 * if within 0.5cm (x&y) of the destination x,y stop otherwise
-				 * continuing traveling
-				 */
-				if (Math.abs(dX) < 1 && Math.abs(dY) < 1) {
-					navigating = false;
-					robot.stop();
-					break travelLoop;
-				}
-				/*
-				 * We are not at our destination and the path is clear
-				 */
-				else {
-
-					// the required theta to travel to our destination
-					double theta = Math.atan2(dY, dX) * 180.0 / Math.PI;
-					// adjust to [0, 360]
-					theta = (theta < 0) ? 360 + theta : theta;
-
-					// error in theta
-					double deltaTheta = theta - currentTheta;
-
-					// Change deltaTheta to [0,360)
-					if (deltaTheta > 180) {
-						deltaTheta -= 360;
-					} else if (deltaTheta < -180) {
-						deltaTheta += 360;
-					}
-
-					// see if we need to make a big turn
-					if (Math.abs(deltaTheta) > 5 ) {
-						// if we need to turn more than 0.2 rads or 0.1 for
-						// completing a turn, call the turnTo method
-						// otherwise we can adjust small angle errors by slowing one
-						// wheel down slightly
-						turnTo(theta);
-
-					}
-					// We need to go straight (or relatively straight)
-					else {
-
-						/*
-						 * For minor angle corrections
-						 */
-
-
-						// amount to change right wheel speed by
-						int dL = 0;
-
-
-						// If angle error is greater than 3 deg, make adjustment
-						if (Math.abs(deltaTheta) > 0.5) {
-
-							// if we are facing to the left of where we should be,
-							// slight right
-							if (deltaTheta > 0) {
-
-								dL = -5;
-							}
-
-							// if we are facing to the right of where we should be,
-							// slight left
-							else if (deltaTheta < 0) {
-
-								dL = 5;
-							}
-						}
-
-						/*
-						 * End minor angle corrections
-						 */
-
-						// Distance to destination
-						double distanceToTravel = (dX * Math.cos(Math.toRadians(currentTheta)))	+ (dY * Math.sin(Math.toRadians(currentTheta)));
-						// high speed
-						if (distanceToTravel > 3) {
-							robot.setSpeeds(MAX_FORWARD_SPEED, dL);
-						}
-						// start to slow down
-						else if (distanceToTravel > 1) {
-							robot.setSpeeds(MAX_FORWARD_SPEED / 2, dL);
-						}
-						// go really slow, so that we don't overshoot
-						else {
-							robot.setSpeeds(MAX_FORWARD_SPEED / 5, dL / 3);
-						}
-
-					}  
-				}  
-			} 
-			//paused
-			else {
-				robot.setSpeeds(0, 0);
-			}
-
-			// this ensure the odometry correction occurs only once every
-			// period
-
-
-			correctionEnd = System.currentTimeMillis();
-
-			if (correctionEnd - correctionStart < UPDATE_PERIOD) {
-				try {
-					Thread.sleep(UPDATE_PERIOD
-							- (correctionEnd - correctionStart));
-				} catch (InterruptedException e) {
-					// there is nothing to be done here because it is not
-					// expected that the odometry correction will be
-					// interrupted by another thread
-				}
-			}
-		}
-	}
-
-
-	/**
-	 * Orientents the robot to the specified angle
-	 * @param angle
-	 */
-	public void turnTo(double angle) {
-	
-		// we are turning
-		if (!turning)
-			turning = true;
-	
-		long correctionStart, correctionEnd;
-	
-		// main loop
-		while (turning) {
-			correctionStart = System.currentTimeMillis();
-	
-			if(!paused) {
-	
-				// error in angle
-				double deltaTheta = angle - odometer.getTheta();
-	
-				// convert to [-180,180] for minimal angle
-				if (deltaTheta > 180) {
-					deltaTheta -= 360;
-				} else if (deltaTheta < -180) {
-					deltaTheta += 360;
-				}
-	
-				// if angle error greater than 1 deg
-				if (Math.abs(deltaTheta) >= 1) {
-					// if error positive and greater than 5 deg -> max speed CCW
-					if (deltaTheta > 8) {
-						robot.setSpeeds(0, -MAX_ROTATE_SPEED);
-					}
-					// positive error, but close to 0, so turn slow CCW to prevent
-					// overshoot
-					else if (deltaTheta > 0) {
-						robot.setSpeeds(0, -MAX_ROTATE_SPEED / 4);
-					}
-					// error negative and less than 5deg -> max speed CW
-					else if (deltaTheta < -8) {
-						robot.setSpeeds(0, MAX_ROTATE_SPEED);
-					}
-					// negative error, but close to 0, so turn slow CW to prevent
-					// overshoot
-					else if (deltaTheta < 0) {
-						robot.setSpeeds(0, MAX_ROTATE_SPEED / 4);
-					}
-				} else {
-					// we have finished turning
-					turning = false;
-					robot.stop();
-				}
-			} 
-			//paused
-			else {
-				robot.setSpeeds(0, 0);
-			}
-			// this ensure the odometry correction occurs only once every period
-			correctionEnd = System.currentTimeMillis();
-	
-			if (correctionEnd - correctionStart < UPDATE_PERIOD) {
-				try {
-					Thread.sleep(UPDATE_PERIOD
-							- (correctionEnd - correctionStart));
-				} catch (InterruptedException e) {
-					// there is nothing to be done here because it is not
-					// expected that the odometry correction will be
-					// interrupted by another thread
-				}
-			}
-		}
-	
-	}
-
-	/**
-	 * backups the robot up along the current heading by a specific distance
-	 * @param distance
-	 */
-	public void backup(int distance) {
-		// we're navigating
-		navigating = true;
-	
-		long correctionStart, correctionEnd;
-	
-	
-		double[] pos = new double[3];
-	
-		odometer.getPosition(pos);
-	
-		double startX = pos[0];
-		double startY = pos[1];
-	
-		// main loop
-		travelLoop: while (navigating) {
-			correctionStart = System.currentTimeMillis();
-	
-			if(!paused) {
-				
-				/*
-				 * retrieve current position and calculate dX and dY
-				 */
-				
-				odometer.getPosition(pos);
-	
-				double currentX = pos[0];
-				double currentY = pos[1];
-	
-	
-				// Distance between where we are and where we need to travel to
-				double dX = currentX - startX;
-				double dY = currentY - startY;
-	
-				/*
-				 * if greater than the desired distance stop
-				 */
-				if (Math.pow(dX, 2) + Math.pow(dY, 2) > Math.pow(distance, 2)) {
-					navigating = false;
-					robot.stop();
-					break travelLoop;
-				}
-				/*
-				 * We are not at our destination so continue backing up
-				 */
-				else {
-					robot.setSpeeds(-MAX_FORWARD_SPEED/2, 0);
-				}
-			} 
-			//pause traveling
-			else {
-				robot.setSpeeds(0, 0);
-			}
-			// this ensure the odometry correction occurs only once every
-			// period
-			correctionEnd = System.currentTimeMillis();
-	
-			if (correctionEnd - correctionStart < UPDATE_PERIOD) {
-				try {
-					Thread.sleep(UPDATE_PERIOD
-							- (correctionEnd - correctionStart));
-				} catch (InterruptedException e) {
-					// there is nothing to be done here because it is not
-					// expected that the odometry correction will be
-					// interrupted by another thread
-				}
-			}
-		}
-	}
-	
-	
-	/**
-	 * Returns true if the robot is navigating or turning
-	 * @return
-	 */
-	public static boolean isNavigating() {
-		return navigating;
-	}
-	
-	/**
-	 * stop navigating
-	 * causes the travelloop to stop in each of the traveling methods
-	 */
-	public void stop() {
-		navigating = false;
-		turning = false;
-	}
-	
-	/*
-	 * pauses traveling
-	 */
-	public void pause() {
-		paused = true;
-	}
-	
-	//resumes traveling
-	public void resume() {
-		paused = false;
-	}
-
-}
diff --git a/Group-15/Lab5-15/ObjectFinding.java b/Group-15/Lab5-15/ObjectFinding.java
deleted file mode 100644
index f2d478a..0000000
--- a/Group-15/Lab5-15/ObjectFinding.java
+++ /dev/null
@@ -1,253 +0,0 @@
-import lejos.nxt.comm.RConsole;
-
-/**
- * 
- * @project Lab 4 Localization 
- * @names Riley van Ryswyk & Aditya Saha
- * @studentID 260447357 & 260453165
- * @group 15
- * @course ECSE 211 
- * @date 06/22/2013
- * 
- * Object Finding
- * 
- *  Contained within this class is the main loop for traversing the course while looking for the styrofoam block
- *  
- *  Initially a different approach was taken with regards to lab 5.  That method was to map the enclosure as it looked for the styrofoam block
- *  this was eliminate due to time constraints (because of the previous strategies failing).    
- * 
- */
-public class ObjectFinding {
-	
-	//Objects to interact with other classes
-	private UltrasonicPoller usPoller;
-	private Odometer odo;
-	private ObjectRecognitionTwo ort;
-	private Navigation nav;
-	
-	/**
-	 * Constructor
-	 * @param usPoller
-	 * @param odo
-	 * @param ort
-	 */
-	public ObjectFinding(UltrasonicPoller usPoller, Odometer odo, ObjectRecognitionTwo ort) {
-		this.usPoller = usPoller;
-		this.odo = odo;
-		this.ort = ort;
-		this.nav = odo.getNavigation();
-
-	}
-	
-	
-	
-	/**
-	 * Find styrofoam loop
-	 * 
-	 * This method could have been implemented in a better manner, however, due to time constraints it was not possible
-	 */
-	public void findStyrofoam() {
-		
-		//travel to the start coordinates
-		nav.travelTo(70, 30);
-		
-		/*
-		 * Continue running until the robot has found the styrofoam
-		 */
-		while(!ort.getHaveStyrofoam()) {
-			
-			/*
-			 * Scans for objects ahead to know when to stop looking to the side (avoid crashing)
-			 * 
-			 * checks in 3 different offsets (left, center, right) in case the block is not directly ahead
-			 * 
-			 */
-			nav.turnTo(20);
-			usPoller.rotateUS(90);
-			int d1 = usPoller.scan();
-			
-			nav.turnTo(90);
-			usPoller.rotateUS(90);
-			int d2 = usPoller.scan();
-			
-			nav.turnTo(110);
-			usPoller.rotateUS(90);
-			int d3 = usPoller.scan();
-			
-			//return to previous orientation
-			nav.turnTo(90);
-			final int distanceToBlock;
-			//intiliaze yStart
-			int yStart = (int) odo.getY();
-			
-			//choose the smallest distance obtained
-			if( d1 < d2 && d1 < d3) {
-				distanceToBlock = d1+yStart;
-			} else if( d2 < d3 && d2 < d1) {
-				distanceToBlock = d2+yStart;
-			} else {
-				distanceToBlock = d3+yStart;
-			}
-			
-			//RConsole.println("distance to block " + String.valueOf(distanceToBlock));
-			
-			//initialize variables
-			int usLastValue = 256;
-			int usCurrentValue;
-			double y = odo.getY();
-			
-			int yEnd;
-			boolean start = false;
-
-			//rotate the ultrasonic to look to the left  
-			usPoller.rotateUS(180);
-			usPoller.clear();
-			
-			//start polling with timerlistner
-			usPoller.start();
-			
-			
-			//travel to the block ahead - 15cm
-			(new Thread() {
-				public void run() {
-					nav.travelTo(odo.getX(), distanceToBlock - 15);
-				}
-			}).start();
-		
-			/*
-			 * look to the left until we reach the block in front of us - 15cm
-			 */
-			while (y < distanceToBlock - 16) {
-				
-				//retrieve what the ultrasonic sensor is reading
-				usCurrentValue = usPoller.filterUS();
-				
-				//update the y coordinate
-				y = odo.getY();
-				//RConsole.println(String.valueOf(usCurrentValue));
-				
-				//don't do anything if this is the first time running (firsttime usLastValue ==256)
-				if(usLastValue != 256) {
-					
-					/*
-					 * we are reading something closer than before, and we have not detected a rising edge yet
-					 * thus the robot has found the first edge of the block
-					 */
-					if((usCurrentValue - usLastValue < -15) && !start) {
-						//store the starting y
-						yStart = (int) odo.getY();
-						start = true;
-						//RConsole.println(String.valueOf(usCurrentValue) + ";" + String.valueOf(usLastValue));
-					} 
-					/*
-					 * we are reading something farther than before, and we have detected a rising edge
-					 * thus the robot has found the last edge of the block
-					 */
-					else if((usLastValue - usCurrentValue < -15 || usLastValue == 255 ) && usCurrentValue != 255 && start) {
-						//store end coordinate
-						yEnd = (int) odo.getY();
-						//stop polling values
-						usPoller.stop();
-						//stop going forward, so we can inspect the block we have just found
-						nav.stop();
-						
-						//Sleep for a little while to ensure navigation stops
-						try {
-							Thread.sleep(100);
-						} catch (InterruptedException e) {
-							// TODO Auto-generated catch block
-							e.printStackTrace();
-						}
-						
-						//go to inspect method, which will inspect the block
-						ort.inspect(yStart, yEnd, usLastValue);
-						
-						//in case the block was not the styrofoam
-						if(!ort.getHaveStyrofoam()) {
-							
-							/*
-							 * reset to detect the next obstacle
-							 */
-							start = false;
-							usLastValue = 256;
-							
-							//resume traveling to the block in front of us
-							(new Thread() {
-								public void run() {
-									nav.travelTo(odo.getX(), distanceToBlock -15);
-								}
-							}).start();
-						}
-					}
-					
-				}
-				
-				//update usLastValue for the next iteration
-				usLastValue = usCurrentValue;
-				
-				//Make sure we don't run to often
-				try {
-					Thread.sleep(35);
-				} catch (InterruptedException e) {
-					// TODO Auto-generated catch block
-					e.printStackTrace();
-				}
-				
-			}
-			
-			/*
-			 * when we reach the block in front of us inspect it
-			 */
-			
-			nav.turnTo(90);
-			usPoller.rotateUS(90);
-			
-			//inspect the block
-			ort.inspect2(90);
-			boolean blocked = true;
-			
-			/*
-			 * this will move the robot to the left by one tile until the tile in front of it (at heading of 90deg) is clear
-			 * 
-			 * one imporvement that was not implemented would be to move the robot back to its inital x position after the block in front had been cleared
-			 */
-			while(blocked) {
-				//travel to one tile over
-				nav.travelTo(odo.getX() - 30, odo.getY());
-				
-				/*
-				 * inspect tile in front
-				 */
-				nav.turnTo(90);
-				
-				int angleAValue;
-				int angleBValue;
-				int angleCValue;
-				
-				//scan at three offsets to check left, middle, right
-				nav.turnTo(90 + 30);
-				usPoller.rotateUS(90 + 15);
-				angleAValue = usPoller.scan();
-				nav.turnTo(90);
-				usPoller.rotateUS(90);
-				angleBValue = usPoller.scan();
-				nav.turnTo(90 - 40);
-				usPoller.rotateUS(90);
-				angleCValue = usPoller.scan();
-				
-				//if the values report back as all greater than 60 we can travel in the +y direction again and continue the scanning
-				if(angleAValue > 60 && angleBValue > 60 && angleCValue > 60) {
-					blocked = false;
-					break;
-				}				
-				
-			}
-			
-			//returns to first loop
-		}		
-		
-		//Done
-		//RConsole.println("Done");
-	}
-
-}
diff --git a/Group-15/Lab5-15/ObjectRecognitionOne.java b/Group-15/Lab5-15/ObjectRecognitionOne.java
deleted file mode 100644
index 71dd963..0000000
--- a/Group-15/Lab5-15/ObjectRecognitionOne.java
+++ /dev/null
@@ -1,217 +0,0 @@
-import lejos.nxt.ColorSensor;
-import lejos.nxt.comm.RConsole;
-import lejos.util.Timer;
-import lejos.util.TimerListener;
-
-/**
- * 
- * @project Lab 4 Localization 
- * @names Riley van Ryswyk & Aditya Saha
- * @studentID 260447357 & 260453165
- * @group 15
- * @course ECSE 211 
- * @date 06/22/2013
- * 
- * Object Recognition One (for part 1)
- * 
- *  The class is used to differentiate between the styrofoam block and wood block
- * 
- */
-
-public class ObjectRecognitionOne implements TimerListener {
-
-	private ColorSensor ls;
-	private UltrasonicPoller usPoller;
-	private TwoWheeledRobot robot;
-	private LCDInfo display;
-	private Timer oroTimer;
-	private int lastUSValue;
-	private boolean objectDetected;
-
-	private LCDInfo.BlockType object;
-	private int lsCalibration = -1;
-	private boolean typeDetected = false;
-	
-	/**
-	 * Object Recognition One Constructor
-	 * @param ls
-	 * @param usPoller
-	 * @param robot
-	 * @param display
-	 */
-	public ObjectRecognitionOne(ColorSensor ls, UltrasonicPoller usPoller, TwoWheeledRobot robot, LCDInfo display) {
-		this.ls = ls;
-		this.usPoller = usPoller;
-		this.robot = robot;
-		this.display = display;
-		this.lastUSValue = 256;
-		this.objectDetected = false;
-		this.oroTimer = new Timer(40, this);
-		ls.setFloodlight(0);
-	}
-	
-	/**
-	 * TimerListner loop
-	 * 
-	 * This method will cause the robot to travel forward if there is an object within 40cm and it will use the light sensor to reach an appropriate distance to check if the block is wood or styrofoam
-	 */
-	public void timedOut() {
-		
-		/*
-		 * ensures the ultrasonic poller has started
-		 */
-		if(lastUSValue < 256) {
-			//retrieve new ultrasonic poller value
-			int newUSValue = usPoller.filterUS();
-		
-			/*
-			 * if an object was detected earlier
-			 */
-			if(objectDetected) {
-				/*
-				 * if the us sensor reports a distance of more than 40, we no longer see the object
-				 */
-				if(newUSValue > 40) {
-					//reset variables and the lcd display + stop the robot from moving forward
-					objectDetected = false;
-					display.blockDetected(false);
-					display.type(LCDInfo.BlockType.NONE);
-					typeDetected = false;
-					robot.setSpeeds(0, 0);
-				} 
-				/*
-				 * the robot still sees the object and the type has not yet been distinguished
-				 */
-				else if(!typeDetected) {
-					
-					//get the current light sensor reading
-					int lsValue = ls.getRawLightValue();
-					
-					/*
-					 * if the difference is less than 5 the robot is far from the object, approach faster
-					 */
-					if(lsValue-lsCalibration < 5) {
-						robot.setSpeeds(6,0);
-					} 
-					
-					/*
-					 * if the difference 5 < d < 10 the robot is nearing the object, approach at half the speed
-					 */
-					else if(lsValue-lsCalibration < 10) {
-						robot.setSpeeds(3, 0);
-					} 
-					/*
-					 * if the difference is 10 < d < 20 the robot is close to the object, approach slowly
-					 */
-					else if(lsValue-lsCalibration < 20) {
-						robot.setSpeeds(1.5, 0);
-					} 
-					/*
-					 * the robot is close enough to take accurate light reading and make a decision
-					 */
-					else {
-						//stop moving
-						robot.setSpeeds(0, 0);
-						
-						//stop the timeOut timer
-						oroTimer.stop();
-						
-						//store the light sensor value when the floodlight is red
-						int redValue = lsValue;
-						
-						//change the floodlight to blue
-						ls.setFloodlight(2);
-						
-						//ensures the floodlight is set to blue before continuing
-						while(ls.getRawLightValue() == -1) {
-							try { Thread.sleep(50); } catch (InterruptedException e) {}
-						}
-						
-						//store the light sensor value when the floodlight is blue
-						int blueValue = ls.getRawLightValue();
-						
-						// if the difference between the red and blue is greater than 25, it is a wood block
-						// actually difference is ~100
-						if (redValue - blueValue > 25) {
-							object = LCDInfo.BlockType.WOOD;
-						} 
-						/*
-						 * otherwise it is a styrofoam block
-						 * difference between red and blue for styrofoam is <5
-						 */
-						else {
-							object = LCDInfo.BlockType.STYROFOAM;
-						}
-						
-						// show the type of block on the LCD
-						display.type(object);
-						
-						//reset the the floodlight to red
-						ls.setFloodlight(0);
-						
-						//ensures the floodlight is red
-						while(ls.getRawLightValue() == -1) {
-							try { Thread.sleep(50); } catch (InterruptedException e) {}
-						}	
-						
-						//type is detected
-						typeDetected = true;
-						
-						//start timeOut timer to check when the block is removed and when a new one is placed in front
-						oroTimer.start();
-						
-					}
-				}
-			}
-			/*
-			 * object is near, determine its type
-			 */
-			else if(newUSValue < 40) {
-				
-				objectDetected = true;
-				//show that a block was detected on the LCD
-				display.blockDetected(true);
-			}
-			
-		} 
-		/*
-		 * only for the inital running | makes sure the usPoller has started
-		 */
-		else {
-			lastUSValue = usPoller.filterUS();
-			
-		}
-	}
-	
-	/**
-	 * starts the timer for the timeOut loop
-	 */
-	public void start() {
-				
-		//starts the ultrasonic poller timer
-		usPoller.start();
-		
-		//set floodlight to red
-		ls.setFloodlight(0);
-		
-		//calibrates the light sensor (retrieves ambient light value)
-		while (lsCalibration < 0) {
-			lsCalibration = ls.getRawLightValue();
-			try { Thread.sleep(50); } catch (InterruptedException e) {}
-		}
-		
-		//start the timer
-		oroTimer.start();
-
-	}
-	
-	/**
-	 * stops the timeOut timer
-	 */
-	public void stop() {
-		oroTimer.stop();
-	}
-	
-	
-	
-}
diff --git a/Group-15/Lab5-15/ObjectRecognitionTwo.java b/Group-15/Lab5-15/ObjectRecognitionTwo.java
deleted file mode 100644
index 5413eaa..0000000
--- a/Group-15/Lab5-15/ObjectRecognitionTwo.java
+++ /dev/null
@@ -1,399 +0,0 @@
-import lejos.nxt.ColorSensor;
-import lejos.nxt.Sound;
-import lejos.nxt.comm.RConsole;
-import lejos.util.Timer;
-import lejos.util.TimerListener;
-
-/**
- * 
- * @project Lab 4 Localization 
- * @names Riley van Ryswyk & Aditya Saha
- * @studentID 260447357 & 260453165
- * @group 15
- * @course ECSE 211 
- * @date 06/22/2013
- * 
- * Object Recognition Two (for part 2)
- * 
- *  The class is used to differentiate between the styrofoam block and wood block
- * 
- */
-
-public class ObjectRecognitionTwo implements TimerListener {
-
-	/*
-	 * Objects to interact with other classes
-	 */
-	private ColorSensor ls;
-	private UltrasonicPoller usPoller;
-	private TwoWheeledRobot robot;
-	private Navigation nav;
-	private Odometer odo;
-	private Timer oroTimer;
-	private boolean objectDetected;
-
-	//light sensor calibration value -> ambient light returned
-	private int lsCalibration = -1;
-	// true if the type has been determined
-	private boolean typeDetected = false;
-	// true if the robot is detecting in the timeOut method
-	private boolean detecting = false;
-	// true if the robot has the styrofoam block 
-	private boolean haveStyrofoam = false;
-	//true if lineing up the robot in inspect2()
-	private boolean inspecting = false;
-	
-	/**
-	 * object recongnition two constructor
-	 * @param ls
-	 * @param usPoller
-	 * @param robot
-	 * @param display
-	 * @param odo
-	 */
-	public ObjectRecognitionTwo(ColorSensor ls, UltrasonicPoller usPoller, TwoWheeledRobot robot, Odometer odo) {
-		this.ls = ls;
-		this.usPoller = usPoller;
-		this.robot = robot;
-		this.objectDetected = false;
-		this.odo = odo;
-		this.nav = new Navigation(odo);
-		
-		//set timer to 40 ms
-		this.oroTimer = new Timer(40, this);
-		//set volume level
-		Sound.setVolume(60);
-	}
-	
-	/**
-	 * returns the current light sensor value referenced to the calibration point
-	 * @return
-	 */
-	public int getLSValue() {
-		return ls.getRawLightValue() - lsCalibration;
-	}
-	
-	
-	/**
-	 * TimerListner loop
-	 * 
-	 * This method will cause the robot to travel forward if there is an object within 40cm and it will use the light sensor to reach an appropriate distance to check if the block is wood or styrofoam
-	 */
-	public void timedOut() {
-		
-		/*
-		 * make sure the floodlight is set to red
-		 */
-		if(ls.getFloodlight() != 0) {
-			ls.setFloodlight(0);
-			
-			//In cases when the floodlight fails to change right away
-			while(ls.getRawLightValue() == -1) {
-				try { Thread.sleep(50); } catch (InterruptedException e) {}
-			}
-		}
-		
-		// poll the us sensor for the new reading
-		int newUSValue = usPoller.filterUS();
-		
-		/*
-		 * the object has been detected (us reading of less than 40cm)
-		 */
-		if(objectDetected) {
-			/*
-			 * if us > 40, we probably are not lined up correctly
-			 * 
-			 * all variables will be reset and the timer is stopped
-			 * this will return to the method that called this one (inspect2(), which will then line up the robot) 
-			 */
-			if(newUSValue > 40) {
-				objectDetected = false;
-				typeDetected = false;
-				robot.setSpeeds(0, 0);
-				detecting = false;
-				stop();
-			/*
-			 * if the type has not yet been detected, move forward so that a good light sensor reading can be taken
-			 */
-			} else if(!typeDetected) {
-				
-				// retrieve the current light value
-				int lsValue = ls.getRawLightValue();
-				
-				/*
-				 * if the difference is less than 5 the robot is far from the object, approach faster
-				 */
-				if(lsValue-lsCalibration < 5) {
-					robot.setSpeeds(2.5,0);
-				} 
-				/*
-				 * the robot is close, slow down
-				 */
-				else if(lsValue-lsCalibration < 40) {
-					robot.setSpeeds(1.5, 0);
-				} 
-				/*
-				 * the robot is close enough to take accurate light reading and make a decision
-				 */
-				else {
-					
-					//stop moving
-					robot.setSpeeds(0, 0);
-					//stop the timer
-					oroTimer.stop();
-					
-					//store the reading with the red flood light on
-					int redValue = lsValue;
-					
-					// set the floodlight to blue
-					ls.setFloodlight(2);
-					
-					//wait till the floodlight is actually changed to blue
-					while(ls.getRawLightValue() == -1) {
-						try { Thread.sleep(50); } catch (InterruptedException e) {}
-					}
-					
-					//store the reading with the blue flood light on
-					int blueValue = ls.getRawLightValue();
-					
-					// if the difference between the red and blue is greater than 25, it is a wood block
-					// actually difference is ~100
-					if (redValue - blueValue > 25) {
-					
-						Sound.beep();
-						Sound.buzz();
-						
-						//backup 10cm
-						nav.backup(10);
-					} 
-					/*
-					 * otherwise it is a styrofoam block
-					 * difference between red and blue for styrofoam is <5
-					 */
-					else {
-						
-						Sound.beep();
-						haveStyrofoam = true;
-						//capture the styrofoam block
-						capture();
-						
-					}
-					
-					// reset the floodlight to red
-					ls.setFloodlight(0);
-					//ensure it is actually red before continuing
-					while(ls.getRawLightValue() == -1) {
-						try { Thread.sleep(50); } catch (InterruptedException e) {}
-					}
-					
-					//reset variables to exit inspecting loops
-					typeDetected = false;
-					inspecting = false;
-					detecting = false;
-					
-				}
-			}
-		}
-		/*
-		 * the US is reading a value < 40 and block has not been detected -> block detectee
-		 */
-		else if(newUSValue < 40) {
-			objectDetected = true;
-		}
-			
-	}
-	
-	/*
-	 * starts the timer for the timeOut loop
-	 */
-	public void start() {
-		//we are detecting
-		detecting = true;
-		
-		//starts the ultrasonic poller timer
-		usPoller.start();
-		
-		//set floodlight to red
-		ls.setFloodlight(0);
-		
-		//calibrates the light sensor (retrieves ambient light value)
-		while (lsCalibration < 0) {
-			lsCalibration = ls.getRawLightValue();
-			try { Thread.sleep(50); } catch (InterruptedException e) {}
-		}
-		
-		//start the timer
-		oroTimer.start();
-
-	}
-	
-	/*
-	 * stop the timer
-	 */
-	public void stop() {
-		oroTimer.stop();
-	}
-	
-	/**
-	 * Inspect Method drives the robot to about 15cm from the object, 
-	 * calls inspect2() to inspect the object, 
-	 * and then if the object is not the styrofoam block
-	 * returns the robot to its original position
-	 * 
-	 * @param yStart
-	 * @param yEnd
-	 * @param distanceToBlock
-	 */
-	public void inspect(int yStart, int yEnd, int distanceToBlock) {
-		
-		//store starting coordinates
-		double xOriginal = odo.getX();
-		double yOriginal = odo.getY();
-		
-		//backup to the middle of the object
-		nav.backup(Math.abs(yEnd - yStart) / 2 );
-		
-		//turn to face the object
-		nav.turnTo(180);
-		usPoller.rotateUS(170);
-		
-		//scan the object for the distance
-		int distanceToObject = usPoller.scan();
-		
-		//take the minimum of the distance to the object as reported by the findStyrofoam loop or the one just measured
-		if(distanceToObject > distanceToBlock + 5) {
-			distanceToObject = distanceToBlock;
-		}
-		
-		//travel to the object - 15cm
-		nav.travelTo(odo.getX() - distanceToObject + 15, odo.getY());
-		
-		//line up the robot to the object and inspect to see if it is styrofoam or wood
-		inspect2(180);
-		
-		// if the object was a wood block return to the original coordinates to continue looking for blocks
-		if(!getHaveStyrofoam()) {
-			nav.travelTo(xOriginal, yOriginal);
-			nav.turnTo(90);
-			usPoller.rotateUS(180);
-		}
-		
-	}
-	
-	/**
-	 * inspect2 will line up the robot to the block and
-	 * then start the timeOut loop to determine what the object is
-	 * @param heading
-	 */
-	public void inspect2(int heading) {
-		inspecting  = true;
-		
-		/*
-		 * main loop
-		 */
-		while(inspecting) {
-			
-			//measure the distance to the object at 3 offsets left, center, right
-			int angleAValue;
-			int angleBValue;
-			int angleCValue;
-			
-			nav.turnTo(heading + 40);
-			usPoller.rotateUS(heading + 10);
-			angleAValue = usPoller.scan();
-			
-			nav.turnTo(heading);
-			usPoller.rotateUS(heading);
-			angleBValue = usPoller.scan();
-			
-			nav.turnTo(heading - 40);
-			usPoller.rotateUS(heading);
-			angleCValue = usPoller.scan();
-			
-			/*
-			 * if oriented along the y axis, 
-			 * adjust the robots x position
-			 */
-			if (Math.abs(Math.sin(Math.toRadians(heading))) > 0.95) {
-				//initialize current x
-				int x = (int) odo.getX();
-				//if the reading to the right was bigger than the left move to the left
-				if(angleCValue - angleAValue > 10 ) {
-					x -= 5;
-				} 
-				// if the reading on the left was bigger than the reading on the right move to the right
-				else if (angleCValue - angleAValue < -10 ) {
-					x+= 5;
-				}
-				//travel to adjusted position				
-				nav.travelTo(x, odo.getY());
-			} 
-			/*
-			 * if oriented along the x axis
-			 * adjust the robots y position
-			 */
-			else {
-				//initialize current y position
-				int y = (int) odo.getY();
-				
-				// if the reading to the right is was bigger than the reading to the left, go to the left
-				if(angleCValue - angleAValue > 10 ) {
-					y -= 5;
-				} 
-				// if the reading to the left was bigger than the reading to the right, go right
-				else if (angleCValue - angleAValue < -10 ) {
-					y+= 5;
-				}
-				
-				//travel to adjusted position			
-				nav.travelTo(odo.getX(), y);
-			}
-			
-			//correct the heading of the robot and ultrasonic
-			nav.turnTo(heading);
-			usPoller.rotateUS(heading);
-			
-			/*
-			 * if the us reading is less than 40, the robot is good to move on to the light sensor part of object recognition
-			 */
-			if(usPoller.scan() < 40) {
-				usPoller.rotateUS(heading-10);
-				//start the timeOut timer -> do light sensor recognition
-				start();
-				
-				//while still detecting wait
-				while(detecting) {
-					try{
-						Thread.sleep(200);
-					} catch(Exception e) {
-						
-					}
-				}
-			}
-		}
-
-	}
-	
-	/**
-	 * returns true if the styrofoam block has been captured
-	 * @return
-	 */
-	public boolean getHaveStyrofoam() {
-		return haveStyrofoam;
-	}
-	
-	
-	/**
-	 * Attempt to capture the styrofoam block
-	 */
-	public void capture() {
-		//travel forward 5cm
-		nav.travelTo(odo.getX() - 5, odo.getY());
-		//turn around to scoop the block
-		nav.turnTo(330);
-		//travel to the end destination
-		nav.travelTo(odo.getX(), 165);
-		nav.travelTo(70, 190);
-	}
-	
-}
diff --git a/Group-15/Lab5-15/Odometer.java b/Group-15/Lab5-15/Odometer.java
deleted file mode 100644
index 4657f62..0000000
--- a/Group-15/Lab5-15/Odometer.java
+++ /dev/null
@@ -1,205 +0,0 @@
-import lejos.util.Timer;
-import lejos.util.TimerListener;
-/**
- * 
- * @project Lab 4 Localization 
- * @names Riley van Ryswyk & Aditya Saha
- * @studentID 260447357 & 260453165
- * @group 15
- * @course ECSE 211 
- * @date 06/22/2013
- * 
- * Odometer (provided)
- * changed the way theta is defined (now 0 along +x axis and increases CCW)
- */
-public class Odometer implements TimerListener {
-	public static final int DEFAULT_PERIOD = 25;
-	private TwoWheeledRobot robot;
-	private Timer odometerTimer;
-	private Navigation nav;
-	// position data
-	private Object lock;
-	private double x, y, theta;
-	private double [] oldDH, dDH;
-	
-	/**
-	 * Odometer constructor
-	 * @param robot
-	 * @param period
-	 * @param start
-	 */
-	public Odometer(TwoWheeledRobot robot, int period, boolean start) {
-		// initialise variables
-		this.robot = robot;
-		this.nav = new Navigation(this);
-		odometerTimer = new Timer(period, this);
-		x = 0.0;
-		y = 0.0;
-		theta = 90.0;
-		oldDH = new double [2];
-		dDH = new double [2];
-		lock = new Object();
-		
-		// start the odometer immediately, if necessary
-		if (start)
-			odometerTimer.start();
-	}
-	/**
-	 * Odometer constructor
-	 * @param robot
-	 */
-	public Odometer(TwoWheeledRobot robot) {
-		this(robot, DEFAULT_PERIOD, false);
-	}
-	/**
-	 * Odometer constructor
-	 * @param robot
-	 * @param start
-	 */
-	public Odometer(TwoWheeledRobot robot, boolean start) {
-		this(robot, DEFAULT_PERIOD, start);
-	}
-	/**
-	 * Odometer Constructor
-	 * @param robot
-	 * @param period
-	 */
-	public Odometer(TwoWheeledRobot robot, int period) {
-		this(robot, period, false);
-	}
-	
-	/**
-	 * Update loop
-	 * 
-	 * Finds change in motors tacho count and then updates x,y,theta correspondingly 
-	 */
-	public void timedOut() {
-		robot.getDisplacementAndHeading(dDH);
-		//change in displacement and heading
-		dDH[0] -= oldDH[0];
-		dDH[1] -= oldDH[1];
-		
-		// update the position in a critical region
-		synchronized (lock) {
-			theta -= dDH[1];
-			theta = fixDegAngle(theta);
-			
-			x += dDH[0] * Math.cos(Math.toRadians(theta));
-			y += dDH[0] * Math.sin(Math.toRadians(theta));
-		}
-		
-		//update old displacement and heading
-		oldDH[0] += dDH[0];
-		oldDH[1] += dDH[1];
-		
-	}
-	
-	/**
-	 * returns position
-	 * @param pos
-	 */
-	public void getPosition(double [] pos) {
-		synchronized (lock) {
-			pos[0] = x;
-			pos[1] = y;
-			pos[2] = theta;
-		}
-	}
-	
-	/**
-	 * returns theta
-	 * @return
-	 */
-	public double getTheta() {
-		double result;
-
-		synchronized (lock) {
-			result = theta;
-		}
-
-		return result;
-	}
-	
-	/**
-	 * returns y
-	 * @return
-	 */
-	public double getY() {
-		double result;
-
-		synchronized (lock) {
-			result = y;
-		}
-
-		return result;
-	}
-	
-	/**
-	 * returns x
-	 * @return
-	 */
-	public double getX() {
-		double result;
-
-		synchronized (lock) {
-			result = x;
-		}
-
-		return result;
-	}
-	
-	/**
-	 * returns TwoWheeledRobot
-	 * @return
-	 */
-	public TwoWheeledRobot getTwoWheeledRobot() {
-		return robot;
-	}
-	
-	/**
-	 * returns navigation object
-	 * @return
-	 */
-	public Navigation getNavigation() {
-		return this.nav;
-	}
-	
-	/**
-	 * set the current position
-	 * @param pos
-	 * @param update
-	 */
-	public void setPosition(double [] pos, boolean [] update) {
-		synchronized (lock) {
-			if (update[0]) x = pos[0];
-			if (update[1]) y = pos[1];
-			if (update[2]) theta = pos[2];
-		}
-	}
-	
-	/**
-	 * Ensures angle is always in [0,360)
-	 * @param angle
-	 * @return
-	 */
-	public static double fixDegAngle(double angle) {		
-		if (angle < 0.0)
-			angle = 360.0 + (angle % 360.0);
-		
-		return angle % 360.0;
-	}
-	/**
-	 * returns the minimum angle
-	 * @param a
-	 * @param b
-	 * @return
-	 */
-	public static double minimumAngleFromTo(double a, double b) {
-		double d = fixDegAngle(b - a);
-		
-		if (d < 180.0)
-			return d;
-		else
-			return d - 360.0;
-	}
-}
diff --git a/Group-15/Lab5-15/TwoWheeledRobot.java b/Group-15/Lab5-15/TwoWheeledRobot.java
deleted file mode 100644
index 4303fbe..0000000
--- a/Group-15/Lab5-15/TwoWheeledRobot.java
+++ /dev/null
@@ -1,165 +0,0 @@
-import lejos.nxt.NXTRegulatedMotor;
-import lejos.nxt.comm.RConsole;
-/**
- * 
- * @project Lab 4 Localization 
- * @names Riley van Ryswyk & Aditya Saha
- * @studentID 260447357 & 260453165
- * @group 15
- * @course ECSE 211 
- * @date 06/10/2013
- * 
- * TwoWheeledRobot (provided)
- * added stop method
- * limited motor acceleration
- * and changed robot parameters
- */
-public class TwoWheeledRobot {
-	public static final double DEFAULT_LEFT_RADIUS = 2.11;
-	public static final double DEFAULT_RIGHT_RADIUS = 2.11;
-	public static final double DEFAULT_WIDTH = 14.92;
-	private NXTRegulatedMotor leftMotor, rightMotor;
-	private double leftRadius, rightRadius, width;
-	private double forwardSpeed, rotationSpeed;
-	
-	/**
-	 * Constructor
-	 * @param leftMotor
-	 * @param rightMotor
-	 * @param width
-	 * @param leftRadius
-	 * @param rightRadius
-	 */
-	public TwoWheeledRobot(NXTRegulatedMotor leftMotor,
-						   NXTRegulatedMotor rightMotor,
-						   double width,
-						   double leftRadius,
-						   double rightRadius) {
-		this.leftMotor = leftMotor;
-		this.rightMotor = rightMotor;
-		this.leftRadius = leftRadius;
-		this.rightRadius = rightRadius;
-		this.width = width;
-		leftMotor.setAcceleration(1000);
-		rightMotor.setAcceleration(1000);
-		leftMotor.resetTachoCount();
-		rightMotor.resetTachoCount();
-	}
-	/**
-	 * Constructor
-	 * @param leftMotor
-	 * @param rightMotor
-	 */
-	public TwoWheeledRobot(NXTRegulatedMotor leftMotor, NXTRegulatedMotor rightMotor) {
-		this(leftMotor, rightMotor, DEFAULT_WIDTH, DEFAULT_LEFT_RADIUS, DEFAULT_RIGHT_RADIUS);
-	}
-	/**
-	 * Constructor
-	 * @param leftMotor
-	 * @param rightMotor
-	 * @param width
-	 */
-	public TwoWheeledRobot(NXTRegulatedMotor leftMotor, NXTRegulatedMotor rightMotor, double width) {
-		this(leftMotor, rightMotor, width, DEFAULT_LEFT_RADIUS, DEFAULT_RIGHT_RADIUS);
-	}
-	
-	/**
-	 * Returns displacement based on TachoMeter count
-	 * @return
-	 */
-	public double getDisplacement() {
-		return (leftMotor.getTachoCount() * leftRadius +
-				rightMotor.getTachoCount() * rightRadius) *
-				Math.PI / 360.0;
-	}
-	/**
-	 *  returns heading based on tachoMeter count
-	 * @return
-	 */
-	public double getHeading() {
-		return (leftMotor.getTachoCount() * leftRadius -
-				rightMotor.getTachoCount() * rightRadius) / width;
-	}
-	/**
-	 * returns displacement and heading based on tacho counts -> passed through the data array pointer
-	 * @param data
-	 */
-	public void getDisplacementAndHeading(double [] data) {
-		int leftTacho, rightTacho;
-		leftTacho = leftMotor.getTachoCount();
-		rightTacho = rightMotor.getTachoCount();
-		
-		data[0] = (leftTacho * leftRadius + rightTacho * rightRadius) *	Math.PI / 360.0;
-		data[1] = (leftTacho * leftRadius - rightTacho * rightRadius) / width;
-	}
-	
-	/**
-	 * Sets forward robot speed (cm/s)
-	 * @param speed
-	 */
-	public void setForwardSpeed(double speed) {
-		forwardSpeed = speed;
-		setSpeeds(forwardSpeed, rotationSpeed);
-	}
-	
-	/**
-	 * sets rotational speed (deg/s)
-	 * @param speed
-	 */
-	public void setRotationSpeed(double speed) {
-		rotationSpeed = speed;
-		setSpeeds(forwardSpeed, rotationSpeed);
-	}
-	
-	/**
-	 * Sets both forward and rotational speed (cm/s, deg/s)
-	 * @param forwardSpeed
-	 * @param rotationalSpeed
-	 */
-	public void setSpeeds(double forwardSpeed, double rotationalSpeed) {
-		double leftSpeed, rightSpeed;
-
-		this.forwardSpeed = forwardSpeed;
-		this.rotationSpeed = rotationalSpeed; 
-
-		leftSpeed = (forwardSpeed + rotationalSpeed * width * Math.PI / 360.0) *
-				180.0 / (leftRadius * Math.PI);
-		rightSpeed = (forwardSpeed - rotationalSpeed * width * Math.PI / 360.0) *
-				180.0 / (rightRadius * Math.PI);
-
-		
-		// set motor directions
-		if (leftSpeed > 0.0)
-			leftMotor.forward();
-		else {
-			leftMotor.backward();
-			leftSpeed = -leftSpeed;
-		}
-		
-		if (rightSpeed > 0.0)
-			rightMotor.forward();
-		else {
-			rightMotor.backward();
-			rightSpeed = -rightSpeed;
-		}
-		
-		// set motor speeds
-		if (leftSpeed > 900.0)
-			leftMotor.setSpeed(900);
-		else
-			leftMotor.setSpeed((int)leftSpeed);
-		
-		if (rightSpeed > 900.0)
-			rightMotor.setSpeed(900);
-		else
-			rightMotor.setSpeed((int)rightSpeed);
-	}
-	
-	/**
-	 * Stops robot
-	 */
-	public void stop() {
-		rightMotor.stop(true);
-		leftMotor.stop();
-	}
-}
diff --git a/Group-15/Lab5-15/USLocalizer.java b/Group-15/Lab5-15/USLocalizer.java
deleted file mode 100644
index 0cb4b6e..0000000
--- a/Group-15/Lab5-15/USLocalizer.java
+++ /dev/null
@@ -1,354 +0,0 @@
-import java.util.ArrayList;
-import java.util.List;
-
-import lejos.nxt.Motor;
-import lejos.nxt.Sound;
-import lejos.nxt.UltrasonicSensor;
-import lejos.nxt.comm.RConsole;
-
-/**
- * 
- * @project Lab 4 Localization 
- * @names Riley van Ryswyk & Aditya Saha
- * @studentID 260447357 & 260453165
- * @group 15
- * @course ECSE 211 
- * @date 06/22/2013
- * 
- * Ultrasonic Localization
- * Accurate to within ~3degs
- */
-
-public class USLocalizer {
-	
-	//Types of localization
-	public enum LocalizationType { FALLING_EDGE, RISING_EDGE };
-	
-	//Speed in deg/sec of which to rotate during localization
-	public static double ROTATION_SPEED = 30;
-	
-	//period to check ultrasonic sensor in ms
-	public final int UPDATE_PERIOD = 30;
-	
-	//threshold distance in cm, to determine if we are at a critical angle
-	public final int THRESHOLD = 30;
-	
-	//Objects for interaction with other classes
-	private Odometer odo;
-	private TwoWheeledRobot robot;
-	private UltrasonicPoller usPoller;
-	private LocalizationType locType;
-	private Navigation nav;
-	
-	// Store list of previous ultrasonic sensor values for filtering
-	private List<Integer> usValues = new ArrayList<Integer>();
-	
-	// Store list of previous ultrasonic sensor values for filtering
-	private int usLastValue = 40;
-	
-	/**
-	 * Ultrasonic sensor class constructor
-	 * @param odo
-	 * @param us
-	 * @param locType
-	 */
-	public USLocalizer(Odometer odo, UltrasonicPoller usPoller, LocalizationType locType) {
-		this.odo = odo;
-		this.robot = odo.getTwoWheeledRobot();
-		this.usPoller = usPoller;
-		this.locType = locType;
-		this.nav = odo.getNavigation();
-		
-		// switch off the ultrasonic sensor
-		//us.off();
-	}
-	
-	/**
-	 * Carrys out Ultrasonic localization
-	 */
-	public void doLocalization() {
-		
-		//to feed to odometer
-		double [] pos = new double [3];
-		
-		// Critical angles (when wall is detected/not detected
-		double angleA = -1, angleB = -1;
-		
-		//amount to adjust the heading by
-		double deltaTheta = 0;
-		
-		//to ensure we run only once an UPDATE_PERIOD
-		long correctionStart, correctionEnd;
-		
-		// to prevent errors when changing directions
-		int BDelay = 0;
-		
-		usPoller.start();
-		
-		//Fill the array of usValues with the current reading of the ultrasonic sensor
-		try {
-			Thread.sleep(4*35);
-		} catch (InterruptedException e) {
-			// there is nothing to be done here because it is not
-			// expected that the odometry correction will be
-			// interrupted by another thread
-		}
-		
-		/*getFilteredData();
-		getFilteredData();
-		getFilteredData();
-		getFilteredData();*/
-		
-		/*
-		 * Falling edge detected (no wall -> wall)
-		 * 
-		 * 	rotate the robot until it sees no wall
-		 *  keep rotating until the robot sees a wall, then latch the angle
-		 *  switch direction and wait until it sees no wall
-		 *  keep rotating until the robot sees a wall, then latch the angle
-		 */
-		if (locType == LocalizationType.FALLING_EDGE) {
-			
-			//to keep track of whether we were facing a wall or not
-			boolean noWall = false;
-			
-			//Localization loop
-			locloop: 
-				while(true) {
-				
-				correctionStart = System.currentTimeMillis();
-				
-				//set the direction of rotation, once angleA is found it will be >0
-				if(angleA < 0) {
-					robot.setSpeeds(0, 40);
-				} else {
-					robot.setSpeeds(0, -40);
-					
-					//prevent detection of same wall/no wall barrier 
-					BDelay++;
-				}
-				
-				//retrieve the value of the filtered Ultrasonic data
-				int distance = usPoller.filterUS();
-				
-				//We were seeing a wall and the distance is greater than the threshold -> we are not seeing a wall
-				if(!noWall && distance > THRESHOLD) {
-					
-					//update noWall
-					noWall = true;
-				} 
-				// we are not seeing a wall, haven't detected angleA and distance less than threshold -> we have found angleA
-				else if(noWall && angleA < 0 && distance < THRESHOLD) {
-					
-					//set angleA
-					angleA = odo.getTheta();
-					
-					//reset noWall
-					noWall = false;					
-				} 
-				//if we are not seeing a wall, and haven't detected angleB, the distance is less than the threshold and the delay since detecting angleA is greater than 50 iterations -> we have found angleB
-				else if(noWall && angleB < 0 && distance < THRESHOLD && BDelay > 50) {
-					
-					//set angleB
-					angleB = odo.getTheta();
-					
-					//Stop robot
-					robot.setSpeeds(0, 0);
-					
-					//break the us localization loop
-					break locloop;
-				}
-				
-				// this ensure the odometry correction occurs only once every period
-				correctionEnd = System.currentTimeMillis();
-				
-				if (correctionEnd - correctionStart < UPDATE_PERIOD) {
-					try {
-						Thread.sleep(UPDATE_PERIOD - (correctionEnd - correctionStart));
-					} catch (InterruptedException e) {
-						// there is nothing to be done here because it is not
-						// expected that the odometry correction will be
-						// interrupted by another thread
-					}
-				}
-				
-			}
-			
-			//first part of deltaTheta, the negative average of <A and <B
-			deltaTheta = -(angleA + angleB) / 2;
-			
-			//Depending on what angle is bigger, offset deltaTheta to the correct amount
-			if(angleA > angleB) {
-				deltaTheta += 214;
-			} else {
-				deltaTheta += 34;
-			}
-		} 
-		
-		/*
-		 * Rising Edge Detection
-		 * 
-		 * The robot should turn until it sees the wall, then look for the
-		 * "rising edges:" the points where it no longer sees the wall.
-		 * This is very similar to the FALLING_EDGE routine, but the robot
-		 * will face toward the wall for most of it.
-		 */
-		
-		else {
-			
-			// true if we are facing a wall
-			boolean wall = false;
-			
-			//localization loop
-			locloop: 
-				while(true) {
-				
-				correctionStart = System.currentTimeMillis();
-				
-				//Set speed of robot depending on whether we have detected angleA 
-				if(angleA < 0) {
-					robot.setSpeeds(0, 40);
-				} else {
-					robot.setSpeeds(0, -40);
-					//prevent incorrect detection of angleB (ie right after angleA has been detected)
-					BDelay++;
-				}
-				
-				//get filtered Ultrasonic data
-				int distance = usPoller.filterUS();
-				
-				//if no wall and distance less than threshold -> we are seeing a wall
-				if(!wall && distance < THRESHOLD) {
-					wall = true;
-				} 
-				//if we were seeing a wall, angleA is not set and distance > threshold -> we have angleA
-				else if(wall && angleA < 0 && distance > THRESHOLD) {
-					
-					//set AngleA
-					angleA = odo.getTheta();
-					
-					//reset wall
-					wall = false;					
-					
-				} 
-				//if we were seeing a wall, angleB is not set, distance > threshold, and it has been more than 50 iterations since detecting angleA - > we have angleB
-				else if(wall && angleB < 0 && distance > THRESHOLD && BDelay > 50) {
-					
-					//set angleB
-					angleB = odo.getTheta();
-					
-					//stop robot
-					robot.setSpeeds(0, 0);
-					
-					//break the localization loop
-					break locloop;
-				}
-				
-				// this ensure the odometry correction occurs only once every period
-				correctionEnd = System.currentTimeMillis();
-				
-				if (correctionEnd - correctionStart < UPDATE_PERIOD) {
-					try {
-						Thread.sleep(UPDATE_PERIOD - (correctionEnd - correctionStart));
-					} catch (InterruptedException e) {
-						// there is nothing to be done here because it is not
-						// expected that the odometry correction will be
-						// interrupted by another thread
-					}
-				}
-				
-			}
-			
-			//first part of deltaTheta, the negative average of <A and <B
-			deltaTheta = -(angleA + angleB) / 2;
-			
-			//Depending on what angle is bigger, offset deltaTheta to the correct amount
-			if(angleB > angleA) {
-				deltaTheta += 228;
-			} else {
-				deltaTheta += 48;
-			}
-		}
-	
-		// initalize our position to x=-14, y=-14, theta += deltaTheta | we are roughly in the center of the square and deltaTheta was calculated by rising or falling edge detection
-		odo.setPosition(new double [] {0.0, 0.0, odo.getTheta() + deltaTheta}, new boolean [] {true, true, true});
-		
-	}
-	
-	/**
-	 * Pings Ultrasonic sensor, waits for return and applys median filtering to the Ultrasonic data
-	 * @return
-	 */
-	/*public int getFilteredData() {
-		int distance;
-		
-		// do a ping
-		us.ping();
-		
-		// wait for the ping to complete
-		try { Thread.sleep(20); } catch (InterruptedException e) {}
-		
-		// there will be a delay here
-		distance = us.getDistance();
-		
-		//add the current value to array of values
-		usValues.add(distance);	
-		
-		//make sure we have sufficient number of samples
-		if(usValues.size() >= 5) {
-									
-			int result;
-			
-			//array of sorted values
-			List<Integer> usValuesSorted = new ArrayList<Integer>(usValues);
-			
-			//length of values (should be 5)
-			int size = usValuesSorted.size();
-			
-			//sort the values: lowest to highest
-			for(int i=0; i<size; i++) {
-				for(int j=i+1; j<size;j++) {
-					if(usValuesSorted.get(i) > usValuesSorted.get(j)) {
-						int temp = usValuesSorted.get(i);
-						usValuesSorted.set(i, usValuesSorted.get(j));
-						usValuesSorted.set(j, temp);					
-					}
-				}
-			}
-			
-			// if odd pick the middle value, else average the two middle values
-			if(size % 2 == 1 ) {
-				result = usValuesSorted.get(size/2);
-			} else {
-				result = ( usValuesSorted.get(size/2-1) + usValuesSorted.get(size/2) ) / 2;
-			}
-			
-			//shift values left by 1 for next iteration
-			usValues.remove(0);
-
-			//return result
-			return result;
-		} 
-		//not enough data for filtering yet, so return the current value
-		else {
-			return distance;
-		}		
-				
-	}*/
-	
-	/**
-	 * Pings Ultrasonic sensor, waits for return and applys difference filtering to the Ultrasonic data
-	 * @return
-	 */
-	/*public void getFilteredData2(int[] data) {
-		
-		int usCurrentValue = getFilteredData();
-		
-		// Smooth and difference
-		data[0] = -usLastValue + usCurrentValue;
-		data[1] = usCurrentValue;
-		usLastValue = usCurrentValue;
-		
-	}*/
-
-}
diff --git a/Group-15/Lab5-15/UltrasonicPoller.java b/Group-15/Lab5-15/UltrasonicPoller.java
deleted file mode 100644
index 9181659..0000000
--- a/Group-15/Lab5-15/UltrasonicPoller.java
+++ /dev/null
@@ -1,235 +0,0 @@
-import java.util.ArrayList;
-import java.util.List;
-
-import lejos.nxt.NXTRegulatedMotor;
-import lejos.nxt.UltrasonicSensor;
-import lejos.nxt.comm.RConsole;
-import lejos.util.TimerListener;
-import lejos.util.Timer;
-
-/**
- * 
- * @project Lab 5 Object Recognition 
- * @names Riley van Ryswyk & Aditya Saha
- * @studentID 260447357 & 260453165
- * @group 15
- * @course ECSE 211 
- * @date 10/22/2013
- * 
- * Class for interaction with ultrasonic sensor
- * 
- */
-public class UltrasonicPoller implements TimerListener {
-
-	private UltrasonicSensor us;
-	
-	//period to Update Ultrasonic sensor in ms
-	private final int PERIOD = 35;
-	
-	// Store list of previous ultrasonic sensor values for filtering
-	private List<Integer> usValues = new ArrayList<Integer>();
-	
-	//Ultrasonic motor
-	private NXTRegulatedMotor usMotor;
-	
-	private Odometer odo;
-	
-	private Timer usTimer;
-	
-	// True if we are polling the ultrasonic sensor once a period
-	private boolean started;
-	
-	private Object lock;
-	
-	/**
-	 * UltrasonicPoller constructor
-	 * @param us
-	 * @param usMotor
-	 * @param odo
-	 */
-	public UltrasonicPoller(UltrasonicSensor us, NXTRegulatedMotor usMotor, Odometer odo) {
-		this.us = us;
-		this.usTimer = new Timer(PERIOD, this);
-		this.started = false;
-		this.lock = new Object();
-		this.usMotor = usMotor;
-		this.odo = odo;
-		
-		//limit usMotor acceleration
-		usMotor.setAcceleration(1000);
-		//stop continuous mode of Ultrasonic sensor
-		us.off();
-		
-	}
-	
-	/**
-	 * Called once a period when started
-	 * calls pingUS()
-	 */
-	public void timedOut() {
-		pingUS();		
-	}
-	
-	/**
-	 * Pings ultrasonic sensor and records the result
-	 */
-	public void pingUS() {
-		int distance;
-		
-		// do a ping
-		us.ping();
-		
-		// wait for the ping to complete
-		try { Thread.sleep(30); } catch (InterruptedException e) {}
-		
-		// there will be a delay here
-		distance = us.getDistance();
-
-		synchronized (lock) {
-		
-			if(usValues.size() > 4) { 
-				//remove the oldest one
-				usValues.remove(0);
-			}
-			
-			//add the current value to array of values
-			usValues.add(distance);
-		}
-	}
-	
-	/**
-	 * Starts the timer for the timeOut method
-	 */
-	public void start() {
-		if(!started) {
-			usTimer.start(); 
-			this.started = true;
-		}
-	}
-	
-	/**
-	 * stops the timer for the timeOut method
-	 */
-	public void stop() {
-		if(started) {
-			usTimer.stop();
-			this.started = false;
-		}
-	}
-	
-	/**
-	 * clears all stored values
-	 */
-	public void clear() {
-		usValues.clear();
-	}
-	
-	/**
-	 * takes 5 readings from the ultrasonic sensor
-	 * and returns the filtered distance
-	 * @return
-	 */
-	public int scan() {
-		stop();
-		
-		synchronized (lock) {
-			usValues.clear();			
-		}
-		
-		pingUS();
-		pingUS();
-		pingUS();
-		pingUS();
-		pingUS();
-		
-		return filterUS();
-		
-	}
-	
-	
-	/**
-	 * Rotates the ultrasonic sensor to face the desired heading 
-	 * it will limit the rotation to what is physically possible by the robot design
-	 * @param heading
-	 */
-	public void rotateUS(int heading) {
-		
-		int robotHeading = (int) odo.getTheta();
-		
-		//relative to the robots heading to ensure it doesn't go backwards or something like that
-		int rotateTo =  robotHeading - heading;
-		
-		//limits the angle of rotation
-		if(rotateTo < -120) {
-			rotateTo  = -120;
-		} else if(rotateTo > 40) {
-			rotateTo = 40;
-		}
-		
-		//rotate the ultrasonic sensor
-		usMotor.rotateTo(rotateTo);
-		
-	}
-	
-	/**
-	 * filters the data store in the usValues array using mode filtering
-	 * if the length of usVaules is less than 3, it will return the last reading
-	 * @return filtered distance
-	 */
-	public int filterUS() {
-		//make sure we have sufficient number of samples
-		if(usValues.size() >= 3) {
-			
-			//initialize vars
-			int result;
-			int size;
-			List<Integer> usValuesSorted;
-			
-			//make sure nothing changes while copying array reading usValues
-			synchronized (lock) {
-				//array of sorted values
-				usValuesSorted = new ArrayList<Integer>(usValues);
-			}
-			
-			//length of values (should be 5)
-			size = usValuesSorted.size();
-			
-			//sort the values: lowest to highest
-			for(int i=0; i<size; i++) {
-				for(int j=i+1; j<size;j++) {
-					if(usValuesSorted.get(i) > usValuesSorted.get(j)) {
-						int temp = usValuesSorted.get(i);
-						usValuesSorted.set(i, usValuesSorted.get(j));
-						usValuesSorted.set(j, temp);					
-					}
-				}
-			}
-			
-			
-			// if odd pick the middle value, else average the two middle values
-			if(size % 2 == 1 ) {
-				result = usValuesSorted.get(size/2);
-			} else {
-				result = ( usValuesSorted.get(size/2-1) + usValuesSorted.get(size/2) ) / 2;
-			}
-
-			//return result
-			return result;
-		} 
-		//not enough data for filtering yet, so return the current value
-		else {
-			int result; 
-			synchronized (lock) {
-				if (usValues.size() > 0) {
-					result = usValues.get(usValues.size()-1);
-				} else {
-					result = 256;
-				}
-			}
-			
-			return result;
-		}
-	}
-	
-	
-}
diff --git a/Group-15/Lab5-15/old.zip b/Group-15/Lab5-15/old.zip
deleted file mode 100644
index 92c68ea..0000000
Binary files a/Group-15/Lab5-15/old.zip and /dev/null differ

commit fb0fee606bcb5dabcf70f1ae49cddcf12ff3c17b
Author: RileyvanRyswyk <rileyvan@gmail.com>
Date:   Sat Nov 2 18:49:26 2013 -0400

    Group 15 Lab 2,4,5
    
    For Lab 5, old.zip contains the original code with the grid and mapping
    information.

diff --git a/Group-15/Lab2-15/Lab2.java b/Group-15/Lab2-15/Lab2.java
new file mode 100644
index 0000000..90ca385
--- /dev/null
+++ b/Group-15/Lab2-15/Lab2.java
@@ -0,0 +1,58 @@
+/*
+ * Lab2.java
+ */
+import lejos.nxt.*;
+
+public class Lab2 {
+	public static void main(String[] args) {
+		int buttonChoice;
+
+		// some objects that need to be instantiated
+		Odometer odometer = new Odometer();
+		
+		OdometryCorrection odometryCorrection = new OdometryCorrection(odometer);
+		OdometryDisplay odometryDisplay = new OdometryDisplay(odometer, odometryCorrection);
+
+		do {
+			// clear the display
+			LCD.clear();
+
+			// ask the user whether the motors should drive in a square or float
+			LCD.drawString("< Left | Right >", 0, 0);
+			LCD.drawString("       |        ", 0, 1);
+			LCD.drawString(" Float | Drive  ", 0, 2);
+			LCD.drawString("motors | in a   ", 0, 3);
+			LCD.drawString("       | square ", 0, 4);
+
+			buttonChoice = Button.waitForPress();
+		} while (buttonChoice != Button.ID_LEFT
+				&& buttonChoice != Button.ID_RIGHT);
+
+		if (buttonChoice == Button.ID_LEFT) {
+			for (NXTRegulatedMotor motor : new NXTRegulatedMotor[] { Motor.A, Motor.B, Motor.C }) {
+				motor.forward();
+				motor.flt();
+			}
+
+			// start only the odometer and the odometry display
+			odometer.start();
+			odometryDisplay.start();
+		} else {
+			// start the odometer, the odometry display and (possibly) the
+			// odometry correction
+			odometer.start();
+			odometryDisplay.start();
+			odometryCorrection.start();
+
+			// spawn a new Thread to avoid SquareDriver.drive() from blocking
+			(new Thread() {
+				public void run() {
+					SquareDriver.drive(Motor.A, Motor.B, 2.12, 2.12, 14.74);
+				}
+			}).start();
+		}
+		
+		while (Button.waitForPress() != Button.ID_ESCAPE);
+		System.exit(0);
+	}
+}
\ No newline at end of file
diff --git a/Group-15/Lab2-15/Odometer.java b/Group-15/Lab2-15/Odometer.java
new file mode 100644
index 0000000..4e68b6b
--- /dev/null
+++ b/Group-15/Lab2-15/Odometer.java
@@ -0,0 +1,163 @@
+import lejos.nxt.Motor;
+import lejos.nxt.NXTRegulatedMotor;
+
+/*
+ * Odometer.java
+ */
+
+public class Odometer extends Thread {
+	// robot position
+	private double x, y, theta;
+
+	// odometer update period, in ms
+	private static final long ODOMETER_PERIOD = 25;
+
+	// lock object for mutual exclusion
+	private Object lock;
+	
+	// robot wheel parameters
+	private final double radius = 2.12, base = 14.74;
+	
+	// robot wheel tacho parameters
+	private int lTacho, rTacho;
+	
+	// motor reassignment
+	private final NXTRegulatedMotor leftMotor = Motor.A, rightMotor = Motor.B;
+	
+	private final double degToDist = (radius * Math.PI) / 180;
+	
+	// default constructor
+	public Odometer() {
+		//initalize to x=0, y=0, theta = 90deg
+		x = 0.0;
+		y = 0.0;
+		theta = Math.PI/2;
+		lock = new Object();
+		//Reset motor tacho counts to zero
+		leftMotor.resetTachoCount();
+		rightMotor.resetTachoCount();		
+	}
+
+	// run method (required for Thread)
+	public void run() {
+		long updateStart, updateEnd;
+
+		while (true) {
+			updateStart = System.currentTimeMillis();
+
+			//save last tacho counts
+			int lastLTacho = lTacho, lastRTacho = rTacho;
+			
+			//update tacho counts
+			lTacho = leftMotor.getTachoCount();
+			rTacho = rightMotor.getTachoCount();
+			
+			// calc distance traveled for each wheel since last update
+			double dL = (lTacho - lastLTacho) * degToDist;
+			double dR = (rTacho - lastRTacho) * degToDist;
+			
+			//cal dTheta and displacement of the center of the robot
+			double dTheta = (dL-dR) / base;
+			double displacement = (dR + dL) / 2.0;
+			
+			
+			synchronized (lock) {
+				//update theta
+				theta += dTheta;
+				//if going past 2pi offset theta to angle close to zero
+				if(theta > 6.27) {
+					theta -= 2*Math.PI;
+				}
+				//update x and y
+				x += displacement * Math.cos(theta);
+				y += displacement * Math.sin(theta);
+			}
+
+			// this ensures that the odometer only runs once every period
+			updateEnd = System.currentTimeMillis();
+			if (updateEnd - updateStart < ODOMETER_PERIOD) {
+				try {
+					Thread.sleep(ODOMETER_PERIOD - (updateEnd - updateStart));
+				} catch (InterruptedException e) {
+					// there is nothing to be done here because it is not
+					// expected that the odometer will be interrupted by
+					// another thread
+				}
+			}
+		}
+	}
+
+	// accessors
+	public void getPosition(double[] position, boolean[] update) {
+		// ensure that the values don't change while the odometer is running
+		synchronized (lock) {
+			if (update[0])
+				position[0] = x;
+			if (update[1])
+				position[1] = y;
+			if (update[2])
+				position[2] = theta;
+		}
+	}
+
+	public double getX() {
+		double result;
+
+		synchronized (lock) {
+			result = x;
+		}
+
+		return result;
+	}
+
+	public double getY() {
+		double result;
+
+		synchronized (lock) {
+			result = y;
+		}
+
+		return result;
+	}
+
+	public double getTheta() {
+		double result;
+
+		synchronized (lock) {
+			result = theta;
+		}
+
+		return result;
+	}
+
+	// mutators
+	public void setPosition(double[] position, boolean[] update) {
+		// ensure that the values don't change while the odometer is running
+		synchronized (lock) {
+			if (update[0])
+				x = position[0];
+			if (update[1])
+				y = position[1];
+			if (update[2])
+				theta = position[2];
+		}
+	}
+
+	public void setX(double x) {
+		synchronized (lock) {
+			this.x = x;
+		}
+	}
+
+	public void setY(double y) {
+		synchronized (lock) {
+			this.y = y;
+		}
+	}
+
+	public void setTheta(double theta) {
+		synchronized (lock) {
+			this.theta = theta;
+		}
+	}
+}
\ No newline at end of file
diff --git a/Group-15/Lab2-15/OdometryCorrection.java b/Group-15/Lab2-15/OdometryCorrection.java
new file mode 100644
index 0000000..ca3997d
--- /dev/null
+++ b/Group-15/Lab2-15/OdometryCorrection.java
@@ -0,0 +1,212 @@
+import java.util.ArrayList;
+import java.util.List;
+import lejos.nxt.ColorSensor;
+import lejos.nxt.SensorPort;
+import lejos.nxt.Sound;
+
+/* 
+ * OdometryCorrection.java
+ * 
+ * Detects black grid lines on wooden floor, then corrects the position of the odometer
+ * based on the position reported when the line was detected
+ * 
+ */
+
+public class OdometryCorrection extends Thread {
+	private static final long CORRECTION_PERIOD = 10;
+	private Odometer odometer;
+	private static final SensorPort lsPort = SensorPort.S1;
+	private ColorSensor lightSensor = new ColorSensor(lsPort);
+	private List<Double> lsValues = new ArrayList<Double>();
+	private int runFilter = -3;
+	private boolean onLine = false;
+	
+	// distance to next most positive x line, distance to next most positive y line, tile size, light sensor offset
+	private double tileSize = 30.48, r = 12.8;
+	private double xOffset = -tileSize/2, yOffset = tileSize/2;
+	
+	
+	// constructor
+	public OdometryCorrection(Odometer odometer) {
+		this.odometer = odometer;
+		//reduce volume
+		Sound.setVolume(35);
+		//set flood light to Red, red gives most accurate results for us
+		lightSensor.setFloodlight(0);
+		
+	}
+
+	// run method (required for Thread)
+	public void run() {
+		long correctionStart, correctionEnd;
+
+		while (true) {
+			correctionStart = System.currentTimeMillis();
+			
+			//update light sensor return value
+			try { 
+				lsValues.set(3, (double) lightSensor.getRawLightValue() / 2.0);			
+			} catch(IndexOutOfBoundsException e) {
+				lsValues.add((double) lightSensor.getRawLightValue() / 2.0);	
+			}
+			
+			
+			if(runFilter == 0) {
+				filterLightSensor();
+				runFilter = -1;				
+			} else {
+				runFilter++;
+			}
+			
+
+			// this ensure the odometry correction occurs only once every period
+			correctionEnd = System.currentTimeMillis();
+			
+			if (correctionEnd - correctionStart < CORRECTION_PERIOD) {
+				try {
+					Thread.sleep(CORRECTION_PERIOD
+							- (correctionEnd - correctionStart));
+				} catch (InterruptedException e) {
+					// there is nothing to be done here because it is not
+					// expected that the odometry correction will be
+					// interrupted by another thread
+				}
+			}
+		}
+	}
+	
+	public void filterLightSensor() {
+		
+		double result;
+		
+		result = -lsValues.get(0) - lsValues.get(1) + lsValues.get(2) + lsValues.get(3);
+		
+		lsValues.remove(0);
+				
+		if(!onLine && result < -45) {
+			//go to line detection logic
+			lineDetected();
+			
+			// We are on the line
+			onLine = true;
+			
+			//alert us with a beep that a line was detected
+			Sound.beep();
+			
+		} else if(onLine && result > 45) {
+			onLine = false;
+		}		
+	}
+	
+	/**
+	 * retrieves last light sensor reading
+	 * @return lastLSValue
+	 */
+	public String lightSensorValue() {
+		return Double.toString(lsValues.get(0));
+	}
+	
+	public void lineDetected() {
+		
+		//for getting the current x, y, theta
+		double[] pos = new double[3];
+		boolean[] update = {true, true, true};
+		
+		odometer.getPosition(pos, update);
+		
+		double x = pos[0];
+		double y= pos[1];
+		double theta = pos[2];
+		
+		/**
+		 * sets orientation
+		 * ~= 1 if going in Y direction
+		 * ~= 0 if going in X direction
+		 */
+		double orientation = Math.abs(Math.sin(theta));	
+		
+		/**
+		 * Update the Y position as we are going in the Y direction
+		 */
+		if(orientation > 0.99) {
+			
+			/**
+			 * getClosestY returns the closest line plus the offset for the light Sensor	
+			 */
+			double line = getClosestY(y, theta);
+			
+			//if we are within 10cm of the line, update our position
+			if(Math.abs(line - y) < 10) {
+				
+				odometer.setY(line);
+			}
+			
+		}
+		/**
+		 * Update the X position, going in X direction
+		 */
+		else if(Math.abs(Math.cos(theta)) > 0.99) {
+			
+				
+			/**
+			 * We have already detected a x line, so get the closest line
+			 * getClosestX returns the closest line plus the offset for the light Sensor
+			 */
+			double line = getClosestX(x, theta);
+			
+			//if we are within 10cm of the line, update our position
+			if(Math.abs(line - x) < 10) {
+				
+				odometer.setX(line);
+				
+			}
+			
+		}
+		
+		/**
+		 * Update theta as we are turning
+		 */
+		else {
+			
+			/*// for the second last corner, if we have enough seperation between the y straight and y angled line
+			if(x<-45 && y<15 && y>(yOffset-r+2) && x > (xOffset-3*tileSize+r)) {
+				
+				//the yLine detected during turning
+				double yPrime =  (Math.round((y+r-yOffset)/tileSize)*tileSize + yOffset);
+				
+				// new Theta
+				double newTheta = 3*Math.PI/2 + Math.acos((yPrime-y)/r);
+				
+				// if Theta is a real number, udpate
+				if(newTheta != Double.NaN) { 
+					odometer.setTheta(newTheta);
+					
+				}
+			}*/
+		}
+	}
+	
+	/**
+	 * Returns the closest y line plus the offset for the light sensor
+	 * @param y
+	 * @param theta
+	 * @return
+	 */
+	public double getClosestY(double y, double theta) {
+		//adjust light sensor offset for direction of robot
+		double R = (Math.sin(theta) < 0) ? -1*r : r;
+		return (Math.round((y-R-yOffset)/tileSize)*tileSize + yOffset + R);
+	}
+	
+	/**
+	 * Returns the closest x line plus the offset for the light sensor
+	 * @param x
+	 * @param theta
+	 * @return
+	 */
+	public double getClosestX(double x, double theta) {
+		//adjust light sensor offset for direction of robot
+		double R = (Math.cos(theta) < 0) ? -1*r : r;
+		return (Math.round((x-R-xOffset)/tileSize)*tileSize + xOffset + R);
+	}
+}
\ No newline at end of file
diff --git a/Group-15/Lab2-15/OdometryDisplay.java b/Group-15/Lab2-15/OdometryDisplay.java
new file mode 100644
index 0000000..93b8ff4
--- /dev/null
+++ b/Group-15/Lab2-15/OdometryDisplay.java
@@ -0,0 +1,101 @@
+/*
+ * OdometryDisplay.java
+ */
+import lejos.nxt.LCD;
+
+public class OdometryDisplay extends Thread {
+	private static final long DISPLAY_PERIOD = 250;
+	private Odometer odometer;
+	private OdometryCorrection light;
+
+	// constructor
+	public OdometryDisplay(Odometer odometer, OdometryCorrection light) {
+		this.odometer = odometer;
+		this.light = light;
+	}
+
+	// run method (required for Thread)
+	public void run() {
+		long displayStart, displayEnd;
+		double[] position = new double[3];
+
+		// clear the display once
+		LCD.clearDisplay();
+
+		while (true) {
+			displayStart = System.currentTimeMillis();
+
+			// clear the lines for displaying odometry information
+			LCD.drawString("X:              ", 0, 0);
+			LCD.drawString("Y:              ", 0, 1);
+			LCD.drawString("T:              ", 0, 2);
+			LCD.drawString("S:              ", 0, 3);
+			
+
+			// get the odometry information
+			odometer.getPosition(position, new boolean[] { true, true, true });
+
+			// display odometry information
+			for (int i = 0; i < 3; i++) {
+				LCD.drawString(formattedDoubleToString(position[i], 2), 3, i);
+			}
+			
+			// Show light sensor value
+			LCD.drawString(light.lightSensorValue(), 3, 3);
+
+			// throttle the OdometryDisplay
+			displayEnd = System.currentTimeMillis();
+			if (displayEnd - displayStart < DISPLAY_PERIOD) {
+				try {
+					Thread.sleep(DISPLAY_PERIOD - (displayEnd - displayStart));
+				} catch (InterruptedException e) {
+					// there is nothing to be done here because it is not
+					// expected that OdometryDisplay will be interrupted
+					// by another thread
+				}
+			}
+		}
+	}
+	
+	private static String formattedDoubleToString(double x, int places) {
+		String result = "";
+		String stack = "";
+		long t;
+		
+		// put in a minus sign as needed
+		if (x < 0.0)
+			result += "-";
+		
+		// put in a leading 0
+		if (-1.0 < x && x < 1.0)
+			result += "0";
+		else {
+			t = (long)x;
+			if (t < 0)
+				t = -t;
+			
+			while (t > 0) {
+				stack = Long.toString(t % 10) + stack;
+				t /= 10;
+			}
+			
+			result += stack;
+		}
+		
+		// put the decimal, if needed
+		if (places > 0) {
+			result += ".";
+		
+			// put the appropriate number of decimals
+			for (int i = 0; i < places; i++) {
+				x = Math.abs(x);
+				x = x - Math.floor(x);
+				x *= 10.0;
+				result += Long.toString((long)x);
+			}
+		}
+		
+		return result;
+	}
+
+}
diff --git a/Group-15/Lab2-15/SquareDriver.java b/Group-15/Lab2-15/SquareDriver.java
new file mode 100644
index 0000000..18dd303
--- /dev/null
+++ b/Group-15/Lab2-15/SquareDriver.java
@@ -0,0 +1,66 @@
+/*
+ * SquareDriver.java
+ */
+import lejos.nxt.*;
+
+public class SquareDriver {
+	private static final int FORWARD_SPEED = 300;
+	private static final int ROTATE_SPEED = 150;
+
+	public static void drive(NXTRegulatedMotor leftMotor, NXTRegulatedMotor rightMotor,
+			double leftRadius, double rightRadius, double width) {
+		// reset the motors
+		for (NXTRegulatedMotor motor : new NXTRegulatedMotor[] { leftMotor, rightMotor }) {
+			motor.stop();
+			motor.setAcceleration(2000);
+		}
+
+		// wait 5 seconds
+		try {
+			Thread.sleep(2000);
+		} catch (InterruptedException e) {
+			// there is nothing to be done here because it is not expected that
+			// the odometer will be interrupted by another thread
+		}
+
+		for (int i = 0; i < 4; i++) {
+			// drive forward two tiles
+			leftMotor.setSpeed(FORWARD_SPEED);
+			rightMotor.setSpeed(FORWARD_SPEED);
+			
+			(new Thread() {
+				public void run() {
+					try {
+						Thread.sleep(1000);
+					} catch (InterruptedException e) {
+						
+					}
+					Motor.A.stop();
+				}
+			}).start();
+			
+			leftMotor.rotate(convertDistance(leftRadius, 60), true);
+			rightMotor.rotate(convertDistance(rightRadius, 60), false);
+			
+			
+
+			// turn 90 degrees clockwise
+			leftMotor.setSpeed(ROTATE_SPEED);
+			rightMotor.setSpeed(ROTATE_SPEED);
+
+			leftMotor.rotate(convertAngle(leftRadius, width, 90.0), true);
+			rightMotor.rotate(-convertAngle(rightRadius, width, 90.0), false);
+			
+		
+		}
+	}
+
+	private static int convertDistance(double radius, double distance) {
+		return (int) ((180.0 * distance) / (Math.PI * radius));
+	}
+
+	private static int convertAngle(double radius, double width, double angle) {
+		return convertDistance(radius, Math.PI * width * angle / 360.0);
+	}
+	
+}
\ No newline at end of file
diff --git a/Group-15/Lab4-15/LCDInfo.java b/Group-15/Lab4-15/LCDInfo.java
new file mode 100644
index 0000000..a9da62f
--- /dev/null
+++ b/Group-15/Lab4-15/LCDInfo.java
@@ -0,0 +1,53 @@
+import lejos.nxt.LCD;
+import lejos.util.Timer;
+import lejos.util.TimerListener;
+
+/**
+ * 
+ * @project Lab 4 Localization 
+ * @names Riley van Ryswyk & Aditya Saha
+ * @studentID 260447357 & 260453165
+ * @group 15
+ * @course ECSE 211 
+ * @date 06/10/2013
+ * 
+ * LCD display (provided)
+ */
+
+public class LCDInfo implements TimerListener{
+	public static final int LCD_REFRESH = 100;
+	private Odometer odo;
+	private Timer lcdTimer;
+	
+	// arrays for displaying data
+	private double [] pos;
+	
+	/**
+	 * LCDInfo constructor
+	 * @param odo
+	 */
+	public LCDInfo(Odometer odo) {
+		this.odo = odo;
+		this.lcdTimer = new Timer(LCD_REFRESH, this);
+		
+		// initialise the arrays for displaying data
+		pos = new double [3];
+		
+		// start the timer
+		lcdTimer.start();
+	}
+	
+	/**
+	 * main update loop
+	 */
+	public void timedOut() { 
+		odo.getPosition(pos);
+		LCD.clear();
+		LCD.drawString("X: ", 0, 0);
+		LCD.drawString("Y: ", 0, 1);
+		LCD.drawString("H: ", 0, 2);
+		LCD.drawInt((int)(pos[0] * 10), 3, 0);
+		LCD.drawInt((int)(pos[1] * 10), 3, 1);
+		LCD.drawInt((int)pos[2], 3, 2);
+	}
+}
diff --git a/Group-15/Lab4-15/Lab4.java b/Group-15/Lab4-15/Lab4.java
new file mode 100644
index 0000000..d414911
--- /dev/null
+++ b/Group-15/Lab4-15/Lab4.java
@@ -0,0 +1,68 @@
+import lejos.nxt.*;
+import lejos.nxt.comm.RConsole;
+
+/**
+ * 
+ * @project Lab 4 Localization 
+ * @names Riley van Ryswyk & Aditya Saha
+ * @studentID 260447357 & 260453165
+ * @group 15
+ * @course ECSE 211 
+ * @date 06/10/2013
+ * 
+ */
+
+public class Lab4 {
+
+	public static void main(String[] args) {
+		
+		// setup the odometer, and ultrasonic and light sensors
+		TwoWheeledRobot patBot = new TwoWheeledRobot(Motor.B, Motor.A);
+		Odometer odo = new Odometer(patBot, true);
+		UltrasonicSensor us = new UltrasonicSensor(SensorPort.S2);
+		ColorSensor ls = new ColorSensor(SensorPort.S1);
+		
+		//choose method of Ultrasonic localization
+		int buttonChoice;
+		
+		do {
+			// clear the display
+			LCD.clear();
+
+			// ask the user whether rising or falling localization
+			LCD.drawString("< Left | Right >", 0, 0);
+			LCD.drawString("       |        ", 0, 1);
+			LCD.drawString("  Rise | Fall   ", 0, 2);
+
+			buttonChoice = Button.waitForPress();
+		} while (buttonChoice != Button.ID_LEFT
+				&& buttonChoice != Button.ID_RIGHT);
+		
+		//setup display
+		LCDInfo lcd = new LCDInfo(odo);
+		
+		//Rising Edge Ultrasonic Localization
+		if (buttonChoice == Button.ID_LEFT) {
+			USLocalizer usl = new USLocalizer(odo, us, USLocalizer.LocalizationType.RISING_EDGE);
+			usl.doLocalization();
+		} 
+		//Falling edge Ultrasonic Localization
+		else {
+			USLocalizer usl = new USLocalizer(odo, us, USLocalizer.LocalizationType.FALLING_EDGE);
+			usl.doLocalization();
+		}
+		
+		// Turn to 0 degrees to display the accuracy of the ultrasonic localization
+		odo.getNavigation().turnTo(0);
+		
+		// perform the light sensor localization
+		LightLocalizer lsl = new LightLocalizer(odo, ls);
+		lsl.doLocalization();
+		
+		odo.getNavigation().travelTo(0, 0);
+		odo.getNavigation().turnTo(0);
+		
+		Button.waitForPress();
+	}
+
+}
diff --git a/Group-15/Lab4-15/LightLocalizer.java b/Group-15/Lab4-15/LightLocalizer.java
new file mode 100644
index 0000000..b42036f
--- /dev/null
+++ b/Group-15/Lab4-15/LightLocalizer.java
@@ -0,0 +1,193 @@
+import java.util.ArrayList;
+import java.util.List;
+
+import lejos.nxt.ColorSensor;
+import lejos.nxt.Sound;
+import lejos.nxt.comm.RConsole;
+
+/**
+ * 
+ * @project Lab 4 Localization 
+ * @names Riley van Ryswyk & Aditya Saha
+ * @studentID 260447357 & 260453165
+ * @group 15
+ * @course ECSE 211 
+ * @date 06/10/2013
+ * 
+ * Light sensor localization
+ */
+
+public class LightLocalizer {
+	
+	private static final long CORRECTION_PERIOD = 10;
+	private Odometer odo;
+	private TwoWheeledRobot robot;
+	private ColorSensor lightSensor;
+	
+	//store light sensor values (for filtering purposes)
+	private List<Double> lsValues = new ArrayList<Double>();
+	
+	//the headings when a line is detected
+	private List<Double> angles = new ArrayList<Double>();
+	
+	// Keep track of whether we are on a line on not
+	private boolean onLine = false;
+	private int lineCount = 0;
+	
+	// tile size, light sensor offset
+	private final double TILE_SIZE = 30.48, LS_OFFSET = 12.8;
+	
+	/**
+	 * Light sensor localization constructor
+	 * @param odo
+	 * @param ls
+	 */
+	public LightLocalizer(Odometer odo, ColorSensor ls) {
+		this.odo = odo;
+		this.robot = odo.getTwoWheeledRobot();
+		this.lightSensor = ls;
+		
+		//for line detection
+		Sound.setVolume(50);
+		// turn on the light to red
+		ls.setFloodlight(0);
+		
+	}
+	
+	/**
+	 * do light sensor localization
+	 * finds x, y, theta to within 0.2cm, 1 deg
+	 */
+	public void doLocalization() {
+		// drive to location listed in tutorial
+		// start rotating and clock all 4 gridlines
+		// do trig to compute (0,0) and 0 degrees
+		// when done travel to (0,0) and turn to 0 degrees
+		
+		// travel to roughly -4cm, -4cm
+		odo.getNavigation().travelTo(-4.0,-4.0);
+		
+		//Initialize line count to 0
+		lineCount = 0;
+		
+		//clear angles array
+		angles.clear();
+		
+		//populate light sensor array with a sufficient amount of values
+		lsValues.add((double) lightSensor.getRawLightValue() / 2.0);
+		lsValues.add((double) lightSensor.getRawLightValue() / 2.0);
+		lsValues.add((double) lightSensor.getRawLightValue() / 2.0);
+		
+		//ensures that we pass the lines in the same order every time | could be avoided with a more sophisticated calculation of thetaX and thetaY
+		if(odo.getTheta() > 80) {
+			odo.getNavigation().turnTo(45);
+		}
+				
+		//to mantain the correct CORRECTION_PERIOD
+		long correctionStart, correctionEnd;
+		
+		//line detection loop
+		while (lineCount < 4) {
+			correctionStart = System.currentTimeMillis();
+			
+			//sets robot to rotate at 35 deg/s
+			robot.setSpeeds(0, 35);
+			
+			//adds light sensor value to array of values
+			lsValues.add((double) lightSensor.getRawLightValue() / 2.0);
+				
+			//filters the light sensor information, and determines if a line was detected or not
+			filterLightSensor();
+			
+			// this ensure the odometry correction occurs only once every period
+			correctionEnd = System.currentTimeMillis();
+			
+			if (correctionEnd - correctionStart < CORRECTION_PERIOD) {
+				try {
+					Thread.sleep(CORRECTION_PERIOD
+							- (correctionEnd - correctionStart));
+				} catch (InterruptedException e) {
+					// there is nothing to be done here because it is not
+					// expected that the odometry correction will be
+					// interrupted by another thread
+				}
+			}
+		}
+		
+		//stop robot
+		robot.setSpeeds(0, 0);
+		
+		//resets onLine
+		onLine = false;
+		
+		// calculates the angle spanned between the headings of the robot when the lines on the X and Y axes were detected respectively
+		double thetaX = angles.get(0) - angles.get(2);
+		double thetaY = angles.get(1) - angles.get(3);
+		
+		// Based on the above angles, the current x, y coordinates are calculated (assuming 0,0 is the closest intersection)
+		double x = -LS_OFFSET * Math.cos(Math.toRadians(thetaY/2.0));
+		double y = -LS_OFFSET * Math.cos(Math.toRadians(thetaX/2.0));
+		
+		// if the first detection was at a heading of between [0,60], we are not in the negative x,y region
+		// so invert y | x will be correctly inverted
+		if(angles.get(0) < 60) {
+			y = -y;
+		} 
+		
+		// we are not in the right stop to determine theta -> update current position (x,y) and then redo localization
+		if(x > 0 || y > 0) {
+			odo.setPosition(new double [] {x, y, odo.getTheta() }, new boolean [] {true, true, true});
+			doLocalization();
+		}
+		//localization was successful
+		else {
+			// calculate amount to adjust theta by, achieved through averaging the values for dTheta calculated on both the x and y axes
+			double dTheta = (439-thetaX/2.0-thetaY/2.0-angles.get(3)-angles.get(2))/2.0;
+			
+			//update our current position 
+			odo.setPosition(new double [] {x, y, odo.getTheta()+dTheta }, new boolean [] {true, true, true});
+		}
+		
+	}
+	
+	/**
+	 * Applys smoothing and differencing to the recorded values
+	 * detects when black line is detected and when the regular floor is detected again 
+	 */
+	public void filterLightSensor() {
+		
+		double result;
+		
+		// Smooth and difference
+		result = -lsValues.get(0) - lsValues.get(1) + lsValues.get(2) + lsValues.get(3);
+		
+		//if not currently on a line and filter result is less than -45 we just enter a line			
+		if(!onLine && result < -45) {
+			onLine = true;
+			
+			//go to line detection logic
+			lineDetected();
+			
+			//alert us with a beep that a line was detected
+			Sound.beep();
+			
+			lineCount++;
+			
+		} 
+		//if we are on a line and filter result > 45 we have now left the line
+		else if(onLine && result > 45) {
+			onLine = false;
+		}
+		
+		//shift values left by 1 for next iteration
+		lsValues.remove(0);
+	}
+	
+	/**
+	 * when a line is detected, add it to the array of line detected angles
+	 */
+	public void lineDetected() {
+		angles.add(odo.getTheta());
+	}
+
+}
diff --git a/Group-15/Lab4-15/Navigation.java b/Group-15/Lab4-15/Navigation.java
new file mode 100644
index 0000000..391af2a
--- /dev/null
+++ b/Group-15/Lab4-15/Navigation.java
@@ -0,0 +1,246 @@
+
+/**
+ * 
+ * @project Lab 4 Localization 
+ * @names Riley van Ryswyk & Aditya Saha
+ * @studentID 260447357 & 260453165
+ * @group 15
+ * @course ECSE 211 
+ * @date 06/10/2013
+ * 
+ * Navigation 
+ * 
+ */
+public class Navigation {
+
+	private Odometer odometer;
+	private TwoWheeledRobot robot;
+
+	// Update every 50ms
+	private static final long UPDATE_PERIOD = 50;
+
+	// Max speeds in cm/sec, deg/sec
+	private final int MAX_FORWARD_SPEED = 8;
+	private final int MAX_ROTATE_SPEED = 40;
+
+	// navigation variables
+	private boolean navigating = false;
+	private boolean turning = false;
+
+	// for synchronization
+	private Object lock;
+
+	public Navigation(Odometer odo) {
+		this.odometer = odo;
+		this.robot = odo.getTwoWheeledRobot();
+	}
+
+	/**
+	 * Method to travel to a set of Cartesian coordinates
+	 * @param x
+	 * @param y
+	 */
+	public void travelTo(double x, double y) {
+
+		// we're navigating
+		navigating = true;
+
+		long correctionStart, correctionEnd;
+
+		// main loop
+		travelLoop: while (navigating) {
+			correctionStart = System.currentTimeMillis();
+
+			/*
+			 * retrieve current position and calculate dX and dY
+			 */
+			double[] pos = new double[3];
+
+			odometer.getPosition(pos);
+
+			double currentX = pos[0];
+			double currentY = pos[1];
+			double currentTheta = pos[2];
+
+			// Distance between where we are and where we need to travel to
+			double dX = x - currentX;
+			double dY = y - currentY;
+
+			/*
+			 * if within 0.2cm (x&y) of the destination x,y stop otherwise
+			 * continuing traveling
+			 */
+			if (Math.abs(dX) < 0.2 && Math.abs(dY) < 0.2) {
+				navigating = false;
+				robot.stop();
+				break travelLoop;
+			}
+			/*
+			 * We are not at our destination and the path is clear
+			 */
+			else {
+
+				// the required theta to travel to our destination
+				double theta = Math.atan2(dY, dX) * 180.0 / Math.PI;
+				// adjust to [0, 360]
+				theta = (theta < 0) ? 360 + theta : theta;
+
+				// see if we need to make a big turn
+				if ((Math.abs(theta - currentTheta) > 1 && turning)
+						|| Math.abs(theta - currentTheta) > 5) {
+
+					// if we need to turn more than 0.2 rads or 0.1 for
+					// completing a turn, call the turnTo method
+					// otherwise we can adjust small angle errors by slowing one
+					// wheel down slightly
+					turnTo(theta);
+
+				}
+				// We need to go straight (or relatively straight)
+				else {
+
+					/*
+					 * For minor angle corrections
+					 */
+
+					// error in theta
+					double deltaTheta = theta - currentTheta;
+					// amount to change right wheel speed by
+					int dL = 0;
+
+					// Change deltaTheta to [0,360)
+					if (deltaTheta > 180) {
+						deltaTheta -= 360;
+					} else if (deltaTheta < -180) {
+						deltaTheta += 360;
+					}
+
+					// If angle error is greater than 0.01 rad, make adjustment
+					if (Math.abs(deltaTheta) > 0.5) {
+
+						// if we are facing to the left of where we should be,
+						// slight right
+						if (deltaTheta > 0) {
+
+							dL = -1;
+						}
+
+						// if we are facing to the right of where we should be,
+						// slight left
+						else if (deltaTheta < 0) {
+
+							dL = 1;
+						}
+					}
+
+					/*
+					 * End minor angle corrections
+					 */
+
+					// Distance to destination
+					double distanceToTravel = (dX * Math.cos(Math
+							.toRadians(currentTheta)))
+							+ (dY * Math.sin(Math.toRadians(currentTheta)));
+
+					// high speed
+					if (distanceToTravel > 3) {
+						robot.setSpeeds(MAX_FORWARD_SPEED, dL);
+					}
+					// start to slow down
+					else if (distanceToTravel > 1) {
+						robot.setSpeeds(MAX_FORWARD_SPEED / 2, dL);
+					}
+					// go really slow, so that we don't overshoot
+					else {
+						robot.setSpeeds(MAX_FORWARD_SPEED / 5, dL / 3);
+					}
+				}
+
+				// this ensure the odometry correction occurs only once every
+				// period
+				correctionEnd = System.currentTimeMillis();
+
+				if (correctionEnd - correctionStart < UPDATE_PERIOD) {
+					try {
+						Thread.sleep(UPDATE_PERIOD
+								- (correctionEnd - correctionStart));
+					} catch (InterruptedException e) {
+						// there is nothing to be done here because it is not
+						// expected that the odometry correction will be
+						// interrupted by another thread
+					}
+				}
+			}
+		}
+
+	}
+
+	/**
+	 * Orientents the robot to the specified angle
+	 * @param angle
+	 */
+	public void turnTo(double angle) {
+
+		// we are turning
+		if (!turning)
+			turning = true;
+
+		long correctionStart, correctionEnd;
+
+		// main loop
+		while (turning) {
+			correctionStart = System.currentTimeMillis();
+
+			// error in angle
+			double deltaTheta = angle - odometer.getTheta();
+
+			// convert to [-180,180] for minimal angle
+			if (deltaTheta > 180) {
+				deltaTheta -= 360;
+			} else if (deltaTheta < -180) {
+				deltaTheta += 360;
+			}
+
+			// if angle error greater than 1 deg
+			if (Math.abs(deltaTheta) >= 1) {
+				// if error positive and greater than 5 deg -> max speed CCW
+				if (deltaTheta > 8) {
+					robot.setSpeeds(0, -MAX_ROTATE_SPEED);
+				}
+				// positive error, but close to 0, so turn slow CCW to prevent
+				// overshoot
+				else if (deltaTheta > 0) {
+					robot.setSpeeds(0, -MAX_ROTATE_SPEED / 4);
+				}
+				// error negative and less than 5deg -> max speed CW
+				else if (deltaTheta < -8) {
+					robot.setSpeeds(0, MAX_ROTATE_SPEED);
+				}
+				// negative error, but close to 0, so turn slow CW to prevent
+				// overshoot
+				else if (deltaTheta < 0) {
+					robot.setSpeeds(0, MAX_ROTATE_SPEED / 4);
+				}
+			} else {
+				// we have finished turning
+				turning = false;
+				robot.stop();
+			}
+
+			// this ensure the odometry correction occurs only once every period
+			correctionEnd = System.currentTimeMillis();
+
+			if (correctionEnd - correctionStart < UPDATE_PERIOD) {
+				try {
+					Thread.sleep(UPDATE_PERIOD
+							- (correctionEnd - correctionStart));
+				} catch (InterruptedException e) {
+					// there is nothing to be done here because it is not
+					// expected that the odometry correction will be
+					// interrupted by another thread
+				}
+			}
+		}
+
+	}
+}
diff --git a/Group-15/Lab4-15/Odometer.java b/Group-15/Lab4-15/Odometer.java
new file mode 100644
index 0000000..e1b9ef8
--- /dev/null
+++ b/Group-15/Lab4-15/Odometer.java
@@ -0,0 +1,176 @@
+import lejos.util.Timer;
+import lejos.util.TimerListener;
+/**
+ * 
+ * @project Lab 4 Localization 
+ * @names Riley van Ryswyk & Aditya Saha
+ * @studentID 260447357 & 260453165
+ * @group 15
+ * @course ECSE 211 
+ * @date 06/10/2013
+ * 
+ * Odometer (provided)
+ * changed the way theta is defined (now 0 along +x axis and increases CCW)
+ */
+public class Odometer implements TimerListener {
+	public static final int DEFAULT_PERIOD = 25;
+	private TwoWheeledRobot robot;
+	private Timer odometerTimer;
+	private Navigation nav;
+	// position data
+	private Object lock;
+	private double x, y, theta;
+	private double [] oldDH, dDH;
+	
+	/**
+	 * Odometer constructor
+	 * @param robot
+	 * @param period
+	 * @param start
+	 */
+	public Odometer(TwoWheeledRobot robot, int period, boolean start) {
+		// initialise variables
+		this.robot = robot;
+		this.nav = new Navigation(this);
+		odometerTimer = new Timer(period, this);
+		x = 0.0;
+		y = 0.0;
+		theta = 90.0;
+		oldDH = new double [2];
+		dDH = new double [2];
+		lock = new Object();
+		
+		// start the odometer immediately, if necessary
+		if (start)
+			odometerTimer.start();
+	}
+	/**
+	 * Odometer constructor
+	 * @param robot
+	 */
+	public Odometer(TwoWheeledRobot robot) {
+		this(robot, DEFAULT_PERIOD, false);
+	}
+	/**
+	 * Odometer constructor
+	 * @param robot
+	 * @param start
+	 */
+	public Odometer(TwoWheeledRobot robot, boolean start) {
+		this(robot, DEFAULT_PERIOD, start);
+	}
+	/**
+	 * Odometer Constructor
+	 * @param robot
+	 * @param period
+	 */
+	public Odometer(TwoWheeledRobot robot, int period) {
+		this(robot, period, false);
+	}
+	
+	/**
+	 * Update loop
+	 * 
+	 * Finds change in motors tacho count and then updates x,y,theta correspondingly 
+	 */
+	public void timedOut() {
+		robot.getDisplacementAndHeading(dDH);
+		//change in displacement and heading
+		dDH[0] -= oldDH[0];
+		dDH[1] -= oldDH[1];
+		
+		// update the position in a critical region
+		synchronized (lock) {
+			theta -= dDH[1];
+			theta = fixDegAngle(theta);
+			
+			x += dDH[0] * Math.cos(Math.toRadians(theta));
+			y += dDH[0] * Math.sin(Math.toRadians(theta));
+		}
+		
+		//update old displacement and heading
+		oldDH[0] += dDH[0];
+		oldDH[1] += dDH[1];
+	}
+	
+	/**
+	 * returns position
+	 * @param pos
+	 */
+	public void getPosition(double [] pos) {
+		synchronized (lock) {
+			pos[0] = x;
+			pos[1] = y;
+			pos[2] = theta;
+		}
+	}
+	
+	/**
+	 * returns theta
+	 * @return
+	 */
+	public double getTheta() {
+		double result;
+
+		synchronized (lock) {
+			result = theta;
+		}
+
+		return result;
+	}
+	
+	/**
+	 * returns TwoWheeledRobot
+	 * @return
+	 */
+	public TwoWheeledRobot getTwoWheeledRobot() {
+		return robot;
+	}
+	
+	/**
+	 * returns navigation object
+	 * @return
+	 */
+	public Navigation getNavigation() {
+		return this.nav;
+	}
+	
+	/**
+	 * set the current position
+	 * @param pos
+	 * @param update
+	 */
+	public void setPosition(double [] pos, boolean [] update) {
+		synchronized (lock) {
+			if (update[0]) x = pos[0];
+			if (update[1]) y = pos[1];
+			if (update[2]) theta = pos[2];
+		}
+	}
+	
+	/**
+	 * Ensures angle is always in [0,360)
+	 * @param angle
+	 * @return
+	 */
+	public static double fixDegAngle(double angle) {		
+		if (angle < 0.0)
+			angle = 360.0 + (angle % 360.0);
+		
+		return angle % 360.0;
+	}
+	/**
+	 * returns the minimum angle
+	 * @param a
+	 * @param b
+	 * @return
+	 */
+	public static double minimumAngleFromTo(double a, double b) {
+		double d = fixDegAngle(b - a);
+		
+		if (d < 180.0)
+			return d;
+		else
+			return d - 360.0;
+	}
+}
diff --git a/Group-15/Lab4-15/TwoWheeledRobot.java b/Group-15/Lab4-15/TwoWheeledRobot.java
new file mode 100644
index 0000000..271e83b
--- /dev/null
+++ b/Group-15/Lab4-15/TwoWheeledRobot.java
@@ -0,0 +1,161 @@
+import lejos.nxt.NXTRegulatedMotor;
+/**
+ * 
+ * @project Lab 4 Localization 
+ * @names Riley van Ryswyk & Aditya Saha
+ * @studentID 260447357 & 260453165
+ * @group 15
+ * @course ECSE 211 
+ * @date 06/10/2013
+ * 
+ * TwoWheeledRobot (provided)
+ * added stop method
+ * limited motor acceleration
+ * and changed robot parameters
+ */
+public class TwoWheeledRobot {
+	public static final double DEFAULT_LEFT_RADIUS = 2.11;
+	public static final double DEFAULT_RIGHT_RADIUS = 2.11;
+	public static final double DEFAULT_WIDTH = 14.92;
+	private NXTRegulatedMotor leftMotor, rightMotor;
+	private double leftRadius, rightRadius, width;
+	private double forwardSpeed, rotationSpeed;
+	
+	/**
+	 * Constructor
+	 * @param leftMotor
+	 * @param rightMotor
+	 * @param width
+	 * @param leftRadius
+	 * @param rightRadius
+	 */
+	public TwoWheeledRobot(NXTRegulatedMotor leftMotor,
+						   NXTRegulatedMotor rightMotor,
+						   double width,
+						   double leftRadius,
+						   double rightRadius) {
+		this.leftMotor = leftMotor;
+		this.rightMotor = rightMotor;
+		this.leftRadius = leftRadius;
+		this.rightRadius = rightRadius;
+		this.width = width;
+		leftMotor.setAcceleration(1000);
+		rightMotor.setAcceleration(1000);
+	}
+	/**
+	 * Constructor
+	 * @param leftMotor
+	 * @param rightMotor
+	 */
+	public TwoWheeledRobot(NXTRegulatedMotor leftMotor, NXTRegulatedMotor rightMotor) {
+		this(leftMotor, rightMotor, DEFAULT_WIDTH, DEFAULT_LEFT_RADIUS, DEFAULT_RIGHT_RADIUS);
+	}
+	/**
+	 * Constructor
+	 * @param leftMotor
+	 * @param rightMotor
+	 * @param width
+	 */
+	public TwoWheeledRobot(NXTRegulatedMotor leftMotor, NXTRegulatedMotor rightMotor, double width) {
+		this(leftMotor, rightMotor, width, DEFAULT_LEFT_RADIUS, DEFAULT_RIGHT_RADIUS);
+	}
+	
+	/**
+	 * Returns displacement based on TachoMeter count
+	 * @return
+	 */
+	public double getDisplacement() {
+		return (leftMotor.getTachoCount() * leftRadius +
+				rightMotor.getTachoCount() * rightRadius) *
+				Math.PI / 360.0;
+	}
+	/**
+	 *  returns heading based on tachoMeter count
+	 * @return
+	 */
+	public double getHeading() {
+		return (leftMotor.getTachoCount() * leftRadius -
+				rightMotor.getTachoCount() * rightRadius) / width;
+	}
+	/**
+	 * returns displacement and heading based on tacho counts -> passed through the data array pointer
+	 * @param data
+	 */
+	public void getDisplacementAndHeading(double [] data) {
+		int leftTacho, rightTacho;
+		leftTacho = leftMotor.getTachoCount();
+		rightTacho = rightMotor.getTachoCount();
+		
+		data[0] = (leftTacho * leftRadius + rightTacho * rightRadius) *	Math.PI / 360.0;
+		data[1] = (leftTacho * leftRadius - rightTacho * rightRadius) / width;
+	}
+	
+	/**
+	 * Sets forward robot speed (cm/s)
+	 * @param speed
+	 */
+	public void setForwardSpeed(double speed) {
+		forwardSpeed = speed;
+		setSpeeds(forwardSpeed, rotationSpeed);
+	}
+	
+	/**
+	 * sets rotational speed (deg/s)
+	 * @param speed
+	 */
+	public void setRotationSpeed(double speed) {
+		rotationSpeed = speed;
+		setSpeeds(forwardSpeed, rotationSpeed);
+	}
+	
+	/**
+	 * Sets both forward and rotational speed (cm/s, deg/s)
+	 * @param forwardSpeed
+	 * @param rotationalSpeed
+	 */
+	public void setSpeeds(double forwardSpeed, double rotationalSpeed) {
+		double leftSpeed, rightSpeed;
+
+		this.forwardSpeed = forwardSpeed;
+		this.rotationSpeed = rotationalSpeed; 
+
+		leftSpeed = (forwardSpeed + rotationalSpeed * width * Math.PI / 360.0) *
+				180.0 / (leftRadius * Math.PI);
+		rightSpeed = (forwardSpeed - rotationalSpeed * width * Math.PI / 360.0) *
+				180.0 / (rightRadius * Math.PI);
+
+		// set motor directions
+		if (leftSpeed > 0.0)
+			leftMotor.forward();
+		else {
+			leftMotor.backward();
+			leftSpeed = -leftSpeed;
+		}
+		
+		if (rightSpeed > 0.0)
+			rightMotor.forward();
+		else {
+			rightMotor.backward();
+			rightSpeed = -rightSpeed;
+		}
+		
+		// set motor speeds
+		if (leftSpeed > 900.0)
+			leftMotor.setSpeed(900);
+		else
+			leftMotor.setSpeed((int)leftSpeed);
+		
+		if (rightSpeed > 900.0)
+			rightMotor.setSpeed(900);
+		else
+			rightMotor.setSpeed((int)rightSpeed);
+	}
+	
+	/**
+	 * Stops robot
+	 */
+	public void stop() {
+		rightMotor.stop(true);
+		leftMotor.stop();
+	}
+}
diff --git a/Group-15/Lab4-15/USLocalizer.java b/Group-15/Lab4-15/USLocalizer.java
new file mode 100644
index 0000000..b4e7d8a
--- /dev/null
+++ b/Group-15/Lab4-15/USLocalizer.java
@@ -0,0 +1,325 @@
+import java.util.ArrayList;
+import java.util.List;
+
+import lejos.nxt.Motor;
+import lejos.nxt.UltrasonicSensor;
+import lejos.nxt.comm.RConsole;
+
+/**
+ * 
+ * @project Lab 4 Localization 
+ * @names Riley van Ryswyk & Aditya Saha
+ * @studentID 260447357 & 260453165
+ * @group 15
+ * @course ECSE 211 
+ * @date 06/10/2013
+ * 
+ * Ultrasonic Localization
+ * Accurate to within ~3degs
+ */
+
+public class USLocalizer {
+	
+	//Types of localization
+	public enum LocalizationType { FALLING_EDGE, RISING_EDGE };
+	
+	//Speed in deg/sec of which to rotate during localization
+	public static double ROTATION_SPEED = 30;
+	
+	//period to check ultrasonic sensor in ms
+	public final int UPDATE_PERIOD = 30;
+	
+	//threshold distance in cm, to determine if we are at a critical angle
+	public final int THRESHOLD = 30;
+	
+	//Objects for interaction with other classes
+	private Odometer odo;
+	private TwoWheeledRobot robot;
+	private UltrasonicSensor us;
+	private LocalizationType locType;
+	private Navigation nav;
+	
+	// Store list of previous ultrasonic sensor values for filtering
+	private List<Integer> usValues = new ArrayList<Integer>();
+	
+	/**
+	 * Ultrasonic sensor class constructor
+	 * @param odo
+	 * @param us
+	 * @param locType
+	 */
+	public USLocalizer(Odometer odo, UltrasonicSensor us, LocalizationType locType) {
+		this.odo = odo;
+		this.robot = odo.getTwoWheeledRobot();
+		this.us = us;
+		this.locType = locType;
+		this.nav = odo.getNavigation();
+		
+		// switch off the ultrasonic sensor
+		us.off();
+	}
+	
+	/**
+	 * Carrys out Ultrasonic localization
+	 */
+	public void doLocalization() {
+		
+		//to feed to odometer
+		double [] pos = new double [3];
+		
+		// Critical angles (when wall is detected/not detected
+		double angleA = -1, angleB = -1;
+		
+		//amount to adjust the heading by
+		double deltaTheta = 0;
+		
+		//to ensure we run only once an UPDATE_PERIOD
+		long correctionStart, correctionEnd;
+		
+		// to prevent errors when changing directions
+		int BDelay = 0; 
+		
+		//Fill the array of usValues with the current reading of the ultrasonic sensor
+		getFilteredData();
+		getFilteredData();
+		getFilteredData();
+		getFilteredData();
+		
+		/*
+		 * Falling edge detected (no wall -> wall)
+		 * 
+		 * 	rotate the robot until it sees no wall
+		 *  keep rotating until the robot sees a wall, then latch the angle
+		 *  switch direction and wait until it sees no wall
+		 *  keep rotating until the robot sees a wall, then latch the angle
+		 */
+		if (locType == LocalizationType.FALLING_EDGE) {
+			
+			//to keep track of whether we were facing a wall or not
+			boolean noWall = false;
+			
+			//Localization loop
+			locloop: 
+				while(true) {
+				
+				correctionStart = System.currentTimeMillis();
+				
+				//set the direction of rotation, once angleA is found it will be >0
+				if(angleA < 0) {
+					robot.setSpeeds(0, 40);
+				} else {
+					robot.setSpeeds(0, -40);
+					
+					//prevent detection of same wall/no wall barrier 
+					BDelay++;
+				}
+				
+				//retrieve the value of the filtered Ultrasonic data
+				int distance = getFilteredData();
+				
+				//We were seeing a wall and the distance is greater than the threshold -> we are not seeing a wall
+				if(!noWall && distance > THRESHOLD) {
+					
+					//update noWall
+					noWall = true;
+				} 
+				// we are not seeing a wall, haven't detected angleA and distance less than threshold -> we have found angleA
+				else if(noWall && angleA < 0 && distance < THRESHOLD) {
+					
+					//set angleA
+					angleA = odo.getTheta();
+					
+					//reset noWall
+					noWall = false;					
+				} 
+				//if we are not seeing a wall, and haven't detected angleB, the distance is less than the threshold and the delay since detecting angleA is greater than 50 iterations -> we have found angleB
+				else if(noWall && angleB < 0 && distance < THRESHOLD && BDelay > 50) {
+					
+					//set angleB
+					angleB = odo.getTheta();
+					
+					//Stop robot
+					robot.setSpeeds(0, 0);
+					
+					//break the us localization loop
+					break locloop;
+				}
+				
+				// this ensure the odometry correction occurs only once every period
+				correctionEnd = System.currentTimeMillis();
+				
+				if (correctionEnd - correctionStart < UPDATE_PERIOD) {
+					try {
+						Thread.sleep(UPDATE_PERIOD - (correctionEnd - correctionStart));
+					} catch (InterruptedException e) {
+						// there is nothing to be done here because it is not
+						// expected that the odometry correction will be
+						// interrupted by another thread
+					}
+				}
+				
+			}
+			
+			//first part of deltaTheta, the negative average of <A and <B
+			deltaTheta = -(angleA + angleB) / 2;
+			
+			//Depending on what angle is bigger, offset deltaTheta to the correct amount
+			if(angleA > angleB) {
+				deltaTheta += 226;
+			} else {
+				deltaTheta += 46;
+			}
+		} 
+		
+		/*
+		 * Rising Edge Detection
+		 * 
+		 * The robot should turn until it sees the wall, then look for the
+		 * "rising edges:" the points where it no longer sees the wall.
+		 * This is very similar to the FALLING_EDGE routine, but the robot
+		 * will face toward the wall for most of it.
+		 */
+		
+		else {
+			
+			// true if we are facing a wall
+			boolean wall = false;
+			
+			//localization loop
+			locloop: 
+				while(true) {
+				
+				correctionStart = System.currentTimeMillis();
+				
+				//Set speed of robot depending on whether we have detected angleA 
+				if(angleA < 0) {
+					robot.setSpeeds(0, 40);
+				} else {
+					robot.setSpeeds(0, -40);
+					//prevent incorrect detection of angleB (ie right after angleA has been detected)
+					BDelay++;
+				}
+				
+				//get filtered Ultrasonic data
+				int distance = getFilteredData();
+				
+				//if no wall and distance less than threshold -> we are seeing a wall
+				if(!wall && distance < THRESHOLD) {
+					wall = true;
+				} 
+				//if we were seeing a wall, angleA is not set and distance > threshold -> we have angleA
+				else if(wall && angleA < 0 && distance > THRESHOLD) {
+					
+					//set AngleA
+					angleA = odo.getTheta();
+					
+					//reset wall
+					wall = false;					
+					
+				} 
+				//if we were seeing a wall, angleB is not set, distance > threshold, and it has been more than 50 iterations since detecting angleA - > we have angleB
+				else if(wall && angleB < 0 && distance > THRESHOLD && BDelay > 50) {
+					
+					//set angleB
+					angleB = odo.getTheta();
+					
+					//stop robot
+					robot.setSpeeds(0, 0);
+					
+					//break the localization loop
+					break locloop;
+				}
+				
+				// this ensure the odometry correction occurs only once every period
+				correctionEnd = System.currentTimeMillis();
+				
+				if (correctionEnd - correctionStart < UPDATE_PERIOD) {
+					try {
+						Thread.sleep(UPDATE_PERIOD - (correctionEnd - correctionStart));
+					} catch (InterruptedException e) {
+						// there is nothing to be done here because it is not
+						// expected that the odometry correction will be
+						// interrupted by another thread
+					}
+				}
+				
+			}
+			
+			//first part of deltaTheta, the negative average of <A and <B
+			deltaTheta = -(angleA + angleB) / 2;
+			
+			//Depending on what angle is bigger, offset deltaTheta to the correct amount
+			if(angleB > angleA) {
+				deltaTheta += 228;
+			} else {
+				deltaTheta += 48;
+			}
+		}
+	
+		// initalize our position to x=-14, y=-14, theta += deltaTheta | we are roughly in the center of the square and deltaTheta was calculated by rising or falling edge detection
+		odo.setPosition(new double [] {-14.0, -14.0, odo.getTheta() + deltaTheta}, new boolean [] {true, true, true});
+		
+	}
+	
+	/**
+	 * Pings Ultrasonic sensor, waits for return and applys median filtering to the Ultrasonic data
+	 * @return
+	 */
+	private int getFilteredData() {
+		int distance;
+		
+		// do a ping
+		us.ping();
+		
+		// wait for the ping to complete
+		try { Thread.sleep(25); } catch (InterruptedException e) {}
+		
+		// there will be a delay here
+		distance = us.getDistance();
+		
+		//add the current value to array of values
+		usValues.add(distance);	
+		
+		//make sure we have sufficient number of samples
+		if(usValues.size() >= 5) {
+									
+			int result;
+			
+			//array of sorted values
+			List<Integer> usValuesSorted = new ArrayList<Integer>(usValues);
+			
+			//length of values (should be 5)
+			int size = usValuesSorted.size();
+			
+			//sort the values: lowest to highest
+			for(int i=0; i<size; i++) {
+				for(int j=i+1; j<size;j++) {
+					if(usValuesSorted.get(i) > usValuesSorted.get(j)) {
+						int temp = usValuesSorted.get(i);
+						usValuesSorted.set(i, usValuesSorted.get(j));
+						usValuesSorted.set(j, temp);					
+					}
+				}
+			}
+			
+			// if odd pick the middle value, else average the two middle values
+			if(size % 2 == 1 ) {
+				result = usValuesSorted.get(size/2);
+			} else {
+				result = ( usValuesSorted.get(size/2-1) + usValuesSorted.get(size/2) ) / 2;
+			}
+			
+			//shift values left by 1 for next iteration
+			usValues.remove(0);
+
+			//return result
+			return result;
+		} 
+		//not enough data for filtering yet, so return the current value
+		else {
+			return distance;
+		}		
+				
+	}
+
+}
diff --git a/Group-15/Lab5-15/Grid.java b/Group-15/Lab5-15/Grid.java
new file mode 100644
index 0000000..9b3e80a
--- /dev/null
+++ b/Group-15/Lab5-15/Grid.java
@@ -0,0 +1,275 @@
+import lejos.nxt.comm.RConsole;
+
+
+public class Grid {
+	
+	private final int FIELD_WIDTH = 4; 
+	private final int FIELD_LENGTH = 8;
+	private final int TILE_SIZE = 30;
+	
+	/*
+	 * Tiles array
+	 * indexed width,height
+	 * eg
+	 * 
+	 * 0,1 ; 1,1 ; 2,1 ; 3;1
+	 * 0,0 ; 1,0 ; 2,0 ; 3;0
+	 * 
+	 * such that (15,15) would be in title 1,1 
+	 * 
+	 * CODES:
+	 *  0 = empty
+	 *  1 = fully blocked
+	 *  2 = left 1/2 blocked (width direction)
+	 *  3 = right 1/2 blocked (width direction)
+	 *  4 = left 1/2 clear (width direction)
+	 *  5 = right 1/2 clear (width direction)
+	 *  6 = Unknown
+	 *  7 = inspection required
+	 *  8 = inspect object in tile
+	 * 
+	 */
+	private short[][] tiles = new short[FIELD_WIDTH][FIELD_LENGTH];
+	
+	public Grid() {
+		initalize();
+	}
+	
+	public void initalize() {
+		for(int i=0; i<tiles.length; i++) {
+			for(int j=0; j<tiles[0].length; j++) {
+				if(i < 3 && j < 3) {
+					//inital nine tiles are clear of any objects
+					tiles[i][j] = 0;
+				} else {
+					//tile is unknown to us
+					tiles[i][j] = 6;
+				}
+			}
+		}
+	}
+	
+	public void setTile(int w, int l, short state) {
+		RConsole.println("w;l" + String.valueOf(w) +";" + String.valueOf(l));
+		tiles[w][l] = state;
+	}
+	
+	public short getTitle(int w, int l) {
+		return tiles[w][l];
+	}
+	
+	public void setTilesScan(int start, int end, int scanPos, int distance, int heading) {
+		
+		int startTile = getTileIndexWidth(start);
+		int endTile = getTileIndexWidth(end);
+		
+		RConsole.println( "start;end " + String.valueOf(startTile) + ";" + String.valueOf(endTile) );
+		
+		if(distance == 255) {
+			RConsole.println("255");
+			for(int i = startTile; i<=endTile; i++) {
+				for(int j = getTileIndexLength(scanPos)+1; j<tiles[0].length; j++) {
+					if(tiles[i][j] != 1) { 
+						tiles[i][j] = 7;
+					}
+				}
+				
+			}
+			RConsole.println("/255");
+		} else {
+		
+			int freeTiles = ( (distance - ((scanPos+5) % TILE_SIZE)) / TILE_SIZE ) + 1;
+			
+			if(freeTiles + (scanPos / TILE_SIZE) > FIELD_LENGTH ) {
+				freeTiles = FIELD_LENGTH - (scanPos / TILE_SIZE);
+			}
+			
+			boolean startTileHalf;
+			
+			if(start > 0) {
+				startTileHalf= (start % TILE_SIZE > 15) ? true : false;
+			} else {
+				startTileHalf = ((start+30) % TILE_SIZE > 15) ? true : false;
+			}
+			boolean endTileHalf = (end % TILE_SIZE < 15) ? true : false;
+			int offset = (int) Math.floor(scanPos / TILE_SIZE) + 1;
+			
+			
+			RConsole.println( "free tiles " + String.valueOf(freeTiles) + "; offset " + String.valueOf(offset) );
+			RConsole.println( "distance to wall " + String.valueOf(distanceToWall(start, scanPos, heading)) );
+		
+			for(int j = offset; j<freeTiles+offset; j++) {
+				for(int i = startTile; i<=endTile; i++) {
+					RConsole.println(String.valueOf(i) + "," + String.valueOf(j));
+					if (startTileHalf && i == startTile ) {
+						if(tiles[i][j] != 2) {
+							tiles[i][j] = 0;
+						} 
+					} else if(endTileHalf && i == endTile) {
+						if(tiles[i][j] != 3) {
+							tiles[i][j] = 0;
+						} 
+					} else {
+						tiles[i][j] = 0;
+					}
+				}
+			}
+			
+			if( Math.abs(distance - distanceToWall(start, scanPos, heading)) > 10) {
+				//length is too long for styrofoam
+				boolean blocked = (Math.abs(start-end) > 40) ? true : false;
+				int j = getTileIndexLength(scanPos+distance);
+				for(int i = startTile; i<=endTile; i++) {
+					if(blocked) {
+						if(startTileHalf && i == startTile) {
+							if(tiles[i][j] == 2 || tiles[i][j] == 1) {
+								tiles[i][j] = 1;
+							} else {
+								tiles[i][j] = 3;
+							}
+						} else if(endTileHalf && i == endTile) {
+							if(tiles[i][j] == 3 || tiles[i][j] == 1) {
+								tiles[i][j] = 1;
+							} else {
+								tiles[i][j] = 2;
+							}
+						} else {
+							//block the tile
+							tiles[i][j] = 1;
+						}
+					} else {
+						//set it to inspect
+						tiles[i][j] = 8;
+					}
+					
+					
+				}
+			}
+		}
+		
+	}
+	
+	public int distanceToWall(int x, int y, int heading) {
+		if(Math.sin(Math.toRadians(heading)) > 0.95) {
+			return (int) ( (FIELD_LENGTH - 1) * TILE_SIZE - y );
+		} else {
+			return (int) ( (FIELD_WIDTH - 1) * TILE_SIZE - x );
+		}
+	}
+	
+	public int getTileIndexWidth(int x) {
+			
+		return  (int) Math.floor( (double) x / (double) TILE_SIZE) + 1;
+	}
+	
+	public int getTileIndexLength(int y) {
+		return (int) Math.floor( (double) y / (double) TILE_SIZE) + 1;
+	}
+	
+	public String printGrid() {
+		String result = "";
+		for(int i=0; i<tiles.length; i++) {
+			for(int j=0; j<tiles[0].length; j++) {
+				result += String.valueOf(tiles[i][j] + ",");
+			}
+			result += "\n";
+		}
+		
+		return result;
+	}
+	
+	public boolean contains(short value) {
+		for(int i=0; i<tiles.length; i++) {
+			for(int j=0; j<tiles[0].length; j++) {
+				if(tiles[i][j] == value) {
+					return true;
+				}
+			}
+		}
+		
+		return false;
+	}
+	
+	public boolean getClosestTile(int[] data, short value) {
+				
+		data[0] = getTileIndexWidth(data[0]);
+		data[1] = getTileIndexWidth(data[1]);
+		
+		double distance = 1000;
+		int w = -1;
+		int l = -1;
+		
+		for(int i=0; i<tiles.length; i++) {
+			for(int j=0; j<tiles[0].length; j++) {
+				if(tiles[i][j] == value) {
+					if ( Math.pow( (i - data[0]) , 2) + Math.pow( (i - data[0]) , 2) < distance) {
+						w = i;
+						l = j;
+						distance = Math.pow( (i - data[0]) , 2) + Math.pow( (i - data[0]) , 2);
+					}
+				}
+			}
+		}
+		
+		if(w == -1) {
+			return false;
+		} else {
+			
+			data[0] = w;
+			data[1] = l;
+			
+			return true;
+		}
+		
+	}
+	
+	public boolean getClosestTile2(int[] data, short value) {
+		
+		data[0] = getTileIndexWidth(data[0]);
+		data[1] = getTileIndexWidth(data[1]);
+		
+		double distance = 1000;
+		int l = -1;
+		int w = -1;
+		
+		for(int i=0; i<tiles.length; i++) {
+			for(int j=3; j<tiles[0].length; j++) {
+				if(tiles[i][j] == value) {
+					if ( j < distance) {
+						l = j;
+						w = i;
+						distance = j;
+					}
+				}
+			}
+		}
+		
+		if(l == -1) {
+			return false;
+		} else {
+			
+			data[0] = w;
+			data[1] = l;
+			
+			return true;
+		}
+		
+	}
+	
+	
+	
+	public int getX(int i) {
+		if(i==0) {
+			return i*30-10;
+		} else if (i == FIELD_WIDTH - 1) {
+			return i*30-20;
+		}
+		return i*30-15;
+	}
+	
+	public int getY(int j) {
+		return j*30-15;
+	}
+	
+
+}
diff --git a/Group-15/Lab5-15/LCDInfo.java b/Group-15/Lab5-15/LCDInfo.java
new file mode 100644
index 0000000..42d7982
--- /dev/null
+++ b/Group-15/Lab5-15/LCDInfo.java
@@ -0,0 +1,77 @@
+import lejos.nxt.LCD;
+import lejos.util.Timer;
+import lejos.util.TimerListener;
+
+/**
+ * 
+ * @project Lab 4 Localization 
+ * @names Riley van Ryswyk & Aditya Saha
+ * @studentID 260447357 & 260453165
+ * @group 15
+ * @course ECSE 211 
+ * @date 06/10/2013
+ * 
+ * LCD display (from lab 4)
+ */
+
+public class LCDInfo implements TimerListener{
+	public static final int LCD_REFRESH = 100;
+	private Odometer odo;
+	private Timer lcdTimer;
+	public enum BlockType { STYROFOAM, WOOD, NONE };
+	private BlockType type;
+	private boolean blockDetected = false;
+	
+	// arrays for displaying data
+	private double [] pos;
+	
+	/**
+	 * LCDInfo constructor
+	 * @param odo
+	 */
+	public LCDInfo(Odometer odo) {
+		this.odo = odo;
+		this.lcdTimer = new Timer(LCD_REFRESH, this);
+		
+		// initialise the arrays for displaying data
+		pos = new double [3];
+		
+		// start the timer
+		lcdTimer.start();
+	}
+	
+	/**
+	 * main update loop
+	 */
+	public void timedOut() { 
+		odo.getPosition(pos);
+		LCD.clear();
+		LCD.drawString("X: ", 0, 0);
+		LCD.drawString("Y: ", 0, 1);
+		LCD.drawString("H: ", 0, 2);
+		LCD.drawInt((int)(pos[0] * 10), 3, 0);
+		LCD.drawInt((int)(pos[1] * 10), 3, 1);
+		LCD.drawInt((int)pos[2], 3, 2);
+		
+		if(blockDetected) {
+			LCD.drawString(" Block Detected ", 0, 3);
+		}
+		
+		if(type == BlockType.STYROFOAM) {
+			LCD.drawString(" Styrofoam ", 0, 4);
+		} else if(type == BlockType.WOOD) {
+			LCD.drawString(" Wood ", 0, 4);
+		}
+	}
+	
+	public void type(BlockType type) {
+		this.type = type;
+	}
+	
+	public void blockDetected(boolean detected) {
+		blockDetected = detected;
+		if(detected = false) {
+			this.type = BlockType.NONE;
+		}
+	}
+}
diff --git a/Group-15/Lab5-15/Lab5.java b/Group-15/Lab5-15/Lab5.java
new file mode 100644
index 0000000..a3eb28b
--- /dev/null
+++ b/Group-15/Lab5-15/Lab5.java
@@ -0,0 +1,71 @@
+import lejos.nxt.*;
+import lejos.nxt.comm.RConsole;
+
+/**
+ * 
+ * @project Lab 5 Object Recognition 
+ * @names Riley van Ryswyk & Aditya Saha
+ * @studentID 260447357 & 260453165
+ * @group 15
+ * @course ECSE 211 
+ * @date 10/22/2013
+ * 
+ */
+
+public class Lab5 {
+
+	public static void main(String[] args) {
+		RConsole.openBluetooth(20000);
+		// setup the odometer, and ultrasonic and light sensors
+		TwoWheeledRobot patBot = new TwoWheeledRobot(Motor.B, Motor.A);
+		Odometer odo = new Odometer(patBot, true);
+		UltrasonicSensor us = new UltrasonicSensor(SensorPort.S2);
+		ColorSensor ls = new ColorSensor(SensorPort.S3);
+		UltrasonicPoller usPoller = new UltrasonicPoller(us, Motor.C, odo);
+				
+		//choose the lab part
+		int buttonChoice;
+		
+		do {
+			// clear the display
+			LCD.clear();
+
+			// ask the user whether rising or falling localization
+			LCD.drawString("< Left | Right >", 0, 0);
+			LCD.drawString("  Part | Part   ", 0, 1);
+			LCD.drawString("  One  | Two    ", 0, 2);
+
+			buttonChoice = Button.waitForPress();
+		} while (buttonChoice != Button.ID_LEFT
+				&& buttonChoice != Button.ID_RIGHT);
+		
+		//setup display
+		LCDInfo lcd = new LCDInfo(odo);
+		
+		//Object recognition
+		if (buttonChoice == Button.ID_LEFT) {
+			ObjectRecognitionOne one = new ObjectRecognitionOne(ls, usPoller, patBot, lcd);
+			one.start();
+			
+		} 
+		//Full lab 
+		else {
+			//initialize required classes
+			USLocalizer usl = new USLocalizer(odo, usPoller, USLocalizer.LocalizationType.FALLING_EDGE);
+			ObjectRecognitionTwo ort = new ObjectRecognitionTwo(ls, usPoller, patBot, odo);
+			ObjectFinding of = new ObjectFinding(usPoller, odo, ort);
+			//localize
+			usl.doLocalization();
+			
+			//Find the styrofoam
+			of.findStyrofoam();
+		}
+ 		
+		
+		Button.waitForPress();
+	}
+	
+	
+	
+
+}
diff --git a/Group-15/Lab5-15/LightLocalizer.java b/Group-15/Lab5-15/LightLocalizer.java
new file mode 100644
index 0000000..e7187a2
--- /dev/null
+++ b/Group-15/Lab5-15/LightLocalizer.java
@@ -0,0 +1,199 @@
+import java.util.ArrayList;
+import java.util.List;
+
+import lejos.nxt.ColorSensor;
+import lejos.nxt.Sound;
+import lejos.nxt.comm.RConsole;
+
+/**
+ * 
+ * @project Lab 4 Localization 
+ * @names Riley van Ryswyk & Aditya Saha
+ * @studentID 260447357 & 260453165
+ * @group 15
+ * @course ECSE 211 
+ * @date 06/10/2013
+ * 
+ * Light sensor localization
+ */
+
+public class LightLocalizer {
+	
+	private static final long CORRECTION_PERIOD = 10;
+	private Odometer odo;
+	private TwoWheeledRobot robot;
+	private ColorSensor lightSensor;
+	
+	//store light sensor values (for filtering purposes)
+	private List<Integer> lsValues = new ArrayList<Integer>();
+	
+	//the headings when a line is detected
+	private List<Double> angles = new ArrayList<Double>();
+	
+	// Keep track of whether we are on a line on not
+	private boolean onLine = false;
+	private int lineCount = 0;
+	
+	// tile size, light sensor offset
+	private final double TILE_SIZE = 30.48, LS_OFFSET = 12.8;
+	
+	/**
+	 * Light sensor localization constructor
+	 * @param odo
+	 * @param ls
+	 */
+	public LightLocalizer(Odometer odo, ColorSensor ls) {
+		this.odo = odo;
+		this.robot = odo.getTwoWheeledRobot();
+		this.lightSensor = ls;
+		
+		//for line detection
+		Sound.setVolume(50);
+		// turn on the light to red
+		ls.setFloodlight(0);
+		
+	}
+	
+	/**
+	 * do light sensor localization
+	 * finds x, y, theta to within 0.2cm, 1 deg
+	 */
+	public void doLocalization() {
+		// drive to location listed in tutorial
+		// start rotating and clock all 4 gridlines
+		// do trig to compute (0,0) and 0 degrees
+		// when done travel to (0,0) and turn to 0 degrees
+		
+		// travel to roughly -4cm, -4cm
+		odo.getNavigation().travelTo(-4.0,-4.0);
+		
+		//Initialize line count to 0
+		lineCount = 0;
+		
+		//clear angles array
+		angles.clear();
+		
+			
+		//ensures that we pass the lines in the same order every time | could be avoided with a more sophisticated calculation of thetaX and thetaY
+		if(odo.getTheta() > 80) {
+			odo.getNavigation().turnTo(45);
+		}
+				
+		//to mantain the correct CORRECTION_PERIOD
+		long correctionStart, correctionEnd;
+		
+		//line detection loop
+		while (lineCount < 4) {
+			correctionStart = System.currentTimeMillis();
+			
+			//sets robot to rotate at 35 deg/s
+			robot.setSpeeds(0, 35);
+			
+			//filters the light sensor information, and determines if a line was detected or not
+			detectLine(filterLightSensor());
+			
+			// this ensure the odometry correction occurs only once every period
+			correctionEnd = System.currentTimeMillis();
+			
+			if (correctionEnd - correctionStart < CORRECTION_PERIOD) {
+				try {
+					Thread.sleep(CORRECTION_PERIOD
+							- (correctionEnd - correctionStart));
+				} catch (InterruptedException e) {
+					// there is nothing to be done here because it is not
+					// expected that the odometry correction will be
+					// interrupted by another thread
+				}
+			}
+		}
+		
+		//stop robot
+		robot.setSpeeds(0, 0);
+		
+		//resets onLine
+		onLine = false;
+		
+		// calculates the angle spanned between the headings of the robot when the lines on the X and Y axes were detected respectively
+		double thetaX = angles.get(0) - angles.get(2);
+		double thetaY = angles.get(1) - angles.get(3);
+		
+		// Based on the above angles, the current x, y coordinates are calculated (assuming 0,0 is the closest intersection)
+		double x = -LS_OFFSET * Math.cos(Math.toRadians(thetaY/2.0));
+		double y = -LS_OFFSET * Math.cos(Math.toRadians(thetaX/2.0));
+		
+		// if the first detection was at a heading of between [0,60], we are not in the negative x,y region
+		// so invert y | x will be correctly inverted
+		if(angles.get(0) < 60) {
+			y = -y;
+		} 
+		
+		// we are not in the right stop to determine theta -> update current position (x,y) and then redo localization
+		if(x > 0 || y > 0) {
+			odo.setPosition(new double [] {x, y, odo.getTheta() }, new boolean [] {true, true, true});
+			doLocalization();
+		}
+		//localization was successful
+		else {
+			// calculate amount to adjust theta by, achieved through averaging the values for dTheta calculated on both the x and y axes
+			double dTheta = (439-thetaX/2.0-thetaY/2.0-angles.get(3)-angles.get(2))/2.0;
+			
+			//update our current position 
+			odo.setPosition(new double [] {x, y, odo.getTheta()+dTheta }, new boolean [] {true, true, true});
+		}
+		
+	}
+	
+	/**
+	 * Applys smoothing and differencing to the recorded values
+	 * detects when black line is detected and when the regular floor is detected again 
+	 */
+	public int filterLightSensor() {
+		
+		if(lsValues.size()<3) {
+			int value = lightSensor.getRawLightValue();
+			lsValues.add(value / 2);
+			return value;
+		} else {
+		
+			lsValues.add(lightSensor.getRawLightValue() / 2);
+			
+			int result;
+			
+			// Smooth and difference
+			result = /*-lsValues.get(0) - lsValues.get(1) +*/ lsValues.get(2) + lsValues.get(3);
+						
+			//shift values left by 1 for next iteration
+			lsValues.remove(0);
+			
+			return result;
+		}
+	}
+	
+	/**
+	 * when a line is detected, add it to the array of line detected angles
+	 */
+	public void lineDetected() {
+		angles.add(odo.getTheta());
+	}
+	
+	public void detectLine(int value) {
+		//if not currently on a line and filter result is less than -45 we just enter a line			
+			if(!onLine && value < -45) {
+				onLine = true;
+				
+				//go to line detection logic
+				lineDetected();
+				
+				//alert us with a beep that a line was detected
+				Sound.beep();
+				
+				lineCount++;
+				
+			} 
+			//if we are on a line and filter result > 45 we have now left the line
+			else if(onLine && value > 45) {
+				onLine = false;
+			}
+	}
+
+}
diff --git a/Group-15/Lab5-15/LightPoller.java b/Group-15/Lab5-15/LightPoller.java
new file mode 100644
index 0000000..1648902
--- /dev/null
+++ b/Group-15/Lab5-15/LightPoller.java
@@ -0,0 +1,131 @@
+import java.util.ArrayList;
+import java.util.List;
+
+import lejos.nxt.ColorSensor;
+import lejos.nxt.comm.RConsole;
+import lejos.util.Timer;
+import lejos.util.TimerListener;
+
+
+public class LightPoller implements TimerListener {
+
+	private static final int CORRECTION_PERIOD = 20;
+	
+	private ColorSensor ls;
+	
+	//store light sensor values (for filtering purposes)
+	private List<Integer> lsValues = new ArrayList<Integer>();
+	
+	private Timer lsTimer;
+	
+	private boolean started;
+	
+	private Object lock;
+	
+	private int floodLightColor = 0;
+
+	
+	public LightPoller(ColorSensor ls) {
+		this.ls = ls;
+		this.lsTimer = new Timer(CORRECTION_PERIOD, this);
+		this.lock = new Object();
+		ls.setFloodlight(floodLightColor);
+	}
+	
+	public void timedOut() {
+		
+		int value = ls.getRawLightValue();
+		RConsole.println(String.valueOf(value));
+		synchronized (lock) {
+			lsValues.add(value / 2);
+			
+			if(lsValues.size()>3) {	
+				lsValues.remove(0);
+			}
+		}
+	}
+	
+	public void start() {
+		if(!started) {
+			lsTimer.start();
+			started = true;
+		}		
+	}
+	
+	public void stop() {
+		if(started) {
+			lsTimer.stop();
+			started = false;
+		}
+	}
+	
+	public void setFloodLight(int color) {
+		//this.stop();
+		ls.setFloodlight(color);		
+		floodLightColor = color;
+		
+		while (ls.getRawLightValue() == -1) {
+			try {
+				Thread.sleep(250);
+			} catch (Exception e) {
+			}
+			RConsole.println(String.valueOf(ls.getFloodlight()));
+			ls.setFloodlight(color);
+		}
+		
+		synchronized (lock) {
+			lsValues.clear();
+		}
+		
+		//this.start();
+		
+	}
+	
+	public int differenceFilter() {
+		
+		int result;
+		
+		synchronized (lock) {
+			if(lsValues.size()<3) {
+				result =  lsValues.get(lsValues.size()-1);
+			} else {
+				// Smooth and difference
+				result =  -lsValues.get(0) - lsValues.get(1) + lsValues.get(2) + lsValues.get(3);
+			}
+		}
+		
+		return result;
+	}
+	
+	public int smoothingFilter() {
+		int result;
+		
+		synchronized (lock) {
+			if(lsValues.size() >= 4 ) {
+				// Smooth
+				result = lsValues.get(2) + lsValues.get(3);
+			} else if(lsValues.size() > 1) {
+				result =  lsValues.get(lsValues.size()-1) + lsValues.get(lsValues.size()-2);
+			} else if (lsValues.size() == 1) {
+				result = lsValues.get(0) * 2;
+			} else {
+				result = ls.getRawLightValue();
+			}
+		}
+		
+		return result;
+	}
+	
+	public int calibrateSensor() {
+		
+		setFloodLight(0);
+		
+		return smoothingFilter();		
+	}
+	
+	public int getLightValue() {
+		return ls.getRawLightValue();
+	}
+	
+	
+}
diff --git a/Group-15/Lab5-15/Navigation.java b/Group-15/Lab5-15/Navigation.java
new file mode 100644
index 0000000..c2829b8
--- /dev/null
+++ b/Group-15/Lab5-15/Navigation.java
@@ -0,0 +1,366 @@
+import lejos.nxt.comm.RConsole;
+
+
+/**
+ * 
+ * @project Lab 4 Localization 
+ * @names Riley van Ryswyk & Aditya Saha
+ * @studentID 260447357 & 260453165
+ * @group 15
+ * @course ECSE 211 
+ * @date 06/22/13
+ * 
+ * Navigation 
+ * 
+ */
+public class Navigation {
+
+	private Odometer odometer;
+	private TwoWheeledRobot robot;
+
+	// Update every 50ms
+	private static final long UPDATE_PERIOD = 50;
+
+	// Max speeds in cm/sec, deg/sec
+	private final int MAX_FORWARD_SPEED = 8;
+	private final int MAX_ROTATE_SPEED = 40;
+
+	// navigation variables
+	private static boolean navigating = false;
+	private static boolean turning = false;
+	private boolean paused = false;
+
+	public Navigation(Odometer odo) {
+		this.odometer = odo;
+		this.robot = odo.getTwoWheeledRobot();
+	}
+
+
+	/**
+	 * Method to travel to a set of Cartesian coordinates
+	 * @param x
+	 * @param y
+	 */
+	public void travelTo(double x, double y) {
+
+		// we're navigating
+		navigating = true;
+
+		long correctionStart, correctionEnd;
+
+		// main loop
+		travelLoop: while (navigating) {
+			correctionStart = System.currentTimeMillis();
+
+			if(!paused) {
+
+				/*
+				 * retrieve current position and calculate dX and dY
+				 */
+				double[] pos = new double[3];
+
+				odometer.getPosition(pos);
+
+				double currentX = pos[0];
+				double currentY = pos[1];
+				double currentTheta = pos[2];
+
+				// Distance between where we are and where we need to travel to
+				double dX = x - currentX;
+				double dY = y - currentY;
+
+				/*
+				 * if within 0.5cm (x&y) of the destination x,y stop otherwise
+				 * continuing traveling
+				 */
+				if (Math.abs(dX) < 1 && Math.abs(dY) < 1) {
+					navigating = false;
+					robot.stop();
+					break travelLoop;
+				}
+				/*
+				 * We are not at our destination and the path is clear
+				 */
+				else {
+
+					// the required theta to travel to our destination
+					double theta = Math.atan2(dY, dX) * 180.0 / Math.PI;
+					// adjust to [0, 360]
+					theta = (theta < 0) ? 360 + theta : theta;
+
+					// error in theta
+					double deltaTheta = theta - currentTheta;
+
+					// Change deltaTheta to [0,360)
+					if (deltaTheta > 180) {
+						deltaTheta -= 360;
+					} else if (deltaTheta < -180) {
+						deltaTheta += 360;
+					}
+
+					// see if we need to make a big turn
+					if (Math.abs(deltaTheta) > 5 ) {
+						// if we need to turn more than 0.2 rads or 0.1 for
+						// completing a turn, call the turnTo method
+						// otherwise we can adjust small angle errors by slowing one
+						// wheel down slightly
+						turnTo(theta);
+
+					}
+					// We need to go straight (or relatively straight)
+					else {
+
+						/*
+						 * For minor angle corrections
+						 */
+
+
+						// amount to change right wheel speed by
+						int dL = 0;
+
+
+						// If angle error is greater than 3 deg, make adjustment
+						if (Math.abs(deltaTheta) > 0.5) {
+
+							// if we are facing to the left of where we should be,
+							// slight right
+							if (deltaTheta > 0) {
+
+								dL = -5;
+							}
+
+							// if we are facing to the right of where we should be,
+							// slight left
+							else if (deltaTheta < 0) {
+
+								dL = 5;
+							}
+						}
+
+						/*
+						 * End minor angle corrections
+						 */
+
+						// Distance to destination
+						double distanceToTravel = (dX * Math.cos(Math.toRadians(currentTheta)))	+ (dY * Math.sin(Math.toRadians(currentTheta)));
+						// high speed
+						if (distanceToTravel > 3) {
+							robot.setSpeeds(MAX_FORWARD_SPEED, dL);
+						}
+						// start to slow down
+						else if (distanceToTravel > 1) {
+							robot.setSpeeds(MAX_FORWARD_SPEED / 2, dL);
+						}
+						// go really slow, so that we don't overshoot
+						else {
+							robot.setSpeeds(MAX_FORWARD_SPEED / 5, dL / 3);
+						}
+
+					}  
+				}  
+			} 
+			//paused
+			else {
+				robot.setSpeeds(0, 0);
+			}
+
+			// this ensure the odometry correction occurs only once every
+			// period
+
+
+			correctionEnd = System.currentTimeMillis();
+
+			if (correctionEnd - correctionStart < UPDATE_PERIOD) {
+				try {
+					Thread.sleep(UPDATE_PERIOD
+							- (correctionEnd - correctionStart));
+				} catch (InterruptedException e) {
+					// there is nothing to be done here because it is not
+					// expected that the odometry correction will be
+					// interrupted by another thread
+				}
+			}
+		}
+	}
+
+
+	/**
+	 * Orientents the robot to the specified angle
+	 * @param angle
+	 */
+	public void turnTo(double angle) {
+	
+		// we are turning
+		if (!turning)
+			turning = true;
+	
+		long correctionStart, correctionEnd;
+	
+		// main loop
+		while (turning) {
+			correctionStart = System.currentTimeMillis();
+	
+			if(!paused) {
+	
+				// error in angle
+				double deltaTheta = angle - odometer.getTheta();
+	
+				// convert to [-180,180] for minimal angle
+				if (deltaTheta > 180) {
+					deltaTheta -= 360;
+				} else if (deltaTheta < -180) {
+					deltaTheta += 360;
+				}
+	
+				// if angle error greater than 1 deg
+				if (Math.abs(deltaTheta) >= 1) {
+					// if error positive and greater than 5 deg -> max speed CCW
+					if (deltaTheta > 8) {
+						robot.setSpeeds(0, -MAX_ROTATE_SPEED);
+					}
+					// positive error, but close to 0, so turn slow CCW to prevent
+					// overshoot
+					else if (deltaTheta > 0) {
+						robot.setSpeeds(0, -MAX_ROTATE_SPEED / 4);
+					}
+					// error negative and less than 5deg -> max speed CW
+					else if (deltaTheta < -8) {
+						robot.setSpeeds(0, MAX_ROTATE_SPEED);
+					}
+					// negative error, but close to 0, so turn slow CW to prevent
+					// overshoot
+					else if (deltaTheta < 0) {
+						robot.setSpeeds(0, MAX_ROTATE_SPEED / 4);
+					}
+				} else {
+					// we have finished turning
+					turning = false;
+					robot.stop();
+				}
+			} 
+			//paused
+			else {
+				robot.setSpeeds(0, 0);
+			}
+			// this ensure the odometry correction occurs only once every period
+			correctionEnd = System.currentTimeMillis();
+	
+			if (correctionEnd - correctionStart < UPDATE_PERIOD) {
+				try {
+					Thread.sleep(UPDATE_PERIOD
+							- (correctionEnd - correctionStart));
+				} catch (InterruptedException e) {
+					// there is nothing to be done here because it is not
+					// expected that the odometry correction will be
+					// interrupted by another thread
+				}
+			}
+		}
+	
+	}
+
+	/**
+	 * backups the robot up along the current heading by a specific distance
+	 * @param distance
+	 */
+	public void backup(int distance) {
+		// we're navigating
+		navigating = true;
+	
+		long correctionStart, correctionEnd;
+	
+	
+		double[] pos = new double[3];
+	
+		odometer.getPosition(pos);
+	
+		double startX = pos[0];
+		double startY = pos[1];
+	
+		// main loop
+		travelLoop: while (navigating) {
+			correctionStart = System.currentTimeMillis();
+	
+			if(!paused) {
+				
+				/*
+				 * retrieve current position and calculate dX and dY
+				 */
+				
+				odometer.getPosition(pos);
+	
+				double currentX = pos[0];
+				double currentY = pos[1];
+	
+	
+				// Distance between where we are and where we need to travel to
+				double dX = currentX - startX;
+				double dY = currentY - startY;
+	
+				/*
+				 * if greater than the desired distance stop
+				 */
+				if (Math.pow(dX, 2) + Math.pow(dY, 2) > Math.pow(distance, 2)) {
+					navigating = false;
+					robot.stop();
+					break travelLoop;
+				}
+				/*
+				 * We are not at our destination so continue backing up
+				 */
+				else {
+					robot.setSpeeds(-MAX_FORWARD_SPEED/2, 0);
+				}
+			} 
+			//pause traveling
+			else {
+				robot.setSpeeds(0, 0);
+			}
+			// this ensure the odometry correction occurs only once every
+			// period
+			correctionEnd = System.currentTimeMillis();
+	
+			if (correctionEnd - correctionStart < UPDATE_PERIOD) {
+				try {
+					Thread.sleep(UPDATE_PERIOD
+							- (correctionEnd - correctionStart));
+				} catch (InterruptedException e) {
+					// there is nothing to be done here because it is not
+					// expected that the odometry correction will be
+					// interrupted by another thread
+				}
+			}
+		}
+	}
+	
+	
+	/**
+	 * Returns true if the robot is navigating or turning
+	 * @return
+	 */
+	public static boolean isNavigating() {
+		return navigating;
+	}
+	
+	/**
+	 * stop navigating
+	 * causes the travelloop to stop in each of the traveling methods
+	 */
+	public void stop() {
+		navigating = false;
+		turning = false;
+	}
+	
+	/*
+	 * pauses traveling
+	 */
+	public void pause() {
+		paused = true;
+	}
+	
+	//resumes traveling
+	public void resume() {
+		paused = false;
+	}
+
+}
diff --git a/Group-15/Lab5-15/ObjectFinding.java b/Group-15/Lab5-15/ObjectFinding.java
new file mode 100644
index 0000000..f2d478a
--- /dev/null
+++ b/Group-15/Lab5-15/ObjectFinding.java
@@ -0,0 +1,253 @@
+import lejos.nxt.comm.RConsole;
+
+/**
+ * 
+ * @project Lab 4 Localization 
+ * @names Riley van Ryswyk & Aditya Saha
+ * @studentID 260447357 & 260453165
+ * @group 15
+ * @course ECSE 211 
+ * @date 06/22/2013
+ * 
+ * Object Finding
+ * 
+ *  Contained within this class is the main loop for traversing the course while looking for the styrofoam block
+ *  
+ *  Initially a different approach was taken with regards to lab 5.  That method was to map the enclosure as it looked for the styrofoam block
+ *  this was eliminate due to time constraints (because of the previous strategies failing).    
+ * 
+ */
+public class ObjectFinding {
+	
+	//Objects to interact with other classes
+	private UltrasonicPoller usPoller;
+	private Odometer odo;
+	private ObjectRecognitionTwo ort;
+	private Navigation nav;
+	
+	/**
+	 * Constructor
+	 * @param usPoller
+	 * @param odo
+	 * @param ort
+	 */
+	public ObjectFinding(UltrasonicPoller usPoller, Odometer odo, ObjectRecognitionTwo ort) {
+		this.usPoller = usPoller;
+		this.odo = odo;
+		this.ort = ort;
+		this.nav = odo.getNavigation();
+
+	}
+	
+	
+	
+	/**
+	 * Find styrofoam loop
+	 * 
+	 * This method could have been implemented in a better manner, however, due to time constraints it was not possible
+	 */
+	public void findStyrofoam() {
+		
+		//travel to the start coordinates
+		nav.travelTo(70, 30);
+		
+		/*
+		 * Continue running until the robot has found the styrofoam
+		 */
+		while(!ort.getHaveStyrofoam()) {
+			
+			/*
+			 * Scans for objects ahead to know when to stop looking to the side (avoid crashing)
+			 * 
+			 * checks in 3 different offsets (left, center, right) in case the block is not directly ahead
+			 * 
+			 */
+			nav.turnTo(20);
+			usPoller.rotateUS(90);
+			int d1 = usPoller.scan();
+			
+			nav.turnTo(90);
+			usPoller.rotateUS(90);
+			int d2 = usPoller.scan();
+			
+			nav.turnTo(110);
+			usPoller.rotateUS(90);
+			int d3 = usPoller.scan();
+			
+			//return to previous orientation
+			nav.turnTo(90);
+			final int distanceToBlock;
+			//intiliaze yStart
+			int yStart = (int) odo.getY();
+			
+			//choose the smallest distance obtained
+			if( d1 < d2 && d1 < d3) {
+				distanceToBlock = d1+yStart;
+			} else if( d2 < d3 && d2 < d1) {
+				distanceToBlock = d2+yStart;
+			} else {
+				distanceToBlock = d3+yStart;
+			}
+			
+			//RConsole.println("distance to block " + String.valueOf(distanceToBlock));
+			
+			//initialize variables
+			int usLastValue = 256;
+			int usCurrentValue;
+			double y = odo.getY();
+			
+			int yEnd;
+			boolean start = false;
+
+			//rotate the ultrasonic to look to the left  
+			usPoller.rotateUS(180);
+			usPoller.clear();
+			
+			//start polling with timerlistner
+			usPoller.start();
+			
+			
+			//travel to the block ahead - 15cm
+			(new Thread() {
+				public void run() {
+					nav.travelTo(odo.getX(), distanceToBlock - 15);
+				}
+			}).start();
+		
+			/*
+			 * look to the left until we reach the block in front of us - 15cm
+			 */
+			while (y < distanceToBlock - 16) {
+				
+				//retrieve what the ultrasonic sensor is reading
+				usCurrentValue = usPoller.filterUS();
+				
+				//update the y coordinate
+				y = odo.getY();
+				//RConsole.println(String.valueOf(usCurrentValue));
+				
+				//don't do anything if this is the first time running (firsttime usLastValue ==256)
+				if(usLastValue != 256) {
+					
+					/*
+					 * we are reading something closer than before, and we have not detected a rising edge yet
+					 * thus the robot has found the first edge of the block
+					 */
+					if((usCurrentValue - usLastValue < -15) && !start) {
+						//store the starting y
+						yStart = (int) odo.getY();
+						start = true;
+						//RConsole.println(String.valueOf(usCurrentValue) + ";" + String.valueOf(usLastValue));
+					} 
+					/*
+					 * we are reading something farther than before, and we have detected a rising edge
+					 * thus the robot has found the last edge of the block
+					 */
+					else if((usLastValue - usCurrentValue < -15 || usLastValue == 255 ) && usCurrentValue != 255 && start) {
+						//store end coordinate
+						yEnd = (int) odo.getY();
+						//stop polling values
+						usPoller.stop();
+						//stop going forward, so we can inspect the block we have just found
+						nav.stop();
+						
+						//Sleep for a little while to ensure navigation stops
+						try {
+							Thread.sleep(100);
+						} catch (InterruptedException e) {
+							// TODO Auto-generated catch block
+							e.printStackTrace();
+						}
+						
+						//go to inspect method, which will inspect the block
+						ort.inspect(yStart, yEnd, usLastValue);
+						
+						//in case the block was not the styrofoam
+						if(!ort.getHaveStyrofoam()) {
+							
+							/*
+							 * reset to detect the next obstacle
+							 */
+							start = false;
+							usLastValue = 256;
+							
+							//resume traveling to the block in front of us
+							(new Thread() {
+								public void run() {
+									nav.travelTo(odo.getX(), distanceToBlock -15);
+								}
+							}).start();
+						}
+					}
+					
+				}
+				
+				//update usLastValue for the next iteration
+				usLastValue = usCurrentValue;
+				
+				//Make sure we don't run to often
+				try {
+					Thread.sleep(35);
+				} catch (InterruptedException e) {
+					// TODO Auto-generated catch block
+					e.printStackTrace();
+				}
+				
+			}
+			
+			/*
+			 * when we reach the block in front of us inspect it
+			 */
+			
+			nav.turnTo(90);
+			usPoller.rotateUS(90);
+			
+			//inspect the block
+			ort.inspect2(90);
+			boolean blocked = true;
+			
+			/*
+			 * this will move the robot to the left by one tile until the tile in front of it (at heading of 90deg) is clear
+			 * 
+			 * one imporvement that was not implemented would be to move the robot back to its inital x position after the block in front had been cleared
+			 */
+			while(blocked) {
+				//travel to one tile over
+				nav.travelTo(odo.getX() - 30, odo.getY());
+				
+				/*
+				 * inspect tile in front
+				 */
+				nav.turnTo(90);
+				
+				int angleAValue;
+				int angleBValue;
+				int angleCValue;
+				
+				//scan at three offsets to check left, middle, right
+				nav.turnTo(90 + 30);
+				usPoller.rotateUS(90 + 15);
+				angleAValue = usPoller.scan();
+				nav.turnTo(90);
+				usPoller.rotateUS(90);
+				angleBValue = usPoller.scan();
+				nav.turnTo(90 - 40);
+				usPoller.rotateUS(90);
+				angleCValue = usPoller.scan();
+				
+				//if the values report back as all greater than 60 we can travel in the +y direction again and continue the scanning
+				if(angleAValue > 60 && angleBValue > 60 && angleCValue > 60) {
+					blocked = false;
+					break;
+				}				
+				
+			}
+			
+			//returns to first loop
+		}		
+		
+		//Done
+		//RConsole.println("Done");
+	}
+
+}
diff --git a/Group-15/Lab5-15/ObjectRecognitionOne.java b/Group-15/Lab5-15/ObjectRecognitionOne.java
new file mode 100644
index 0000000..71dd963
--- /dev/null
+++ b/Group-15/Lab5-15/ObjectRecognitionOne.java
@@ -0,0 +1,217 @@
+import lejos.nxt.ColorSensor;
+import lejos.nxt.comm.RConsole;
+import lejos.util.Timer;
+import lejos.util.TimerListener;
+
+/**
+ * 
+ * @project Lab 4 Localization 
+ * @names Riley van Ryswyk & Aditya Saha
+ * @studentID 260447357 & 260453165
+ * @group 15
+ * @course ECSE 211 
+ * @date 06/22/2013
+ * 
+ * Object Recognition One (for part 1)
+ * 
+ *  The class is used to differentiate between the styrofoam block and wood block
+ * 
+ */
+
+public class ObjectRecognitionOne implements TimerListener {
+
+	private ColorSensor ls;
+	private UltrasonicPoller usPoller;
+	private TwoWheeledRobot robot;
+	private LCDInfo display;
+	private Timer oroTimer;
+	private int lastUSValue;
+	private boolean objectDetected;
+
+	private LCDInfo.BlockType object;
+	private int lsCalibration = -1;
+	private boolean typeDetected = false;
+	
+	/**
+	 * Object Recognition One Constructor
+	 * @param ls
+	 * @param usPoller
+	 * @param robot
+	 * @param display
+	 */
+	public ObjectRecognitionOne(ColorSensor ls, UltrasonicPoller usPoller, TwoWheeledRobot robot, LCDInfo display) {
+		this.ls = ls;
+		this.usPoller = usPoller;
+		this.robot = robot;
+		this.display = display;
+		this.lastUSValue = 256;
+		this.objectDetected = false;
+		this.oroTimer = new Timer(40, this);
+		ls.setFloodlight(0);
+	}
+	
+	/**
+	 * TimerListner loop
+	 * 
+	 * This method will cause the robot to travel forward if there is an object within 40cm and it will use the light sensor to reach an appropriate distance to check if the block is wood or styrofoam
+	 */
+	public void timedOut() {
+		
+		/*
+		 * ensures the ultrasonic poller has started
+		 */
+		if(lastUSValue < 256) {
+			//retrieve new ultrasonic poller value
+			int newUSValue = usPoller.filterUS();
+		
+			/*
+			 * if an object was detected earlier
+			 */
+			if(objectDetected) {
+				/*
+				 * if the us sensor reports a distance of more than 40, we no longer see the object
+				 */
+				if(newUSValue > 40) {
+					//reset variables and the lcd display + stop the robot from moving forward
+					objectDetected = false;
+					display.blockDetected(false);
+					display.type(LCDInfo.BlockType.NONE);
+					typeDetected = false;
+					robot.setSpeeds(0, 0);
+				} 
+				/*
+				 * the robot still sees the object and the type has not yet been distinguished
+				 */
+				else if(!typeDetected) {
+					
+					//get the current light sensor reading
+					int lsValue = ls.getRawLightValue();
+					
+					/*
+					 * if the difference is less than 5 the robot is far from the object, approach faster
+					 */
+					if(lsValue-lsCalibration < 5) {
+						robot.setSpeeds(6,0);
+					} 
+					
+					/*
+					 * if the difference 5 < d < 10 the robot is nearing the object, approach at half the speed
+					 */
+					else if(lsValue-lsCalibration < 10) {
+						robot.setSpeeds(3, 0);
+					} 
+					/*
+					 * if the difference is 10 < d < 20 the robot is close to the object, approach slowly
+					 */
+					else if(lsValue-lsCalibration < 20) {
+						robot.setSpeeds(1.5, 0);
+					} 
+					/*
+					 * the robot is close enough to take accurate light reading and make a decision
+					 */
+					else {
+						//stop moving
+						robot.setSpeeds(0, 0);
+						
+						//stop the timeOut timer
+						oroTimer.stop();
+						
+						//store the light sensor value when the floodlight is red
+						int redValue = lsValue;
+						
+						//change the floodlight to blue
+						ls.setFloodlight(2);
+						
+						//ensures the floodlight is set to blue before continuing
+						while(ls.getRawLightValue() == -1) {
+							try { Thread.sleep(50); } catch (InterruptedException e) {}
+						}
+						
+						//store the light sensor value when the floodlight is blue
+						int blueValue = ls.getRawLightValue();
+						
+						// if the difference between the red and blue is greater than 25, it is a wood block
+						// actually difference is ~100
+						if (redValue - blueValue > 25) {
+							object = LCDInfo.BlockType.WOOD;
+						} 
+						/*
+						 * otherwise it is a styrofoam block
+						 * difference between red and blue for styrofoam is <5
+						 */
+						else {
+							object = LCDInfo.BlockType.STYROFOAM;
+						}
+						
+						// show the type of block on the LCD
+						display.type(object);
+						
+						//reset the the floodlight to red
+						ls.setFloodlight(0);
+						
+						//ensures the floodlight is red
+						while(ls.getRawLightValue() == -1) {
+							try { Thread.sleep(50); } catch (InterruptedException e) {}
+						}	
+						
+						//type is detected
+						typeDetected = true;
+						
+						//start timeOut timer to check when the block is removed and when a new one is placed in front
+						oroTimer.start();
+						
+					}
+				}
+			}
+			/*
+			 * object is near, determine its type
+			 */
+			else if(newUSValue < 40) {
+				
+				objectDetected = true;
+				//show that a block was detected on the LCD
+				display.blockDetected(true);
+			}
+			
+		} 
+		/*
+		 * only for the inital running | makes sure the usPoller has started
+		 */
+		else {
+			lastUSValue = usPoller.filterUS();
+			
+		}
+	}
+	
+	/**
+	 * starts the timer for the timeOut loop
+	 */
+	public void start() {
+				
+		//starts the ultrasonic poller timer
+		usPoller.start();
+		
+		//set floodlight to red
+		ls.setFloodlight(0);
+		
+		//calibrates the light sensor (retrieves ambient light value)
+		while (lsCalibration < 0) {
+			lsCalibration = ls.getRawLightValue();
+			try { Thread.sleep(50); } catch (InterruptedException e) {}
+		}
+		
+		//start the timer
+		oroTimer.start();
+
+	}
+	
+	/**
+	 * stops the timeOut timer
+	 */
+	public void stop() {
+		oroTimer.stop();
+	}
+	
+	
+	
+}
diff --git a/Group-15/Lab5-15/ObjectRecognitionTwo.java b/Group-15/Lab5-15/ObjectRecognitionTwo.java
new file mode 100644
index 0000000..5413eaa
--- /dev/null
+++ b/Group-15/Lab5-15/ObjectRecognitionTwo.java
@@ -0,0 +1,399 @@
+import lejos.nxt.ColorSensor;
+import lejos.nxt.Sound;
+import lejos.nxt.comm.RConsole;
+import lejos.util.Timer;
+import lejos.util.TimerListener;
+
+/**
+ * 
+ * @project Lab 4 Localization 
+ * @names Riley van Ryswyk & Aditya Saha
+ * @studentID 260447357 & 260453165
+ * @group 15
+ * @course ECSE 211 
+ * @date 06/22/2013
+ * 
+ * Object Recognition Two (for part 2)
+ * 
+ *  The class is used to differentiate between the styrofoam block and wood block
+ * 
+ */
+
+public class ObjectRecognitionTwo implements TimerListener {
+
+	/*
+	 * Objects to interact with other classes
+	 */
+	private ColorSensor ls;
+	private UltrasonicPoller usPoller;
+	private TwoWheeledRobot robot;
+	private Navigation nav;
+	private Odometer odo;
+	private Timer oroTimer;
+	private boolean objectDetected;
+
+	//light sensor calibration value -> ambient light returned
+	private int lsCalibration = -1;
+	// true if the type has been determined
+	private boolean typeDetected = false;
+	// true if the robot is detecting in the timeOut method
+	private boolean detecting = false;
+	// true if the robot has the styrofoam block 
+	private boolean haveStyrofoam = false;
+	//true if lineing up the robot in inspect2()
+	private boolean inspecting = false;
+	
+	/**
+	 * object recongnition two constructor
+	 * @param ls
+	 * @param usPoller
+	 * @param robot
+	 * @param display
+	 * @param odo
+	 */
+	public ObjectRecognitionTwo(ColorSensor ls, UltrasonicPoller usPoller, TwoWheeledRobot robot, Odometer odo) {
+		this.ls = ls;
+		this.usPoller = usPoller;
+		this.robot = robot;
+		this.objectDetected = false;
+		this.odo = odo;
+		this.nav = new Navigation(odo);
+		
+		//set timer to 40 ms
+		this.oroTimer = new Timer(40, this);
+		//set volume level
+		Sound.setVolume(60);
+	}
+	
+	/**
+	 * returns the current light sensor value referenced to the calibration point
+	 * @return
+	 */
+	public int getLSValue() {
+		return ls.getRawLightValue() - lsCalibration;
+	}
+	
+	
+	/**
+	 * TimerListner loop
+	 * 
+	 * This method will cause the robot to travel forward if there is an object within 40cm and it will use the light sensor to reach an appropriate distance to check if the block is wood or styrofoam
+	 */
+	public void timedOut() {
+		
+		/*
+		 * make sure the floodlight is set to red
+		 */
+		if(ls.getFloodlight() != 0) {
+			ls.setFloodlight(0);
+			
+			//In cases when the floodlight fails to change right away
+			while(ls.getRawLightValue() == -1) {
+				try { Thread.sleep(50); } catch (InterruptedException e) {}
+			}
+		}
+		
+		// poll the us sensor for the new reading
+		int newUSValue = usPoller.filterUS();
+		
+		/*
+		 * the object has been detected (us reading of less than 40cm)
+		 */
+		if(objectDetected) {
+			/*
+			 * if us > 40, we probably are not lined up correctly
+			 * 
+			 * all variables will be reset and the timer is stopped
+			 * this will return to the method that called this one (inspect2(), which will then line up the robot) 
+			 */
+			if(newUSValue > 40) {
+				objectDetected = false;
+				typeDetected = false;
+				robot.setSpeeds(0, 0);
+				detecting = false;
+				stop();
+			/*
+			 * if the type has not yet been detected, move forward so that a good light sensor reading can be taken
+			 */
+			} else if(!typeDetected) {
+				
+				// retrieve the current light value
+				int lsValue = ls.getRawLightValue();
+				
+				/*
+				 * if the difference is less than 5 the robot is far from the object, approach faster
+				 */
+				if(lsValue-lsCalibration < 5) {
+					robot.setSpeeds(2.5,0);
+				} 
+				/*
+				 * the robot is close, slow down
+				 */
+				else if(lsValue-lsCalibration < 40) {
+					robot.setSpeeds(1.5, 0);
+				} 
+				/*
+				 * the robot is close enough to take accurate light reading and make a decision
+				 */
+				else {
+					
+					//stop moving
+					robot.setSpeeds(0, 0);
+					//stop the timer
+					oroTimer.stop();
+					
+					//store the reading with the red flood light on
+					int redValue = lsValue;
+					
+					// set the floodlight to blue
+					ls.setFloodlight(2);
+					
+					//wait till the floodlight is actually changed to blue
+					while(ls.getRawLightValue() == -1) {
+						try { Thread.sleep(50); } catch (InterruptedException e) {}
+					}
+					
+					//store the reading with the blue flood light on
+					int blueValue = ls.getRawLightValue();
+					
+					// if the difference between the red and blue is greater than 25, it is a wood block
+					// actually difference is ~100
+					if (redValue - blueValue > 25) {
+					
+						Sound.beep();
+						Sound.buzz();
+						
+						//backup 10cm
+						nav.backup(10);
+					} 
+					/*
+					 * otherwise it is a styrofoam block
+					 * difference between red and blue for styrofoam is <5
+					 */
+					else {
+						
+						Sound.beep();
+						haveStyrofoam = true;
+						//capture the styrofoam block
+						capture();
+						
+					}
+					
+					// reset the floodlight to red
+					ls.setFloodlight(0);
+					//ensure it is actually red before continuing
+					while(ls.getRawLightValue() == -1) {
+						try { Thread.sleep(50); } catch (InterruptedException e) {}
+					}
+					
+					//reset variables to exit inspecting loops
+					typeDetected = false;
+					inspecting = false;
+					detecting = false;
+					
+				}
+			}
+		}
+		/*
+		 * the US is reading a value < 40 and block has not been detected -> block detectee
+		 */
+		else if(newUSValue < 40) {
+			objectDetected = true;
+		}
+			
+	}
+	
+	/*
+	 * starts the timer for the timeOut loop
+	 */
+	public void start() {
+		//we are detecting
+		detecting = true;
+		
+		//starts the ultrasonic poller timer
+		usPoller.start();
+		
+		//set floodlight to red
+		ls.setFloodlight(0);
+		
+		//calibrates the light sensor (retrieves ambient light value)
+		while (lsCalibration < 0) {
+			lsCalibration = ls.getRawLightValue();
+			try { Thread.sleep(50); } catch (InterruptedException e) {}
+		}
+		
+		//start the timer
+		oroTimer.start();
+
+	}
+	
+	/*
+	 * stop the timer
+	 */
+	public void stop() {
+		oroTimer.stop();
+	}
+	
+	/**
+	 * Inspect Method drives the robot to about 15cm from the object, 
+	 * calls inspect2() to inspect the object, 
+	 * and then if the object is not the styrofoam block
+	 * returns the robot to its original position
+	 * 
+	 * @param yStart
+	 * @param yEnd
+	 * @param distanceToBlock
+	 */
+	public void inspect(int yStart, int yEnd, int distanceToBlock) {
+		
+		//store starting coordinates
+		double xOriginal = odo.getX();
+		double yOriginal = odo.getY();
+		
+		//backup to the middle of the object
+		nav.backup(Math.abs(yEnd - yStart) / 2 );
+		
+		//turn to face the object
+		nav.turnTo(180);
+		usPoller.rotateUS(170);
+		
+		//scan the object for the distance
+		int distanceToObject = usPoller.scan();
+		
+		//take the minimum of the distance to the object as reported by the findStyrofoam loop or the one just measured
+		if(distanceToObject > distanceToBlock + 5) {
+			distanceToObject = distanceToBlock;
+		}
+		
+		//travel to the object - 15cm
+		nav.travelTo(odo.getX() - distanceToObject + 15, odo.getY());
+		
+		//line up the robot to the object and inspect to see if it is styrofoam or wood
+		inspect2(180);
+		
+		// if the object was a wood block return to the original coordinates to continue looking for blocks
+		if(!getHaveStyrofoam()) {
+			nav.travelTo(xOriginal, yOriginal);
+			nav.turnTo(90);
+			usPoller.rotateUS(180);
+		}
+		
+	}
+	
+	/**
+	 * inspect2 will line up the robot to the block and
+	 * then start the timeOut loop to determine what the object is
+	 * @param heading
+	 */
+	public void inspect2(int heading) {
+		inspecting  = true;
+		
+		/*
+		 * main loop
+		 */
+		while(inspecting) {
+			
+			//measure the distance to the object at 3 offsets left, center, right
+			int angleAValue;
+			int angleBValue;
+			int angleCValue;
+			
+			nav.turnTo(heading + 40);
+			usPoller.rotateUS(heading + 10);
+			angleAValue = usPoller.scan();
+			
+			nav.turnTo(heading);
+			usPoller.rotateUS(heading);
+			angleBValue = usPoller.scan();
+			
+			nav.turnTo(heading - 40);
+			usPoller.rotateUS(heading);
+			angleCValue = usPoller.scan();
+			
+			/*
+			 * if oriented along the y axis, 
+			 * adjust the robots x position
+			 */
+			if (Math.abs(Math.sin(Math.toRadians(heading))) > 0.95) {
+				//initialize current x
+				int x = (int) odo.getX();
+				//if the reading to the right was bigger than the left move to the left
+				if(angleCValue - angleAValue > 10 ) {
+					x -= 5;
+				} 
+				// if the reading on the left was bigger than the reading on the right move to the right
+				else if (angleCValue - angleAValue < -10 ) {
+					x+= 5;
+				}
+				//travel to adjusted position				
+				nav.travelTo(x, odo.getY());
+			} 
+			/*
+			 * if oriented along the x axis
+			 * adjust the robots y position
+			 */
+			else {
+				//initialize current y position
+				int y = (int) odo.getY();
+				
+				// if the reading to the right is was bigger than the reading to the left, go to the left
+				if(angleCValue - angleAValue > 10 ) {
+					y -= 5;
+				} 
+				// if the reading to the left was bigger than the reading to the right, go right
+				else if (angleCValue - angleAValue < -10 ) {
+					y+= 5;
+				}
+				
+				//travel to adjusted position			
+				nav.travelTo(odo.getX(), y);
+			}
+			
+			//correct the heading of the robot and ultrasonic
+			nav.turnTo(heading);
+			usPoller.rotateUS(heading);
+			
+			/*
+			 * if the us reading is less than 40, the robot is good to move on to the light sensor part of object recognition
+			 */
+			if(usPoller.scan() < 40) {
+				usPoller.rotateUS(heading-10);
+				//start the timeOut timer -> do light sensor recognition
+				start();
+				
+				//while still detecting wait
+				while(detecting) {
+					try{
+						Thread.sleep(200);
+					} catch(Exception e) {
+						
+					}
+				}
+			}
+		}
+
+	}
+	
+	/**
+	 * returns true if the styrofoam block has been captured
+	 * @return
+	 */
+	public boolean getHaveStyrofoam() {
+		return haveStyrofoam;
+	}
+	
+	
+	/**
+	 * Attempt to capture the styrofoam block
+	 */
+	public void capture() {
+		//travel forward 5cm
+		nav.travelTo(odo.getX() - 5, odo.getY());
+		//turn around to scoop the block
+		nav.turnTo(330);
+		//travel to the end destination
+		nav.travelTo(odo.getX(), 165);
+		nav.travelTo(70, 190);
+	}
+	
+}
diff --git a/Group-15/Lab5-15/Odometer.java b/Group-15/Lab5-15/Odometer.java
new file mode 100644
index 0000000..4657f62
--- /dev/null
+++ b/Group-15/Lab5-15/Odometer.java
@@ -0,0 +1,205 @@
+import lejos.util.Timer;
+import lejos.util.TimerListener;
+/**
+ * 
+ * @project Lab 4 Localization 
+ * @names Riley van Ryswyk & Aditya Saha
+ * @studentID 260447357 & 260453165
+ * @group 15
+ * @course ECSE 211 
+ * @date 06/22/2013
+ * 
+ * Odometer (provided)
+ * changed the way theta is defined (now 0 along +x axis and increases CCW)
+ */
+public class Odometer implements TimerListener {
+	public static final int DEFAULT_PERIOD = 25;
+	private TwoWheeledRobot robot;
+	private Timer odometerTimer;
+	private Navigation nav;
+	// position data
+	private Object lock;
+	private double x, y, theta;
+	private double [] oldDH, dDH;
+	
+	/**
+	 * Odometer constructor
+	 * @param robot
+	 * @param period
+	 * @param start
+	 */
+	public Odometer(TwoWheeledRobot robot, int period, boolean start) {
+		// initialise variables
+		this.robot = robot;
+		this.nav = new Navigation(this);
+		odometerTimer = new Timer(period, this);
+		x = 0.0;
+		y = 0.0;
+		theta = 90.0;
+		oldDH = new double [2];
+		dDH = new double [2];
+		lock = new Object();
+		
+		// start the odometer immediately, if necessary
+		if (start)
+			odometerTimer.start();
+	}
+	/**
+	 * Odometer constructor
+	 * @param robot
+	 */
+	public Odometer(TwoWheeledRobot robot) {
+		this(robot, DEFAULT_PERIOD, false);
+	}
+	/**
+	 * Odometer constructor
+	 * @param robot
+	 * @param start
+	 */
+	public Odometer(TwoWheeledRobot robot, boolean start) {
+		this(robot, DEFAULT_PERIOD, start);
+	}
+	/**
+	 * Odometer Constructor
+	 * @param robot
+	 * @param period
+	 */
+	public Odometer(TwoWheeledRobot robot, int period) {
+		this(robot, period, false);
+	}
+	
+	/**
+	 * Update loop
+	 * 
+	 * Finds change in motors tacho count and then updates x,y,theta correspondingly 
+	 */
+	public void timedOut() {
+		robot.getDisplacementAndHeading(dDH);
+		//change in displacement and heading
+		dDH[0] -= oldDH[0];
+		dDH[1] -= oldDH[1];
+		
+		// update the position in a critical region
+		synchronized (lock) {
+			theta -= dDH[1];
+			theta = fixDegAngle(theta);
+			
+			x += dDH[0] * Math.cos(Math.toRadians(theta));
+			y += dDH[0] * Math.sin(Math.toRadians(theta));
+		}
+		
+		//update old displacement and heading
+		oldDH[0] += dDH[0];
+		oldDH[1] += dDH[1];
+		
+	}
+	
+	/**
+	 * returns position
+	 * @param pos
+	 */
+	public void getPosition(double [] pos) {
+		synchronized (lock) {
+			pos[0] = x;
+			pos[1] = y;
+			pos[2] = theta;
+		}
+	}
+	
+	/**
+	 * returns theta
+	 * @return
+	 */
+	public double getTheta() {
+		double result;
+
+		synchronized (lock) {
+			result = theta;
+		}
+
+		return result;
+	}
+	
+	/**
+	 * returns y
+	 * @return
+	 */
+	public double getY() {
+		double result;
+
+		synchronized (lock) {
+			result = y;
+		}
+
+		return result;
+	}
+	
+	/**
+	 * returns x
+	 * @return
+	 */
+	public double getX() {
+		double result;
+
+		synchronized (lock) {
+			result = x;
+		}
+
+		return result;
+	}
+	
+	/**
+	 * returns TwoWheeledRobot
+	 * @return
+	 */
+	public TwoWheeledRobot getTwoWheeledRobot() {
+		return robot;
+	}
+	
+	/**
+	 * returns navigation object
+	 * @return
+	 */
+	public Navigation getNavigation() {
+		return this.nav;
+	}
+	
+	/**
+	 * set the current position
+	 * @param pos
+	 * @param update
+	 */
+	public void setPosition(double [] pos, boolean [] update) {
+		synchronized (lock) {
+			if (update[0]) x = pos[0];
+			if (update[1]) y = pos[1];
+			if (update[2]) theta = pos[2];
+		}
+	}
+	
+	/**
+	 * Ensures angle is always in [0,360)
+	 * @param angle
+	 * @return
+	 */
+	public static double fixDegAngle(double angle) {		
+		if (angle < 0.0)
+			angle = 360.0 + (angle % 360.0);
+		
+		return angle % 360.0;
+	}
+	/**
+	 * returns the minimum angle
+	 * @param a
+	 * @param b
+	 * @return
+	 */
+	public static double minimumAngleFromTo(double a, double b) {
+		double d = fixDegAngle(b - a);
+		
+		if (d < 180.0)
+			return d;
+		else
+			return d - 360.0;
+	}
+}
diff --git a/Group-15/Lab5-15/TwoWheeledRobot.java b/Group-15/Lab5-15/TwoWheeledRobot.java
new file mode 100644
index 0000000..4303fbe
--- /dev/null
+++ b/Group-15/Lab5-15/TwoWheeledRobot.java
@@ -0,0 +1,165 @@
+import lejos.nxt.NXTRegulatedMotor;
+import lejos.nxt.comm.RConsole;
+/**
+ * 
+ * @project Lab 4 Localization 
+ * @names Riley van Ryswyk & Aditya Saha
+ * @studentID 260447357 & 260453165
+ * @group 15
+ * @course ECSE 211 
+ * @date 06/10/2013
+ * 
+ * TwoWheeledRobot (provided)
+ * added stop method
+ * limited motor acceleration
+ * and changed robot parameters
+ */
+public class TwoWheeledRobot {
+	public static final double DEFAULT_LEFT_RADIUS = 2.11;
+	public static final double DEFAULT_RIGHT_RADIUS = 2.11;
+	public static final double DEFAULT_WIDTH = 14.92;
+	private NXTRegulatedMotor leftMotor, rightMotor;
+	private double leftRadius, rightRadius, width;
+	private double forwardSpeed, rotationSpeed;
+	
+	/**
+	 * Constructor
+	 * @param leftMotor
+	 * @param rightMotor
+	 * @param width
+	 * @param leftRadius
+	 * @param rightRadius
+	 */
+	public TwoWheeledRobot(NXTRegulatedMotor leftMotor,
+						   NXTRegulatedMotor rightMotor,
+						   double width,
+						   double leftRadius,
+						   double rightRadius) {
+		this.leftMotor = leftMotor;
+		this.rightMotor = rightMotor;
+		this.leftRadius = leftRadius;
+		this.rightRadius = rightRadius;
+		this.width = width;
+		leftMotor.setAcceleration(1000);
+		rightMotor.setAcceleration(1000);
+		leftMotor.resetTachoCount();
+		rightMotor.resetTachoCount();
+	}
+	/**
+	 * Constructor
+	 * @param leftMotor
+	 * @param rightMotor
+	 */
+	public TwoWheeledRobot(NXTRegulatedMotor leftMotor, NXTRegulatedMotor rightMotor) {
+		this(leftMotor, rightMotor, DEFAULT_WIDTH, DEFAULT_LEFT_RADIUS, DEFAULT_RIGHT_RADIUS);
+	}
+	/**
+	 * Constructor
+	 * @param leftMotor
+	 * @param rightMotor
+	 * @param width
+	 */
+	public TwoWheeledRobot(NXTRegulatedMotor leftMotor, NXTRegulatedMotor rightMotor, double width) {
+		this(leftMotor, rightMotor, width, DEFAULT_LEFT_RADIUS, DEFAULT_RIGHT_RADIUS);
+	}
+	
+	/**
+	 * Returns displacement based on TachoMeter count
+	 * @return
+	 */
+	public double getDisplacement() {
+		return (leftMotor.getTachoCount() * leftRadius +
+				rightMotor.getTachoCount() * rightRadius) *
+				Math.PI / 360.0;
+	}
+	/**
+	 *  returns heading based on tachoMeter count
+	 * @return
+	 */
+	public double getHeading() {
+		return (leftMotor.getTachoCount() * leftRadius -
+				rightMotor.getTachoCount() * rightRadius) / width;
+	}
+	/**
+	 * returns displacement and heading based on tacho counts -> passed through the data array pointer
+	 * @param data
+	 */
+	public void getDisplacementAndHeading(double [] data) {
+		int leftTacho, rightTacho;
+		leftTacho = leftMotor.getTachoCount();
+		rightTacho = rightMotor.getTachoCount();
+		
+		data[0] = (leftTacho * leftRadius + rightTacho * rightRadius) *	Math.PI / 360.0;
+		data[1] = (leftTacho * leftRadius - rightTacho * rightRadius) / width;
+	}
+	
+	/**
+	 * Sets forward robot speed (cm/s)
+	 * @param speed
+	 */
+	public void setForwardSpeed(double speed) {
+		forwardSpeed = speed;
+		setSpeeds(forwardSpeed, rotationSpeed);
+	}
+	
+	/**
+	 * sets rotational speed (deg/s)
+	 * @param speed
+	 */
+	public void setRotationSpeed(double speed) {
+		rotationSpeed = speed;
+		setSpeeds(forwardSpeed, rotationSpeed);
+	}
+	
+	/**
+	 * Sets both forward and rotational speed (cm/s, deg/s)
+	 * @param forwardSpeed
+	 * @param rotationalSpeed
+	 */
+	public void setSpeeds(double forwardSpeed, double rotationalSpeed) {
+		double leftSpeed, rightSpeed;
+
+		this.forwardSpeed = forwardSpeed;
+		this.rotationSpeed = rotationalSpeed; 
+
+		leftSpeed = (forwardSpeed + rotationalSpeed * width * Math.PI / 360.0) *
+				180.0 / (leftRadius * Math.PI);
+		rightSpeed = (forwardSpeed - rotationalSpeed * width * Math.PI / 360.0) *
+				180.0 / (rightRadius * Math.PI);
+
+		
+		// set motor directions
+		if (leftSpeed > 0.0)
+			leftMotor.forward();
+		else {
+			leftMotor.backward();
+			leftSpeed = -leftSpeed;
+		}
+		
+		if (rightSpeed > 0.0)
+			rightMotor.forward();
+		else {
+			rightMotor.backward();
+			rightSpeed = -rightSpeed;
+		}
+		
+		// set motor speeds
+		if (leftSpeed > 900.0)
+			leftMotor.setSpeed(900);
+		else
+			leftMotor.setSpeed((int)leftSpeed);
+		
+		if (rightSpeed > 900.0)
+			rightMotor.setSpeed(900);
+		else
+			rightMotor.setSpeed((int)rightSpeed);
+	}
+	
+	/**
+	 * Stops robot
+	 */
+	public void stop() {
+		rightMotor.stop(true);
+		leftMotor.stop();
+	}
+}
diff --git a/Group-15/Lab5-15/USLocalizer.java b/Group-15/Lab5-15/USLocalizer.java
new file mode 100644
index 0000000..0cb4b6e
--- /dev/null
+++ b/Group-15/Lab5-15/USLocalizer.java
@@ -0,0 +1,354 @@
+import java.util.ArrayList;
+import java.util.List;
+
+import lejos.nxt.Motor;
+import lejos.nxt.Sound;
+import lejos.nxt.UltrasonicSensor;
+import lejos.nxt.comm.RConsole;
+
+/**
+ * 
+ * @project Lab 4 Localization 
+ * @names Riley van Ryswyk & Aditya Saha
+ * @studentID 260447357 & 260453165
+ * @group 15
+ * @course ECSE 211 
+ * @date 06/22/2013
+ * 
+ * Ultrasonic Localization
+ * Accurate to within ~3degs
+ */
+
+public class USLocalizer {
+	
+	//Types of localization
+	public enum LocalizationType { FALLING_EDGE, RISING_EDGE };
+	
+	//Speed in deg/sec of which to rotate during localization
+	public static double ROTATION_SPEED = 30;
+	
+	//period to check ultrasonic sensor in ms
+	public final int UPDATE_PERIOD = 30;
+	
+	//threshold distance in cm, to determine if we are at a critical angle
+	public final int THRESHOLD = 30;
+	
+	//Objects for interaction with other classes
+	private Odometer odo;
+	private TwoWheeledRobot robot;
+	private UltrasonicPoller usPoller;
+	private LocalizationType locType;
+	private Navigation nav;
+	
+	// Store list of previous ultrasonic sensor values for filtering
+	private List<Integer> usValues = new ArrayList<Integer>();
+	
+	// Store list of previous ultrasonic sensor values for filtering
+	private int usLastValue = 40;
+	
+	/**
+	 * Ultrasonic sensor class constructor
+	 * @param odo
+	 * @param us
+	 * @param locType
+	 */
+	public USLocalizer(Odometer odo, UltrasonicPoller usPoller, LocalizationType locType) {
+		this.odo = odo;
+		this.robot = odo.getTwoWheeledRobot();
+		this.usPoller = usPoller;
+		this.locType = locType;
+		this.nav = odo.getNavigation();
+		
+		// switch off the ultrasonic sensor
+		//us.off();
+	}
+	
+	/**
+	 * Carrys out Ultrasonic localization
+	 */
+	public void doLocalization() {
+		
+		//to feed to odometer
+		double [] pos = new double [3];
+		
+		// Critical angles (when wall is detected/not detected
+		double angleA = -1, angleB = -1;
+		
+		//amount to adjust the heading by
+		double deltaTheta = 0;
+		
+		//to ensure we run only once an UPDATE_PERIOD
+		long correctionStart, correctionEnd;
+		
+		// to prevent errors when changing directions
+		int BDelay = 0;
+		
+		usPoller.start();
+		
+		//Fill the array of usValues with the current reading of the ultrasonic sensor
+		try {
+			Thread.sleep(4*35);
+		} catch (InterruptedException e) {
+			// there is nothing to be done here because it is not
+			// expected that the odometry correction will be
+			// interrupted by another thread
+		}
+		
+		/*getFilteredData();
+		getFilteredData();
+		getFilteredData();
+		getFilteredData();*/
+		
+		/*
+		 * Falling edge detected (no wall -> wall)
+		 * 
+		 * 	rotate the robot until it sees no wall
+		 *  keep rotating until the robot sees a wall, then latch the angle
+		 *  switch direction and wait until it sees no wall
+		 *  keep rotating until the robot sees a wall, then latch the angle
+		 */
+		if (locType == LocalizationType.FALLING_EDGE) {
+			
+			//to keep track of whether we were facing a wall or not
+			boolean noWall = false;
+			
+			//Localization loop
+			locloop: 
+				while(true) {
+				
+				correctionStart = System.currentTimeMillis();
+				
+				//set the direction of rotation, once angleA is found it will be >0
+				if(angleA < 0) {
+					robot.setSpeeds(0, 40);
+				} else {
+					robot.setSpeeds(0, -40);
+					
+					//prevent detection of same wall/no wall barrier 
+					BDelay++;
+				}
+				
+				//retrieve the value of the filtered Ultrasonic data
+				int distance = usPoller.filterUS();
+				
+				//We were seeing a wall and the distance is greater than the threshold -> we are not seeing a wall
+				if(!noWall && distance > THRESHOLD) {
+					
+					//update noWall
+					noWall = true;
+				} 
+				// we are not seeing a wall, haven't detected angleA and distance less than threshold -> we have found angleA
+				else if(noWall && angleA < 0 && distance < THRESHOLD) {
+					
+					//set angleA
+					angleA = odo.getTheta();
+					
+					//reset noWall
+					noWall = false;					
+				} 
+				//if we are not seeing a wall, and haven't detected angleB, the distance is less than the threshold and the delay since detecting angleA is greater than 50 iterations -> we have found angleB
+				else if(noWall && angleB < 0 && distance < THRESHOLD && BDelay > 50) {
+					
+					//set angleB
+					angleB = odo.getTheta();
+					
+					//Stop robot
+					robot.setSpeeds(0, 0);
+					
+					//break the us localization loop
+					break locloop;
+				}
+				
+				// this ensure the odometry correction occurs only once every period
+				correctionEnd = System.currentTimeMillis();
+				
+				if (correctionEnd - correctionStart < UPDATE_PERIOD) {
+					try {
+						Thread.sleep(UPDATE_PERIOD - (correctionEnd - correctionStart));
+					} catch (InterruptedException e) {
+						// there is nothing to be done here because it is not
+						// expected that the odometry correction will be
+						// interrupted by another thread
+					}
+				}
+				
+			}
+			
+			//first part of deltaTheta, the negative average of <A and <B
+			deltaTheta = -(angleA + angleB) / 2;
+			
+			//Depending on what angle is bigger, offset deltaTheta to the correct amount
+			if(angleA > angleB) {
+				deltaTheta += 214;
+			} else {
+				deltaTheta += 34;
+			}
+		} 
+		
+		/*
+		 * Rising Edge Detection
+		 * 
+		 * The robot should turn until it sees the wall, then look for the
+		 * "rising edges:" the points where it no longer sees the wall.
+		 * This is very similar to the FALLING_EDGE routine, but the robot
+		 * will face toward the wall for most of it.
+		 */
+		
+		else {
+			
+			// true if we are facing a wall
+			boolean wall = false;
+			
+			//localization loop
+			locloop: 
+				while(true) {
+				
+				correctionStart = System.currentTimeMillis();
+				
+				//Set speed of robot depending on whether we have detected angleA 
+				if(angleA < 0) {
+					robot.setSpeeds(0, 40);
+				} else {
+					robot.setSpeeds(0, -40);
+					//prevent incorrect detection of angleB (ie right after angleA has been detected)
+					BDelay++;
+				}
+				
+				//get filtered Ultrasonic data
+				int distance = usPoller.filterUS();
+				
+				//if no wall and distance less than threshold -> we are seeing a wall
+				if(!wall && distance < THRESHOLD) {
+					wall = true;
+				} 
+				//if we were seeing a wall, angleA is not set and distance > threshold -> we have angleA
+				else if(wall && angleA < 0 && distance > THRESHOLD) {
+					
+					//set AngleA
+					angleA = odo.getTheta();
+					
+					//reset wall
+					wall = false;					
+					
+				} 
+				//if we were seeing a wall, angleB is not set, distance > threshold, and it has been more than 50 iterations since detecting angleA - > we have angleB
+				else if(wall && angleB < 0 && distance > THRESHOLD && BDelay > 50) {
+					
+					//set angleB
+					angleB = odo.getTheta();
+					
+					//stop robot
+					robot.setSpeeds(0, 0);
+					
+					//break the localization loop
+					break locloop;
+				}
+				
+				// this ensure the odometry correction occurs only once every period
+				correctionEnd = System.currentTimeMillis();
+				
+				if (correctionEnd - correctionStart < UPDATE_PERIOD) {
+					try {
+						Thread.sleep(UPDATE_PERIOD - (correctionEnd - correctionStart));
+					} catch (InterruptedException e) {
+						// there is nothing to be done here because it is not
+						// expected that the odometry correction will be
+						// interrupted by another thread
+					}
+				}
+				
+			}
+			
+			//first part of deltaTheta, the negative average of <A and <B
+			deltaTheta = -(angleA + angleB) / 2;
+			
+			//Depending on what angle is bigger, offset deltaTheta to the correct amount
+			if(angleB > angleA) {
+				deltaTheta += 228;
+			} else {
+				deltaTheta += 48;
+			}
+		}
+	
+		// initalize our position to x=-14, y=-14, theta += deltaTheta | we are roughly in the center of the square and deltaTheta was calculated by rising or falling edge detection
+		odo.setPosition(new double [] {0.0, 0.0, odo.getTheta() + deltaTheta}, new boolean [] {true, true, true});
+		
+	}
+	
+	/**
+	 * Pings Ultrasonic sensor, waits for return and applys median filtering to the Ultrasonic data
+	 * @return
+	 */
+	/*public int getFilteredData() {
+		int distance;
+		
+		// do a ping
+		us.ping();
+		
+		// wait for the ping to complete
+		try { Thread.sleep(20); } catch (InterruptedException e) {}
+		
+		// there will be a delay here
+		distance = us.getDistance();
+		
+		//add the current value to array of values
+		usValues.add(distance);	
+		
+		//make sure we have sufficient number of samples
+		if(usValues.size() >= 5) {
+									
+			int result;
+			
+			//array of sorted values
+			List<Integer> usValuesSorted = new ArrayList<Integer>(usValues);
+			
+			//length of values (should be 5)
+			int size = usValuesSorted.size();
+			
+			//sort the values: lowest to highest
+			for(int i=0; i<size; i++) {
+				for(int j=i+1; j<size;j++) {
+					if(usValuesSorted.get(i) > usValuesSorted.get(j)) {
+						int temp = usValuesSorted.get(i);
+						usValuesSorted.set(i, usValuesSorted.get(j));
+						usValuesSorted.set(j, temp);					
+					}
+				}
+			}
+			
+			// if odd pick the middle value, else average the two middle values
+			if(size % 2 == 1 ) {
+				result = usValuesSorted.get(size/2);
+			} else {
+				result = ( usValuesSorted.get(size/2-1) + usValuesSorted.get(size/2) ) / 2;
+			}
+			
+			//shift values left by 1 for next iteration
+			usValues.remove(0);
+
+			//return result
+			return result;
+		} 
+		//not enough data for filtering yet, so return the current value
+		else {
+			return distance;
+		}		
+				
+	}*/
+	
+	/**
+	 * Pings Ultrasonic sensor, waits for return and applys difference filtering to the Ultrasonic data
+	 * @return
+	 */
+	/*public void getFilteredData2(int[] data) {
+		
+		int usCurrentValue = getFilteredData();
+		
+		// Smooth and difference
+		data[0] = -usLastValue + usCurrentValue;
+		data[1] = usCurrentValue;
+		usLastValue = usCurrentValue;
+		
+	}*/
+
+}
diff --git a/Group-15/Lab5-15/UltrasonicPoller.java b/Group-15/Lab5-15/UltrasonicPoller.java
new file mode 100644
index 0000000..9181659
--- /dev/null
+++ b/Group-15/Lab5-15/UltrasonicPoller.java
@@ -0,0 +1,235 @@
+import java.util.ArrayList;
+import java.util.List;
+
+import lejos.nxt.NXTRegulatedMotor;
+import lejos.nxt.UltrasonicSensor;
+import lejos.nxt.comm.RConsole;
+import lejos.util.TimerListener;
+import lejos.util.Timer;
+
+/**
+ * 
+ * @project Lab 5 Object Recognition 
+ * @names Riley van Ryswyk & Aditya Saha
+ * @studentID 260447357 & 260453165
+ * @group 15
+ * @course ECSE 211 
+ * @date 10/22/2013
+ * 
+ * Class for interaction with ultrasonic sensor
+ * 
+ */
+public class UltrasonicPoller implements TimerListener {
+
+	private UltrasonicSensor us;
+	
+	//period to Update Ultrasonic sensor in ms
+	private final int PERIOD = 35;
+	
+	// Store list of previous ultrasonic sensor values for filtering
+	private List<Integer> usValues = new ArrayList<Integer>();
+	
+	//Ultrasonic motor
+	private NXTRegulatedMotor usMotor;
+	
+	private Odometer odo;
+	
+	private Timer usTimer;
+	
+	// True if we are polling the ultrasonic sensor once a period
+	private boolean started;
+	
+	private Object lock;
+	
+	/**
+	 * UltrasonicPoller constructor
+	 * @param us
+	 * @param usMotor
+	 * @param odo
+	 */
+	public UltrasonicPoller(UltrasonicSensor us, NXTRegulatedMotor usMotor, Odometer odo) {
+		this.us = us;
+		this.usTimer = new Timer(PERIOD, this);
+		this.started = false;
+		this.lock = new Object();
+		this.usMotor = usMotor;
+		this.odo = odo;
+		
+		//limit usMotor acceleration
+		usMotor.setAcceleration(1000);
+		//stop continuous mode of Ultrasonic sensor
+		us.off();
+		
+	}
+	
+	/**
+	 * Called once a period when started
+	 * calls pingUS()
+	 */
+	public void timedOut() {
+		pingUS();		
+	}
+	
+	/**
+	 * Pings ultrasonic sensor and records the result
+	 */
+	public void pingUS() {
+		int distance;
+		
+		// do a ping
+		us.ping();
+		
+		// wait for the ping to complete
+		try { Thread.sleep(30); } catch (InterruptedException e) {}
+		
+		// there will be a delay here
+		distance = us.getDistance();
+
+		synchronized (lock) {
+		
+			if(usValues.size() > 4) { 
+				//remove the oldest one
+				usValues.remove(0);
+			}
+			
+			//add the current value to array of values
+			usValues.add(distance);
+		}
+	}
+	
+	/**
+	 * Starts the timer for the timeOut method
+	 */
+	public void start() {
+		if(!started) {
+			usTimer.start(); 
+			this.started = true;
+		}
+	}
+	
+	/**
+	 * stops the timer for the timeOut method
+	 */
+	public void stop() {
+		if(started) {
+			usTimer.stop();
+			this.started = false;
+		}
+	}
+	
+	/**
+	 * clears all stored values
+	 */
+	public void clear() {
+		usValues.clear();
+	}
+	
+	/**
+	 * takes 5 readings from the ultrasonic sensor
+	 * and returns the filtered distance
+	 * @return
+	 */
+	public int scan() {
+		stop();
+		
+		synchronized (lock) {
+			usValues.clear();			
+		}
+		
+		pingUS();
+		pingUS();
+		pingUS();
+		pingUS();
+		pingUS();
+		
+		return filterUS();
+		
+	}
+	
+	
+	/**
+	 * Rotates the ultrasonic sensor to face the desired heading 
+	 * it will limit the rotation to what is physically possible by the robot design
+	 * @param heading
+	 */
+	public void rotateUS(int heading) {
+		
+		int robotHeading = (int) odo.getTheta();
+		
+		//relative to the robots heading to ensure it doesn't go backwards or something like that
+		int rotateTo =  robotHeading - heading;
+		
+		//limits the angle of rotation
+		if(rotateTo < -120) {
+			rotateTo  = -120;
+		} else if(rotateTo > 40) {
+			rotateTo = 40;
+		}
+		
+		//rotate the ultrasonic sensor
+		usMotor.rotateTo(rotateTo);
+		
+	}
+	
+	/**
+	 * filters the data store in the usValues array using mode filtering
+	 * if the length of usVaules is less than 3, it will return the last reading
+	 * @return filtered distance
+	 */
+	public int filterUS() {
+		//make sure we have sufficient number of samples
+		if(usValues.size() >= 3) {
+			
+			//initialize vars
+			int result;
+			int size;
+			List<Integer> usValuesSorted;
+			
+			//make sure nothing changes while copying array reading usValues
+			synchronized (lock) {
+				//array of sorted values
+				usValuesSorted = new ArrayList<Integer>(usValues);
+			}
+			
+			//length of values (should be 5)
+			size = usValuesSorted.size();
+			
+			//sort the values: lowest to highest
+			for(int i=0; i<size; i++) {
+				for(int j=i+1; j<size;j++) {
+					if(usValuesSorted.get(i) > usValuesSorted.get(j)) {
+						int temp = usValuesSorted.get(i);
+						usValuesSorted.set(i, usValuesSorted.get(j));
+						usValuesSorted.set(j, temp);					
+					}
+				}
+			}
+			
+			
+			// if odd pick the middle value, else average the two middle values
+			if(size % 2 == 1 ) {
+				result = usValuesSorted.get(size/2);
+			} else {
+				result = ( usValuesSorted.get(size/2-1) + usValuesSorted.get(size/2) ) / 2;
+			}
+
+			//return result
+			return result;
+		} 
+		//not enough data for filtering yet, so return the current value
+		else {
+			int result; 
+			synchronized (lock) {
+				if (usValues.size() > 0) {
+					result = usValues.get(usValues.size()-1);
+				} else {
+					result = 256;
+				}
+			}
+			
+			return result;
+		}
+	}
+	
+	
+}
diff --git a/Group-15/Lab5-15/old.zip b/Group-15/Lab5-15/old.zip
new file mode 100644
index 0000000..92c68ea
Binary files /dev/null and b/Group-15/Lab5-15/old.zip differ

commit 28dcc7a556d15d31e4288c88a897ea5f24d3683e
Author: danielle-mustillo <danielle.mustillo@mail.mcgill.ca>
Date:   Sat Nov 2 15:16:55 2013 -0400

    Create README.md

diff --git a/README.md b/README.md
new file mode 100644
index 0000000..b58710c
--- /dev/null
+++ b/README.md
@@ -0,0 +1,4 @@
+ECSE-211-Team-5
+===============
+
+The repository for all your code and the current code. 
